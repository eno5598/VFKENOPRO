<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO CRAZY ‚Äì High-End Vorhersage</title>
<style>
  :root {
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041; --text:#e5e7eb;
    --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444; --pink:#a78bfa;
  }
  body {margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  a{color:#93c5fd;text-decoration:none}
  .box{max-width:1140px;margin:0 auto}
  input[type="file"],input[type="number"],select{
    width:100%;padding:10px;border-radius:10px;border:1px solid var(--muted);background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 240px}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .status{
    margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);
    border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap;
    max-height:240px;overflow:auto
  }
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .fc-line{border:1px solid var(--muted);border-radius:8px;padding:6px;margin-bottom:4px}
  .combo{font-weight:800}
  .badge{display:inline-block;padding:2px 8px;border:1px solid var(--muted);border-radius:999px;margin-left:8px}
  .crazyBanner{
    background:linear-gradient(135deg,#a78bfa,#ec4899);color:#120a1a;font-weight:800;text-align:center;border-radius:12px;padding:10px
  }
</style>
</head>
<body>
<div class="box">

  <!-- üóÇÔ∏è Archiv -->
  <div class="panel" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2></div>
    <input type="file" id="file" accept=".csv,.txt,.zip">
    <div class="hint">Unterst√ºtzt: CSV/TXT mit KENO-Zahlen oder ZIP von Lotto-Bayern<br>
      <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
    </div>
    <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
  </div>

  <!-- üéõÔ∏è Einstellungen -->
  <div class="panel" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">üéõÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div>
        <label>KENO-Typ</label>
        <select id="kenoType">
          <option value="2">Typ 2</option><option value="3">Typ 3</option><option value="4">Typ 4</option>
          <option value="5">Typ 5</option><option value="6" selected>Typ 6</option>
          <option value="7">Typ 7</option><option value="8">Typ 8</option>
          <option value="9">Typ 9</option><option value="10">Typ 10</option>
        </select>
      </div>
      <div>
        <label>Wieviele Vorschl√§ge anzeigen?</label>
        <input type="number" id="numResults" value="6" min="1" max="50">
      </div>
    </div>
  </div>

  <!-- üîÆ CRAZY Vorhersage -->
  <div class="panel" style="border-left:6px solid var(--pink)">
    <div class="crazyBanner">üîÆ CRAZY-VORHERSAGE ‚Äì nutzt IMMER das gesamte Archiv</div>
    <div class="row" style="margin-top:6px">
      <button id="fcStart" class="primary">Start</button>
      <button id="fcPause" class="secondary" disabled>Pause</button>
      <button id="fcResume" class="secondary" disabled>Weiter</button>
      <button id="fcReset" class="danger" disabled>Zur√ºcksetzen</button>
      <button id="fcShow" class="secondary" disabled>Top Vorschl√§ge zeigen</button>
    </div>
    <div id="fcInfo" class="status">bereit</div>
    <div id="fcResults" class="results"></div>

    <div id="finalBlock" class="panel" style="display:none;border-left:6px solid var(--accent2)">
      <h2>üèÅ Finale Vorschl√§ge</h2>
      <div id="finalCombos" class="grid"></div>
    </div>
  </div>

</div>

<!-- JSZip zum Entpacken -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<!-- ====== TEIL 2 WIRD GENAU HIER EINGEF√úGT ====== -->
<script>
(function(){
  "use strict";
  /* ===== Kurz-Utils ===== */
  const $=s=>document.querySelector(s);
  const text=(el,s)=>{ if(el){ el.textContent=s; el.scrollTop=el.scrollHeight; } };
  const html=(el,s)=>{ if(el) el.innerHTML=s; };
  const uniqSorted=a=>Array.from(new Set(a)).sort((x,y)=>x-y);
  const fmt=(n)=>n.toLocaleString("de-DE");
  const pct=(x)=> (x<=0? "0,00%" : (x*100).toFixed(2).replace(".",",")+"%");

  /* ===== Persistenz-Keys ===== */
  const CACHE_KEY="keno_archive_v3";
  const SNAP_KEY="keno_snapshot_v2";   // Snapshot des Workers (f√ºr Pause/Weiter)
  const LIVE_KEY="keno_livebest_v1";   // Live-Topliste (f√ºr ‚ÄûTop Vorschl√§ge zeigen‚Äú)

  /* ===== Globale Variablen ===== */
  let g_draws=[], g_drawSize=0; // komplettes Archiv
  let fcWorker=null;            // Web Worker
  let running=false;

  /* ===== Archiv-Parsing robuster ===== */
  function splitSmart(line){
    if(/\t/.test(line)) return line.split("\t");
    if(line.includes(";")) return line.split(";");
    if(line.includes("|")) return line.split("|");
    if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
    return line.trim().split(/\s+/);
  }
  function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}
  function tryZahlHeader(rows){
    if(!rows.length) return null;
    const header=rows[0].map(x=>String(x).trim());
    const idx=[]; for(let i=0;i<header.length;i++) if(/^zahl\s*\d+$/i.test(header[i])) idx.push(i);
    if(idx.length>=5){
      const lists=[];
      for(let r=1;r<rows.length;r++){
        const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
        if(nums.length) lists.push(nums);
      }
      return {lists, info:`Header erkannt (${idx.length} Zahl-Spalten)`};
    }
    return null;
  }
  function detectDashCol(rows){
    let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
    let best=-1,score=-1;
    for(let c=0;c<maxCols;c++){
      let sc=0;
      for(const r of rows){
        if(c>=r.length) continue;
        const cell=String(r[c]??"").trim(); if(!cell) continue;
        const parts=cell.split("-");
        if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }
  function fallbackExtract(raw){
    const out=[];
    for(const lnRaw of raw.split(/\r?\n/)){
      const ln=lnRaw.trim(); if(!ln) continue;
      if(/^\d+(?:-\d+)+$/.test(ln)){ out.push(ln.split("-").map(n=>parseInt(n,10))); continue; }
      const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
      if(nums.length>=5) out.push(nums);
    }
    return out;
  }
  function loadArchiveFromRawText(raw, sourceLabel){
    const rows=parseTable(raw);
    let lists=[], detected="";
    const h=tryZahlHeader(rows);
    if(h){ lists=h.lists; detected=h.info; }
    else{
      const ncol=detectDashCol(rows);
      if(ncol>=0){
        for(const r of rows){
          if(ncol>=r.length) continue;
          const cell=String(r[ncol]??"").trim(); if(!cell) continue;
          const parts=cell.split("-").map(s=>s.trim());
          if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
        }
        detected="Spalte 1-4-‚Ä¶";
      }else{
        lists=fallbackExtract(raw);
        detected="Freie Zahlzeilen (Fallback)";
      }
    }
    if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");
    const count=new Map(); for(const a of lists){ count.set(a.length,(count.get(a.length)||0)+1); }
    g_drawSize=[...count.entries()].sort((a,b)=>b[1]-a[1])[0][0];
    g_draws=lists.filter(a=>a.length===g_drawSize).map(a=>uniqSorted(a));
    if(!g_draws.length) throw new Error("Nach Filter auf dominierende L√§nge keine Ziehungen.");

    localStorage.setItem(CACHE_KEY, JSON.stringify({draws:g_draws, drawSize:g_drawSize, savedAt:Date.now(), source:sourceLabel||""}));
    text($("#statusTop"), `Archiv geladen: ${fmt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}${sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:""}`);
    // Reset Lauf-Anzeigen
    text($("#fcInfo"), "bereit");
    $("#finalBlock").style.display="none";
    $("#fcShow").disabled=false;
  }
  async function handleAnyFile(file){
    if(!file){ text($("#statusTop"),"Keine Datei gew√§hlt."); return; }
    text($("#statusTop"),`Lese Datei: ${file.name}`);
    const name=(file.name||"").toLowerCase();
    try{
      if(name.endsWith(".zip")){
        if(!window.JSZip){ text($("#statusTop"),"Fehler: JSZip (CDN) nicht verf√ºgbar."); return; }
        const ab=await file.arrayBuffer();
        const zip=await JSZip.loadAsync(ab);
        const candidates=[];
        zip.forEach((path, entry)=>{
          const p=path.toLowerCase();
          if(p.endsWith(".csv")||p.endsWith(".txt")){
            const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
            candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
          }
        });
        if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
        candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
        const target=candidates[0];
        let raw="";
        try{ raw=await target.entry.async("string"); }
        catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(raw, `ZIP: ${target.path}`);
      }else{
        let txt="";
        try{ txt=await file.text(); }
        catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(txt, file.name||"Upload");
      }
    }catch(e){
      text($("#statusTop"), "Fehler beim Lesen: "+(e?.message||e));
      g_draws=[]; g_drawSize=0;
    }
  }
  $("#file").addEventListener("change", ()=> handleAnyFile($("#file").files[0]));
  (function init(){
    try{
      const raw=localStorage.getItem(CACHE_KEY);
      if(raw){
        const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
        if(g_draws.length){
          text($("#statusTop"), `Archiv aus Browser geladen: ${fmt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize})`);
          $("#fcShow").disabled=false;
        }
      }
    }catch{}
    // Falls alter Snapshot existiert ‚Üí ‚ÄûWeiter‚Äú erm√∂glichen
    if(localStorage.getItem(SNAP_KEY)){
      $("#fcResume").disabled=false;
      $("#fcShow").disabled=false;
      text($("#fcInfo"), ($("#fcInfo").textContent||"bereit") + "\n(Es liegt ein gespeicherter Snapshot vor)");
    }
  })();

  /* ===== Worker erzeugen (schwerer Algorithmus) ===== */
  function ensureWorker(){
    if(fcWorker) return;
    const code = `
      let STATE=null; // arbeitet immer mit gesamten Archiv-Ausschnitt (drawsSub)

      function rnd(seed){ let t=seed>>>0; return ()=>{ t=(t+0x6D2B79F5)>>>0; let r=t^(t>>>15); r=Math.imul(r^(r>>>7),61|r); r=(r^(r>>>14))>>>0; return r/4294967296; }; }
      const sum=a=>a.reduce((s,x)=>s+x,0);

      // Grundstatistiken
      function freq(draws){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=1&&v<=70) f[v]++; return f; }
      function lastSeen(draws){ const last=Array(71).fill(-1); for(let i=0;i<draws.length;i++) for(const v of draws[i]) last[v]=i; return last; }
      function pairCo(draws){
        const M=Array.from({length:71},()=>Array(71).fill(0));
        for(const d of draws){
          for(let i=0;i<d.length;i++) for(let j=i+1;j<d.length;j++){
            const a=d[i],b=d[j]; if(a>=1&&a<=70&&b>=1&&b<=70){ M[a][b]++; M[b][a]++; }
          }
        }
        return M;
      }
      function gapWeights(draws){
        const w=Array(70).fill(0);
        const base = draws.length>20000 ? draws.slice(-20000) : draws;
        for(const d of base){
          const s=d.slice().sort((a,b)=>a-b);
          for(let i=1;i<s.length;i++){
            const g=s[i]-s[i-1];
            if(g>=1 && g<=69) w[g]+=1;
          }
        }
        for(let i=2;i<69;i++) w[i]=0.25*w[i-1]+0.5*w[i]+0.25*w[i+1];
        let m=Math.max(1, ...w); for(let i=1;i<=69;i++) w[i]/=m;
        return w;
      }
      function norm(p){ let s=0; for(let i=1;i<=70;i++) s+=p[i]; if(s<=0){ for(let i=1;i<=70;i++) p[i]=1/70; return p; } for(let i=1;i<=70;i++) p[i]/=s; return p; }
      function baseP(drawsSub, drawsAll){
        const f=freq(drawsSub), last=lastSeen(drawsAll), nAll=drawsAll.length;
        const p=Array(71).fill(0);
        for(let i=1;i<=70;i++){
          const since=(last[i]<0)?nAll:(nAll-1-last[i]);
          const boost = 1 + Math.min(2.2, since/Math.max(10, nAll/28)); // st√§rkere Recency-Bevorzugung
          p[i] = (f[i] + 0.6) * boost;
        }
        // leichte Dreiteilungs-Gl√§ttung
        for(const [L,R,w] of [[1,23,1.05],[24,47,1.02],[48,70,1.00]]){
          let s=0; for(let i=L;i<=R;i++) s+=p[i];
          const avg=s/Math.max(1,(R-L+1));
          for(let i=L;i<=R;i++) p[i] = 0.8*p[i] + 0.2*avg*w;
        }
        return norm(p);
      }

      function sampleOne(p, used, rng){
        let sum=0; for(let i=1;i<=70;i++) if(!used.has(i)) sum+=p[i];
        let r=rng()*sum, acc=0;
        for(let i=1;i<=70;i++){ if(used.has(i)) continue; acc+=p[i]; if(acc>=r) return i; }
        for(let i=1;i<=70;i++) if(!used.has(i) && p[i]>0) return i;
        return -1;
      }
      function drawS(pBase, pair, S, rng){
        const used=new Set(); const out=[];
        while(out.length<S){
          const p=pBase.slice();
          if(out.length){
            for(let i=1;i<=70;i++){
              if(used.has(i)){ p[i]=0; continue; }
              let sc=0; for(const a of out){ sc+=pair[i][a]; }
              p[i]*=(1 + sc*0.0018);
            }
          }
          norm(p);
          const pick=sampleOne(p,used,rng);
          if(pick<0) break;
          used.add(pick); out.push(pick);
        }
        out.sort((a,b)=>a-b); return out;
      }
      function gapScore(arr, GAPW){
        let sc=0;
        for(let i=1;i<arr.length;i++){
          const g=arr[i]-arr[i-1];
          if(g>=1 && g<=69) sc += (GAPW[g]||0);
        }
        return sc/(arr.length-1||1);
      }
      function scoreCombo(arr, PBASE, PAIR, GAPW){
        let sProb=0; for(const v of arr) sProb += Math.log(Math.max(1e-12, PBASE[v]));
        let sPair=0; for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) sPair += PAIR[arr[i]][arr[j]];
        let sGap = gapScore(arr, GAPW);
        let low=0, mid=0, high=0; for(const v of arr){ if(v<=23) low++; else if(v<=47) mid++; else high++; }
        const bal = 1 - (Math.abs(low-mid)+Math.abs(mid-high)+Math.abs(low-high))/(2*arr.length);
        return  1.00*sProb + 0.002*sPair + 0.50*sGap + 0.25*bal;
      }

      function buildState(payload){
        const {drawsAll, drawsSub, S, want, seed, maxIter} = payload;
        const PBASE = baseP(drawsSub, drawsAll);
        const PAIR  = pairCo(drawsSub);
        const GAPW  = gapWeights(drawsAll);
        return {
          drawsAll, drawsSub, S, want,
          PBASE, PAIR, GAPW,
          iter:0, maxIter, paused:false,
          rng: rnd((seed>>>0)||1),
          best: [] // Array {k:"1-2-..", sc:number, ct:number}
        };
      }

      function pushBest(STATE, tip, sc){
        const k=tip.join("-");
        const found = STATE.best.find(it=>it.k===k);
        if(found){ found.ct++; found.sc = Math.max(found.sc, sc); }
        else{
          STATE.best.push({k, sc, ct:1});
        }
        // Topliste begrenzen
        const cap = Math.max(STATE.want*10, 200);
        if(STATE.best.length>cap){
          STATE.best.sort((a,b)=> b.sc-a.sc || b.ct-a.ct || (a.k<b.k?-1:1));
          STATE.best.length=cap;
        }
      }

      function tick(){
        if(!STATE || STATE.paused) return;
        for(let t=0; t<2000; t++){ // Burst
          const tip = drawS(STATE.PBASE, STATE.PAIR, STATE.S, STATE.rng);
          const sc  = scoreCombo(tip, STATE.PBASE, STATE.PAIR, STATE.GAPW);
          pushBest(STATE, tip, sc);
          STATE.iter++;
          // adaptiv leicht PBASE justieren nach beobachteter H√§ufigkeit
          if(STATE.iter % 5000 === 0){
            // cool/warm: milde Anpassung
            for(let i=1;i<=70;i++){
              STATE.PBASE[i] = Math.max(1e-12, STATE.PBASE[i] * 1.001);
            }
            let s=0; for(let i=1;i<=70;i++) s+=STATE.PBASE[i]; for(let i=1;i<=70;i++) STATE.PBASE[i]/=s;
          }
          if(STATE.iter>=STATE.maxIter) break;
        }

        if(STATE.iter % 10000 === 0){
          const live = STATE.best.slice().sort((a,b)=> b.sc-a.sc || b.ct-a.ct).slice(0, Math.max(STATE.want*2,12));
          postMessage({type:"progress", iter:STATE.iter, best: live});
        }

        if(STATE.iter>=STATE.maxIter){
          const out = STATE.best.slice().sort((a,b)=> b.sc-a.sc || b.ct-a.ct).slice(0, STATE.want);
          postMessage({type:"done", best: out, iter:STATE.iter});
          STATE=null; return;
        }
        setTimeout(tick, 0);
      }

      function snapshot(){
        if(!STATE) return null;
        // serialisierbarer Snapshot
        return {
          S:STATE.S, want:STATE.want, iter:STATE.iter, maxIter:STATE.maxIter,
          PBASE:STATE.PBASE, PAIR:STATE.PAIR, GAPW:STATE.GAPW,
          best:STATE.best, paused:true
        };
      }

      onmessage = (e)=>{
        const m=e.data;
        if(m.cmd==="start"){
          STATE = buildState(m);
          postMessage({type:"started", maxIter:STATE.maxIter});
          tick();
        }else if(m.cmd==="resume"){
          // Resume: STATE aus m.snap + draws (nicht im Snap)
          STATE = {
            drawsAll:m.drawsAll, drawsSub:m.drawsSub,
            S:m.snap.S, want:m.snap.want,
            PBASE:m.snap.PBASE, PAIR:m.snap.PAIR, GAPW:m.snap.GAPW,
            iter:m.snap.iter, maxIter:m.snap.maxIter, paused:false,
            rng: rnd((m.seed>>>0)||1),
            best:m.snap.best || []
          };
          postMessage({type:"resumed", iter:STATE.iter, maxIter:STATE.maxIter});
          tick();
        }else if(m.cmd==="pause"){
          const snap=snapshot();
          postMessage({type:"paused", snap});
          if(STATE) STATE.paused=true;
        }else if(m.cmd==="stop"){
          STATE=null; postMessage({type:"stopped"});
        }
      };
    `;
    const blob=new Blob([code],{type:"application/javascript"});
    const url=URL.createObjectURL(blob);
    fcWorker=new Worker(url);

    // Worker Events
    fcWorker.onmessage=(ev)=>{
      const m=ev.data;
      if(m.type==="started"){
        log(`üöÄ gestartet ¬∑ Ziel-Iterationen: ${fmt(m.maxIter)}`);
        $("#fcPause").disabled=false; $("#fcReset").disabled=false; $("#fcShow").disabled=false;
        running=true;
      }else if(m.type==="progress"){
        saveLiveBest(m.best);
        renderLive(m.best, m.iter);
      }else if(m.type==="paused"){
        saveSnapshot(m.snap);
        log("‚è∏Ô∏è pausiert ¬∑ Snapshot gespeichert");
        $("#fcPause").disabled=true; $("#fcResume").disabled=false; running=false;
      }else if(m.type==="resumed"){
        log(`‚ñ∂Ô∏è weiter bei Iteration ${fmt(m.iter)} ¬∑ Ziel: ${fmt(m.maxIter)}`);
        $("#fcPause").disabled=false; $("#fcResume").disabled=true; running=true;
      }else if(m.type==="stopped"){
        log("üõë gestoppt");
        running=false;
      }else if(m.type==="done"){
        saveLiveBest(m.best);
        log(`üèÅ fertig ¬∑ insgesamt ${fmt(m.iter)} Iterationen`);
        renderFinal(m.best);
        running=false;
        $("#fcPause").disabled=true; $("#fcResume").disabled=true;
      }
    };
    fcWorker.onerror=(e)=>{
      log("‚ùå Fehler im Worker: "+(e.message||"unbekannt"));
      running=false;
      $("#fcPause").disabled=true; $("#fcResume").disabled=false;
    };
  }

  /* ===== Log & Rendering ===== */
  function log(line){
    const el=$("#fcInfo");
    el.textContent = (el.textContent? el.textContent+"\n" : "") + line;
    el.scrollTop=el.scrollHeight;
  }
  function saveSnapshot(snap){
    if(!snap) return;
    try{ localStorage.setItem(SNAP_KEY, JSON.stringify(snap)); }catch{}
    $("#fcResume").disabled=false;
  }
  function loadSnapshot(){
    try{ const raw=localStorage.getItem(SNAP_KEY); return raw? JSON.parse(raw) : null; }catch{ return null; }
  }
  function clearSnapshot(){
    try{ localStorage.removeItem(SNAP_KEY); }catch{}
    $("#fcResume").disabled=true;
  }
  function saveLiveBest(list){
    try{ localStorage.setItem(LIVE_KEY, JSON.stringify(list||[])); }catch{}
  }
  function loadLiveBest(){
    try{ const raw=localStorage.getItem(LIVE_KEY); return raw? JSON.parse(raw):[]; }catch{ return []; }
  }

  function renderLive(list, iter){
    const want = Math.max(1, Math.min(50, parseInt($("#numResults").value,10)||6));
    const best = (list||[]).slice(0, Math.max(want*2, 12));
    const lines = best.map((it,i)=>{
      const nums = `<span class="combo">${it.k.replace(/-/g," ")}</span>`;
      const meta = `<span class="badge">Score ${it.sc.toFixed(3)} ¬∑ Hits ${it.ct}</span>`;
      return `<div class="fc-line">#${i+1} ${nums} ${meta}</div>`;
    }).join("");
    html($("#fcResults"), (lines || "(noch keine Daten)")+ (iter? `<div class="badge">Iterationen: ${fmt(iter)}</div>`:""));
  }
  function renderFinal(list){
    const want = Math.max(1, Math.min(50, parseInt($("#numResults").value,10)||6));
    const items = (list||[]).slice(0, want);
    const box=$("#finalCombos"); box.innerHTML="";
    if(!items.length){ $("#finalBlock").style.display=""; box.innerHTML='<div class="status">(keine Daten)</div>'; return; }
    for(const it of items){
      const div=document.createElement("div");
      div.className="fc-line";
      div.innerHTML = `<span class="combo">${it.k.replace(/-/g," ")}</span> <span class="badge">Score ${it.sc.toFixed(3)} ¬∑ Hits ${it.ct}</span>`;
      box.appendChild(div);
    }
    $("#finalBlock").style.display="";
  }
  function showTopNow(){
    const list=loadLiveBest();
    if(!list || !list.length){ alert("Noch keine Live-Ergebnisse gespeichert."); return; }
    renderFinal(list);
  }

  /* ===== Dynamische Rechenlast (maxIter) =====
     ‚Äì skaliert mit Archivgr√∂√üe N und KENO-Typ S
     ‚Äì w√§chst mit N^0.85 und S^2, plus Basisterm
  */
  function autoMaxIter(N,S){
    const base = 150000;                    // Grundbudget
    const nterm = Math.pow(Math.max(1,N), 0.85) * 35; // je mehr Historie, desto h√∂her
    const sterm = (S*S) * 800;              // gr√∂√üere Kombi ‚Üí deutlich mehr
    const maxIters = Math.floor(base + nterm + sterm);
    // Safety Cap sehr hoch, damit er wirklich lange rechnen kann, aber Browser nicht killt
    return Math.min(maxIters, 50_000_000); // 50 Mio Iterationen als absolute Obergrenze
  }

  /* ===== Steuerung ===== */
  function startRun(){
    if(!g_draws.length){ alert("Bitte zuerst Archiv laden (ZIP/CSV/TXT)."); return; }
    if(running){ alert("Lauf l√§uft bereits."); return; }
    ensureWorker();
    const S=parseInt($("#kenoType").value,10)||6;
    const want=Math.max(1, Math.min(50, parseInt($("#numResults").value,10)||6));
    const drawsSub=g_draws.slice(); // IMMER gesamtes Archiv
    const N=drawsSub.length;
    const maxIter=autoMaxIter(N,S);
    const seed = (Date.now() ^ (N*131) ^ (S*7919))>>>0;

    // UI
    $("#fcStart").disabled=true; $("#fcPause").disabled=false; $("#fcReset").disabled=false; $("#fcShow").disabled=false;
    text($("#fcInfo"), "Starte‚Ä¶");
    $("#finalBlock").style.display="none";

    // livebest l√∂schen
    saveLiveBest([]);

    fcWorker.postMessage({cmd:"start", drawsAll:g_draws, drawsSub, S, want, seed, maxIter});
  }
  function pauseRun(){
    if(!fcWorker || !running) return;
    fcWorker.postMessage({cmd:"pause"});
  }
  function resumeRun(){
    const snap=loadSnapshot();
    if(!snap){ alert("Kein Snapshot gefunden."); return; }
    if(running){ alert("Lauf l√§uft bereits."); return; }
    ensureWorker();
    const drawsSub=g_draws.slice();
    const seed=(Date.now()>>>0);
    $("#fcStart").disabled=true; $("#fcPause").disabled=false; $("#fcResume").disabled=true; $("#fcReset").disabled=false; $("#fcShow").disabled=false;
    log("‚ñ∂Ô∏è Resume‚Ä¶");
    fcWorker.postMessage({cmd:"resume", snap, drawsAll:g_draws, drawsSub, seed});
  }
  function resetRun(){
    if(fcWorker){ try{ fcWorker.terminate(); }catch{} fcWorker=null; }
    running=false;
    clearSnapshot();
    saveLiveBest([]);
    $("#fcStart").disabled=false; $("#fcPause").disabled=true; $("#fcResume").disabled=true; $("#fcReset").disabled=true;
    text($("#fcInfo"), "zur√ºckgesetzt");
    $("#fcResults").innerHTML="";
    $("#finalBlock").style.display="none";
  }

  // Buttons
  $("#fcStart").addEventListener("click", startRun);
  $("#fcPause").addEventListener("click", pauseRun);
  $("#fcResume").addEventListener("click", resumeRun);
  $("#fcReset").addEventListener("click", resetRun);
  $("#fcShow").addEventListener("click", showTopNow);
})();
</script>
</body>
</html>