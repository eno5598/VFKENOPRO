<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO Analyzer ‚Äì 7-Gruppen/Hot-Paare (deterministisch)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041;
    --text:#e5e7eb; --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444; --pink:#a78bfa;
  }
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  .box{max-width:1140px;margin:0 auto}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  input[type="file"],select,input[type="number"],input[type="text"]{
    width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid var(--muted);
    background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);
          border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  progress{width:100%;height:14px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-value{background:#22c55e}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .fc-line{border:1px solid var(--muted);border-radius:8px;padding:6px;margin-bottom:4px}
  .badge{display:inline-block;padding:2px 6px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:6px;font-size:13px}
  .chip{background:var(--bg);border:1px solid var(--muted);border-radius:999px;padding:4px 8px;margin:2px;display:inline-block}
  .row{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
<div class="box">

  <!-- Archiv laden -->
  <div class="panel">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2></div>
    <input type="file" id="file" accept=".csv,.txt,.zip">
    <div class="status" style="margin-top:8px">
      Offizielles ZIP (manuell laden & hier ausw√§hlen):
      <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
    </div>
    <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
  </div>

  <!-- Einstellungen -->
  <div class="panel">
    <div class="ph"><span class="emoji">‚öôÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div style="flex:1 1 220px">
        <label>KENO-Typ</label>
        <select id="kenoType">
          <option value="2">Typ 2</option>
          <option value="3">Typ 3</option>
          <option value="4">Typ 4</option>
          <option value="5">Typ 5</option>
          <option value="6" selected>Typ 6</option>
          <option value="7">Typ 7</option>
          <option value="8">Typ 8</option>
          <option value="9">Typ 9</option>
          <option value="10">Typ 10</option>
        </select>
      </div>
      <div style="flex:1 1 220px">
        <label>Zielzeit</label>
        <select id="target">
          <option value="300">‚âà 5 min</option>
          <option value="600" selected>‚âà 10 min</option>
          <option value="0">High-End (max)</option>
        </select>
      </div>
      <div style="flex:1 1 220px">
        <label>Top-Kombis anzeigen</label>
        <select id="topShow">
          <option value="12">12</option>
          <option value="24" selected>24</option>
          <option value="48">48</option>
          <option value="72">72</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Analyse -->
  <div class="panel" id="p-analyse">
    <div class="ph"><span class="emoji">üîç</span><h2 style="margin:0">Analyse (7 Gruppen + Hot-Paare, deterministisch)</h2></div>
    <div class="row" style="margin-bottom:8px">
      <button id="start" class="primary">Start</button>
      <button id="pause" class="secondary" disabled>Pause</button>
      <button id="resume" class="secondary" disabled>Weiter</button>
      <button id="stop" class="danger" disabled>Stopp</button>
      <button id="showFinal" class="secondary" disabled>Top 6 anzeigen</button>
    </div>
    <progress id="prog" value="0" max="1" style="display:none"></progress>
    <div id="status" class="status">bereit</div>
    <div id="results" class="results"></div>
    <div id="finalBlock" class="panel" style="display:none">
      <h3>üèÅ Finale 6 Vorschl√§ge</h3>
      <div id="finalCombos" class="grid"></div>
    </div>
  </div>

  <!-- Tipp-Analyse -->
  <div class="panel" id="p-tip">
    <div class="ph"><span class="emoji">üìù</span><h2 style="margin:0">Tipp-Analyse</h2></div>
    <input type="text" id="tipInput" placeholder="z. B. 10 11 22 24 48 52">
    <button id="checkTip" class="secondary" style="margin-top:6px">Tipp analysieren</button>
    <div id="tipStatus" class="status" style="display:none"></div>
  </div>

</div>

<!-- ======= TEIL 2 direkt HIER drunter einf√ºgen ======= -->
</body>
</html>
<script>
(function(){
"use strict";

/* ===== Helpers ===== */
const $ = s => document.querySelector(s);
const text = (el, s) => { if(el) el.textContent = s; };
const html = (el, s) => { if(el) el.innerHTML = s; };
const uniqSorted = a => Array.from(new Set(a)).sort((x,y)=>x-y);
const fmtInt = n => (n||0).toLocaleString("de-DE");
const pct = x => ((x*100).toFixed(2)+"%").replace(".", ",");

/* ===== Archiv laden (CSV/TXT/ZIP) ===== */
const CACHE_KEY = "keno_grp7_archive_v1";
let g_draws = [], g_drawSize = 0;

function splitSmart(line){
  if(/\t/.test(line)) return line.split("\t");
  if(line.includes(";")) return line.split(";");
  if(line.includes("|")) return line.split("|");
  if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
  return line.trim().split(/\s+/);
}
function parseTable(text){ return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart); }
function tryZahlHeader(rows){
  if(!rows.length) return null;
  const header = rows[0].map(x=>String(x).trim());
  const idx = [];
  for(let i=0;i<header.length;i++) if(/^zahl\s*\d+$/i.test(header[i])) idx.push(i);
  if(idx.length>=5){
    const lists=[];
    for(let r=1;r<rows.length;r++){
      const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
      if(nums.length) lists.push(nums);
    }
    return {lists, info:`Header erkannt (${idx.length} Zahl-Spalten)`};
  }
  return null;
}
function detectDashCol(rows){
  let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
  let best=-1,score=-1;
  for(let c=0;c<maxCols;c++){
    let sc=0;
    for(const r of rows){
      if(c>=r.length) continue;
      const cell=String(r[c]??"").trim(); if(!cell) continue;
      const parts=cell.split("-");
      if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
    }
    if(sc>score){score=sc;best=c;}
  }
  return best;
}
function fallbackExtract(raw){
  const out=[];
  for(const lnRaw of raw.split(/\r?\n/)){
    const ln=lnRaw.trim(); if(!ln) continue;
    if(/^\d+(?:-\d+)+$/.test(ln)){
      out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); continue;
    }
    const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    if(nums.length>=5) out.push(nums);
  }
  return out;
}
function loadArchiveFromRawText(raw, sourceLabel){
  text($("#statusTop"), "Analysiere Datei ‚Ä¶");
  const rows=parseTable(raw);
  let lists=[], detected="";
  const h=tryZahlHeader(rows);
  if(h){ lists=h.lists; detected=h.info; }
  else{
    const ncol=detectDashCol(rows);
    if(ncol>=0){
      for(const r of rows){
        if(ncol>=r.length) continue;
        const cell=String(r[ncol]??"").trim(); if(!cell) continue;
        const parts=cell.split("-").map(s=>s.trim());
        if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
      }
      detected="Spalte 1-4-‚Ä¶";
    }else{
      lists=fallbackExtract(raw);
      detected="Fallback: freie Zahlzeilen";
    }
  }
  if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");

  const freq=new Map();
  for(const a of lists){ if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1); }
  let bestLen=0,bestCnt=-1;
  for(const [k,v] of freq.entries()){ if(v>bestCnt){ bestCnt=v; bestLen=k; } }
  if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");

  g_drawSize=bestLen;
  g_draws = lists.filter(a=>a.length===g_drawSize).map(a=>uniqSorted(a.filter(Number.isInteger)));
  if(!g_draws.length) throw new Error("Nach Filter auf dominierende L√§nge keine Ziehungen √ºbrig.");

  try{
    localStorage.setItem(CACHE_KEY, JSON.stringify({draws:g_draws, drawSize:g_drawSize, savedAt:Date.now(), source:sourceLabel||""}));
  }catch{}

  const ts=new Date();
  text($("#statusTop"),
    `Archiv geladen: ${fmtInt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}`+
    (sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:"")+
    `\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`
  );
  html($("#results"),""); $("#finalBlock").style.display="none";
  text($("#status"),"bereit"); $("#prog").style.display="none";
}
async function ensureJSZip(){
  if(window.JSZip) return;
  await new Promise((res,rej)=>{
    const s=document.createElement("script");
    s.src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
    s.onload=res; s.onerror=()=>rej(new Error("JSZip laden fehlgeschlagen"));
    document.head.appendChild(s);
  });
}
async function handleAnyFile(file){
  if(!file){ text($("#statusTop"),"Keine Datei gew√§hlt."); return; }
  text($("#statusTop"),`Lese Datei: ${file.name}`);
  const name=(file.name||"").toLowerCase();
  try{
    if(name.endsWith(".zip")){
      await ensureJSZip();
      const ab=await file.arrayBuffer();
      const zip=await JSZip.loadAsync(ab);
      const candidates=[];
      zip.forEach((path, entry)=>{
        const p=path.toLowerCase();
        if(p.endsWith(".csv")||p.endsWith(".txt")){
          const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
          candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
        }
      });
      if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
      candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
      const target=candidates[0];
      text($("#statusTop"),`Entpacke & lese: ${target.path}`);
      let raw="";
      try{ raw=await target.entry.async("string"); }
      catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
      loadArchiveFromRawText(raw, `ZIP: ${target.path}`);
    }else{
      let txt="";
      try{ txt=await file.text(); }
      catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
      loadArchiveFromRawText(txt, file.name||"Upload");
    }
  }catch(e){
    text($("#statusTop"),"Fehler beim Lesen: "+(e?.message||e));
    g_draws=[]; g_drawSize=0;
  }
}
$("#file").addEventListener("change", ()=> handleAnyFile($("#file").files[0]));
(function initFromCache(){
  try{
    const raw=localStorage.getItem(CACHE_KEY);
    if(raw){
      const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
      if(g_draws.length){
        const ts=obj.savedAt?new Date(obj.savedAt):new Date();
        const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
        text($("#statusTop"),
          `Archiv aus Browser geladen: ${fmtInt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize})${src}\n`+
          `Gespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`
        );
      }else{
        text($("#statusTop"),"Bereit. (Kein Archiv geladen)");
      }
    }else{
      text($("#statusTop"),"Bereit. (Kein Archiv geladen)");
    }
  }catch{ text($("#statusTop"),"Bereit. (Kein Archiv geladen)"); }
})();

/* ===== Worker: 7-Gruppen + Hot-Paare, Zeitgesteuerte Beam-Suche ===== */
let worker=null, runState="idle", lastBest=[];
function buildWorker(){
  if(worker) try{worker.terminate();}catch{}
  const code = `
  let CFG=null, STATE=null; // CFG: config, STATE: runtime
  const uniqSorted = a => Array.from(new Set(a)).sort((x,y)=>x-y);
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const groupOf = v => Math.ceil(v/10); // 1..7 (61-70 -> 7)

  function freq(draws){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=1&&v<=70) f[v]++; return f; }
  function lastSeen(draws){ const last=Array(71).fill(-1); for(let i=0;i<draws.length;i++) for(const v of draws[i]) last[v]=i; return last; }
  function coMatrix(draws){
    const M=Array.from({length:71},()=>Array(71).fill(0));
    for(const d of draws){
      for(let i=0;i<d.length;i++) for(let j=i+1;j<d.length;j++){
        const a=d[i],b=d[j]; if(a>=1&&a<=70&&b>=1&&b<=70){ M[a][b]++; M[b][a]++; }
      }
    }
    return M;
  }
  function PMI(draws){
    const N=draws.length, f=freq(draws), co=coMatrix(draws);
    const p=Array(71).fill(0).map((_,i)=> i? (f[i]/(N||1)) : 0);
    const P=Array.from({length:71},()=>Array(71).fill(0));
    for(let a=1;a<=70;a++) for(let b=1;b<=70;b++){
      if(a===b){P[a][b]=0;continue;}
      const pab=co[a][b]/(N||1); const den=(p[a]*p[b])||1e-12;
      P[a][b]=Math.log((pab||1e-12)/den);
    }
    return {P,co};
  }
  function gapHistogram(draws){
    const H=Array(70).fill(0);
    for(const d of draws){
      const s=d.slice().sort((a,b)=>a-b);
      for(let i=1;i<s.length;i++){
        const g=s[i]-s[i-1];
        if(g>=1&&g<=69) H[g]++;
      }
    }
    for(let i=2;i<=68;i++) H[i]=0.25*H[i-1]+0.5*H[i]+0.25*H[i+1];
    let mx=1; for(let i=1;i<=69;i++) if(H[i]>mx) mx=H[i];
    for(let i=1;i<=69;i++) H[i]/=mx||1;
    return H;
  }
  function baseProb(draws){
    const f=freq(draws), last=lastSeen(draws), N=draws.length, p=Array(71).fill(0);
    for(let i=1;i<=70;i++){
      const due=(last[i]<0)?N:(N-1-last[i]);
      const boost = 1 + Math.min(1.8, due/Math.max(12, N/30));
      p[i]=(f[i]+0.5)*boost;
    }
    let s=0; for(let i=1;i<=70;i++) s+=p[i]; if(s<=0){for(let i=1;i<=70;i++) p[i]=1/70;} else {for(let i=1;i<=70;i++) p[i]/=s;}
    return p;
  }

  // Ziel-Gruppenprofil f√ºr S aus Archiv ableiten (+Nachbarschaft)
  function groupProfile(draws, S){
    const cnt=Array(8).fill(0), tot=Array(8).fill(0), N=draws.length;
    for(const d of draws){
      for(const v of d){ const g=groupOf(v); if(g>=1&&g<=7){ tot[g]++; } }
    }
    const share=Array(8).fill(0);
    let sum=0; for(let g=1;g<=7;g++){ share[g]=tot[g]/Math.max(1, N*g<=0?1: N*g ); } // robust
    // direkte Proportionen
    const target=Array(8).fill(0);
    let rest=S;
    // grob nach Anteil
    const raw=Array(8).fill(0).map((_,g)=> g? share[g]*S : 0);
    for(let g=1;g<=7;g++){ target[g]=Math.floor(raw[g]); rest-=target[g]; }
    // verteile Reste an gr√∂√üte Bruchteile
    const frac=[]; for(let g=1;g<=7;g++) frac.push({g, f: raw[g]-target[g]});
    frac.sort((a,b)=> b.f-a.f || a.g-b.g);
    for(let i=0;i<rest;i++) target[frac[i%frac.length].g]++;
    // mind. 1 in aktiven Segmenten (falls m√∂glich)
    for(let g=1;g<=7;g++){
      if(target[g]===0 && tot[g]>0 && rest>0){ target[g]++; rest--; }
    }
    // Varianten in Nachbarschaft (¬±1 verschieben)
    const variants=[];
    const base=target.slice();
    variants.push(base);
    for(let a=1;a<=7;a++) for(let b=1;b<=7;b++){
      if(a===b) continue;
      if(base[a]>0){
        const v=base.slice(); v[a]--; v[b]++; // Summe bleibt S
        variants.push(v);
      }
    }
    // dedup & nur plausible (kein Segment <0)
    const seen=new Set(), out=[];
    for(const v of variants){
      let ok=true, sum2=0;
      for(let g=1;g<=7;g++){ if(v[g]<0) ok=false; sum2+=v[g]; }
      if(!ok || sum2!==S) continue;
      const k=v.join(",");
      if(!seen.has(k)){ seen.add(k); out.push(v); }
    }
    // leicht begrenzen
    return out.slice(0, 24);
  }

  // Score: pBase + PMI + Gap + Balance + Gruppenmatch
  function scoreOf(arr, ctx){
    const {P, gapW, pBase, grpTarget} = ctx;
    let sProb=0; for(const v of arr) sProb+=Math.log(Math.max(1e-12, pBase[v]));
    let sPair=0; for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) sPair+=P[arr[i]][arr[j]];
    let sGap=0; for(let i=1;i<arr.length;i++){ const g=arr[i]-arr[i-1]; if(g>=1&&g<=69) sGap+=gapW[g]; }
    sGap/=Math.max(1,arr.length-1);
    // Gruppen√ºbereinstimmung
    const cg=Array(8).fill(0); for(const v of arr) cg[groupOf(v)]++;
    let sGrp=0; for(let g=1;g<=7;g++){ const diff=Math.abs((grpTarget[g]||0)-(cg[g]||0)); sGrp += -diff; } // je n√§her desto besser
    // Balance (unter/mitte/oben 1-23/24-47/48-70)
    let low=0,mid=0,high=0; for(const v of arr){ if(v<=23) low++; else if(v<=47) mid++; else high++; }
    const bal = 1 - (Math.abs(low-mid)+Math.abs(mid-high)+Math.abs(low-high))/(2*arr.length);
    return 1.00*sProb + 0.40*sPair + 0.60*sGap + 0.35*sGrp + 0.20*bal;
  }

  // Kandidaten-Ordering pro Segment
  function rankNumbers(pBase, P){
    // Einzelwert + bestes Paarpotenzial (Top-Partner)
    const r=Array(71).fill(0);
    for(let v=1;v<=70;v++){
      let top=0;
      for(let u=1;u<=70;u++){ if(u===v) continue; if(P[v][u]>top) top=P[v][u]; }
      r[v]=Math.log(Math.max(1e-12,pBase[v])) + 0.35*top;
    }
    return r;
  }

  function start(cfg){
    CFG=cfg; // S, targetSec, drawsAll
    // volle Basis nutzen
    const draws=CFG.drawsAll;
    const pBase=baseProb(draws);
    const gapW=gapHistogram(draws);
    const {P} = PMI(draws);
    const grpVariants = groupProfile(draws, CFG.S);
    const rank = rankNumbers(pBase, P);
    // pro Gruppe sortierte Kandidaten
    const groups = Array.from({length:8},()=>[]);
    for(let v=1;v<=70;v++){ const g=groupOf(v); groups[g].push(v); }
    for(let g=1;g<=7;g++){ groups[g].sort((a,b)=> rank[b]-rank[a] || a-b); }

    STATE={
      startTime: performance.now(),
      targetSec: CFG.targetSec,
      iter:0, paused:false, stop:false,
      variants: grpVariants,
      varIdx: 0,
      best: new Map(),
      ctxBase: {P, gapW, pBase},
      groups, rank
    };
    tick();
  }

  function expandVariant(){
    const S=CFG.S;
    if(STATE.varIdx>=STATE.variants.length) return false;
    const target=STATE.variants[STATE.varIdx];
    const ctx = {...STATE.ctxBase, grpTarget: target};
    // Beam-Suche gef√ºhrt durch Gruppenbedarf
    const beamW = CFG.beam;
    let frontier=[{arr:[], last:0, need: target.slice(), score:0}];

    function nextGroupOrder(need){
      // w√§hle Gruppe mit gr√∂√ütem Rest, bei Gleichstand die ‚Äûst√§rkste‚Äú (Summe Rank top-k)
      let bestG=1, bestV=-1;
      for(let g=1;g<=7;g++){
        if(need[g]<=0) continue;
        // approx St√§rke
        let s=0; for(let i=0;i<Math.min(need[g], groups[g].length); i++) s+=STATE.rank[groups[g][i]];
        const v=need[g]*1000 + s; // priorisiere Menge, dann Qualit√§t
        if(v>bestV){bestV=v; bestG=g;}
      }
      return bestG;
    }

    const groups=STATE.groups;
    for(let depth=0; depth<S; depth++){
      const next=[];
      for(const node of frontier){
        const g = nextGroupOrder(node.need);
        if(!g){ continue; }
        // Kandidaten aus Gruppe g (gefiltert > last)
        let pushed=0;
        for(const v of groups[g]){
          if(v<=node.last) continue;
          if(node.need[g]<=0) continue;
          const arr = node.arr.concat(v);
          // schneller Prune: zu viele Zahlen in einem Segment?
          const need2=node.need.slice(); need2[g]--;
          // Score inkrementell (am Ende genauer)
          const sc = scoreOf(arr, ctx);
          next.push({arr, last:v, need:need2, score:sc});
          if(++pushed>=CFG.branchPerStep) break; // begrenze pro Knoten
        }
      }
      next.sort((a,b)=> b.score-a.score || a.arr.length-b.arr.length || a.arr.join("-").localeCompare(b.arr.join("-")));
      frontier = next.slice(0, beamW);
      if((depth+1)%2===0) postMessage({type:"phase", depth:depth+1, beam:frontier.length, var:STATE.varIdx+1, varTotal:STATE.variants.length});
    }

    // fertige Kandidaten einsammeln
    for(const node of frontier){
      if(node.arr.length===S){
        const k=node.arr.join("-");
        const val=STATE.best.get(k)||0;
        STATE.best.set(k, val + node.score);
      }
    }
    STATE.varIdx++;
    return true;
  }

  function elapsedSec(){ return (performance.now()-STATE.startTime)/1000; }

  function tick(){
    if(!STATE || STATE.stop) return;
    if(STATE.paused){ setTimeout(tick,200); return; }

    const targetSec=STATE.targetSec;
    // Eine Variantenerweiterung pro Tick (damit UI regelm√§√üig updatet)
    const ok = expandVariant();
    STATE.iter++;

    // Fortschritt
    if(STATE.iter%1===0){
      const best = Array.from(STATE.best.entries())
        .sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]))
        .slice(0, Math.min(60, CFG.showN))
        .map(([k,score])=>({k,score}));
      let max=best.length? best[0].score : 1;
      const out = best.map(x=>({k:x.k, idx:+( (x.score/max)*100 ).toFixed(1), raw:+x.score.toFixed(3)}));
      postMessage({type:"progress", var:STATE.varIdx, varTotal:STATE.variants.length, elapsed:elapsedSec(), list:out});
    }

    // Stoppkriterien
    if(targetSec>0 && elapsedSec()>=targetSec){
      finish(); return;
    }
    if(!ok){
      finish(); return;
    }
    setTimeout(tick,0);
  }

  function finish(){
    const best = Array.from(STATE.best.entries())
      .sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]))
      .slice(0, CFG.showN)
      .map(([k,score])=>({k,score}));
    let max=best.length? best[0].score : 1;
    const out = best.map(x=>({k:x.k, idx:+( (x.score/max)*100 ).toFixed(1), raw:+x.score.toFixed(3)}));
    postMessage({type:"done", list: out});
    STATE=null;
  }

  onmessage = e=>{
    const m=e.data;
    if(m.cmd==="start") start(m.cfg);
    else if(m.cmd==="pause"){ if(STATE){ STATE.paused=true; postMessage({type:"paused"});} }
    else if(m.cmd==="resume"){ if(STATE){ STATE.paused=false; postMessage({type:"resumed"});} }
    else if(m.cmd==="stop"){ if(STATE){ STATE.stop=true; } postMessage({type:"stopped"}); }
  };
  `;
  const blob=new Blob([code],{type:'application/javascript'});
  const url=URL.createObjectURL(blob);
  worker=new Worker(url);
  worker.onmessage = onWorkerMsg;
  worker.onerror = e=>{ text($("#status"), "Fehler im Worker: "+(e.message||"unbekannt")); resetButtons(); };
}

function onWorkerMsg(ev){
  const m=ev.data;
  if(m.type==="phase"){
    const prev = $("#status").textContent;
    text($("#status"), `${prev}\nVariante ${m.var}/${m.varTotal} ¬∑ Tiefe ${m.depth} ¬∑ Beam=${fmtInt(m.beam)}`);
  }else if(m.type==="progress"){
    $("#prog").style.display=""; // ‚Äûpseudo‚Äú-Fortschritt: Anteil Varianten + Zeit
    const frac = (m.varTotal? (m.var/m.varTotal) : 0.5);
    $("#prog").value=Math.max(0, Math.min(1, frac));
    renderResults(m.list||[]);
    text($("#status"), `Variante ${m.var}/${m.varTotal} ¬∑ verstrichen ${m.elapsed.toFixed(1)}s ¬∑ Kandidaten=${fmtInt((m.list||[]).length)}`);
    lastBest = m.list||[];
  }else if(m.type==="paused"){
    runState="paused";
    $("#pause").disabled=true; $("#resume").disabled=false; $("#stop").disabled=false; $("#showFinal").disabled=false;
  }else if(m.type==="resumed"){
    runState="running";
    $("#pause").disabled=false; $("#resume").disabled=true; $("#stop").disabled=false;
  }else if(m.type==="stopped"){
    runState="idle"; resetButtons(true); finalizeTop6From(lastBest);
  }else if(m.type==="done"){
    runState="idle"; resetButtons(true); renderResults(m.list||[]); finalizeTop6From(m.list||[]);
  }
}

function resetButtons(hasFinal){
  $("#start").disabled=false; $("#pause").disabled=true; $("#resume").disabled=true; $("#stop").disabled=true;
  $("#showFinal").disabled = !hasFinal;
  $("#prog").style.display="none";
}

/* ===== UI-Render ===== */
function renderResults(list){
  const take = parseInt($("#topShow").value,10)||24;
  const out = (list||[]).slice(0,take).map((it,i)=>{
    const nums = it.k.replace(/-/g," ");
    const ginfo = grpInfo(it.k);
    return `<div class="fc-line">
      <b>${i+1}. ${nums}</b>
      <span class="badge">Score-Index: ${it.idx}</span>
      <span class="badge">Gruppen: ${ginfo}</span>
      <button class="secondary" style="margin-left:8px" data-tip="${it.k}">Tipp analysieren</button>
    </div>`;
  }).join("");
  html($("#results"), out || "<div class='fc-line'>(keine Kandidaten)</div>");
}

function grpInfo(key){
  const arr=key.split("-").map(x=>+x);
  const cnt=[0,0,0,0,0,0,0,0];
  for(const v of arr){ cnt[Math.ceil(v/10)]++; }
  const labels=["","1-10","11-20","21-30","31-40","41-50","51-60","61-70"];
  const parts=[];
  for(let g=1;g<=7;g++){ if(cnt[g]>0) parts.push(labels[g]+":"+cnt[g]); }
  return parts.join(" | ");
}

function finalizeTop6From(list){
  const top6 = (list||[]).slice(0,6);
  $("#finalBlock").style.display="";
  if(!top6.length){ html($("#finalCombos"), "<div class='fc-line'>(keine Daten)</div>"); return; }
  const out = top6.map(it=>`<div class="fc-line"><b>${it.k.replace(/-/g," ")}</b><span class="badge">Score-Index: ${it.idx}</span><span class="badge">${grpInfo(it.k)}</span></div>`).join("");
  html($("#finalCombos"), out);
}

/* ===== Steuerung ===== */
function startAnalysis(){
  if(!g_draws.length){ alert("Bitte zuerst ein Archiv laden."); return; }
  const S = parseInt($("#kenoType").value,10)||6;
  const targetSec = parseInt($("#target").value,10)||0;
  buildWorker();
  runState="running";
  $("#start").disabled=true; $("#pause").disabled=false; $("#resume").disabled=true; $("#stop").disabled=false; $("#showFinal").disabled=true;
  $("#prog").style.display=""; $("#prog").value=0;
  text($("#status"), `Start ‚Äì S=${S} ¬∑ Zielzeit=${targetSec>0?(targetSec+"s"):"High-End"} ¬∑ Archiv=${fmtInt(g_draws.length)} Ziehungen`);
  // Beam/Branch abh√§ngig von Zielzeit
  const beam = targetSec===0 ? 18000 : targetSec>=600 ? 12000 : 8000;
  const branchPerStep = targetSec===0 ? 18 : targetSec>=600 ? 14 : 10;
  worker.postMessage({cmd:"start", cfg:{
    S, targetSec, drawsAll: g_draws, showN: parseInt($("#topShow").value,10)||24,
    beam, branchPerStep
  }});
}
function pauseAnalysis(){ if(worker && runState==="running"){ worker.postMessage({cmd:"pause"}); } }
function resumeAnalysis(){ if(worker && runState==="paused"){ worker.postMessage({cmd:"resume"}); } }
function stopAnalysis(){ if(worker){ worker.postMessage({cmd:"stop"}); } }

$("#start").addEventListener("click", startAnalysis);
$("#pause").addEventListener("click", pauseAnalysis);
$("#resume").addEventListener("click", resumeAnalysis);
$("#stop").addEventListener("click", stopAnalysis);
$("#showFinal").addEventListener("click", ()=> document.getElementById("finalBlock").scrollIntoView({behavior:"smooth", block:"start"}));

/* ===== Tipp-Analyse (gleiche Features) ===== */
$("#results").addEventListener("click",(e)=>{
  const btn=e.target.closest("button[data-tip]");
  if(!btn) return;
  $("#tipInput").value = btn.getAttribute("data-tip").split("-").join(" ");
  document.getElementById("p-tip").scrollIntoView({behavior:"smooth", block:"start"});
  setTimeout(()=>runTipAnalysis(), 80);
});
$("#checkTip").addEventListener("click", runTipAnalysis);

function runTipAnalysis(){
  if(!g_draws.length){ alert("Bitte Archiv laden."); return; }
  const raw=String($("#tipInput").value||"").trim();
  let arr=(raw.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
  arr=uniqSorted(arr);
  if(!arr.length){ alert("Kein Tipp erkannt."); return; }

  // gleiche Stats
  function freq(draws){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=1&&v<=70) f[v]++; return f; }
  function coMatrix(draws){
    const M=Array.from({length:71},()=>Array(71).fill(0));
    for(const d of draws){ for(let i=0;i<d.length;i++) for(let j=i+1;j<d.length;j++){ const a=d[i],b=d[j]; if(a>=1&&a<=70&&b>=1&&b<=70){ M[a][b]++; M[b][a]++; } } }
    return M;
  }
  function PMI(draws){
    const N=draws.length, f=freq(draws), co=coMatrix(draws);
    const p=Array(71).fill(0).map((_,i)=> i? (f[i]/(N||1)) : 0);
    const P=Array.from({length:71},()=>Array(71).fill(0));
    for(let a=1;a<=70;a++) for(let b=1;b<=70;b++){
      if(a===b){P[a][b]=0;continue;}
      const pab=co[a][b]/(N||1), den=(p[a]*p[b])||1e-12;
      P[a][b]=Math.log((pab||1e-12)/den);
    }
    return P;
  }
  function gapHistogram(draws){
    const H=Array(70).fill(0);
    for(const d of draws){
      const s=d.slice().sort((a,b)=>a-b);
      for(let i=1;i<s.length;i++){ const g=s[i]-s[i-1]; if(g>=1&&g<=69) H[g]++; }
    }
    for(let i=2;i<=68;i++) H[i]=0.25*H[i-1]+0.5*H[i]+0.25*H[i+1];
    let mx=1; for(let i=1;i<=69;i++) if(H[i]>mx) mx=H[i];
    for(let i=1;i<=69;i++) H[i]/=mx||1;
    return H;
  }
  function baseProb(draws){
    const f=freq(draws), p=Array(71).fill(0);
    for(let i=1;i<=70;i++){ p[i]=(f[i]+0.5); }
    let s=0; for(let i=1;i<=70;i++) s+=p[i]; for(let i=1;i<=70;i++) p[i]/=s||1;
    return p;
  }

  const pBase=baseProb(g_draws), P=PMI(g_draws), gapW=gapHistogram(g_draws);
  const grpTarget = (function(){ // bestes Profil f√ºr arr.length
    const S=arr.length;
    // einfache Ableitung: proportional zu Archiv
    const tot=Array(8).fill(0);
    for(const d of g_draws) for(const v of d) tot[Math.ceil(v/10)]++;
    const raw=Array(8).fill(0); for(let g=1;g<=7;g++) raw[g]=tot[g]/Math.max(1, g_draws.length);
    const v=Array(8).fill(0); let rest=S;
    for(let g=1;g<=7;g++){ v[g]=Math.floor(raw[g]*S); rest-=v[g]; }
    const frac=[]; for(let g=1;g<=7;g++) frac.push({g, f:raw[g]*S - v[g]});
    frac.sort((a,b)=> b.f-a.f);
    for(let i=0;i<rest;i++) v[frac[i%frac.length].g]++;
    return v;
  })();

  function scoreOf(a){
    let sProb=0; for(const v of a) sProb+=Math.log(Math.max(1e-12,pBase[v]));
    let sPair=0; for(let i=0;i<a.length;i++) for(let j=i+1;j<a.length;j++) sPair+=P[a[i]][a[j]];
    let sGap=0; for(let i=1;i<a.length;i++){ const g=a[i]-a[i-1]; if(g>=1&&g<=69) sGap+=gapW[g]; } sGap/=Math.max(1,a.length-1);
    const cg=Array(8).fill(0); for(const v of a) cg[Math.ceil(v/10)]++;
    let sGrp=0; for(let g=1;g<=7;g++){ sGrp += -Math.abs((grpTarget[g]||0)-(cg[g]||0)); }
    return 1.00*sProb + 0.40*sPair + 0.60*sGap + 0.35*sGrp;
  }

  const sc=scoreOf(arr);
  const gaps = arr.slice(1).map((v,i)=> v-arr[i]);
  const cnt=[0,0,0,0,0,0,0,0]; for(const v of arr) cnt[Math.ceil(v/10)]++;
  const labels=["","1-10","11-20","21-30","31-40","41-50","51-60","61-70"];
  const gtxt=[]; for(let g=1;g<=7;g++) if(cnt[g]) gtxt.push(labels[g]+":"+cnt[g]);

  $("#tipStatus").style.display="";
  $("#tipStatus").textContent = [
    "Tipp: "+arr.join(" "),
    "Score (relativ): "+sc.toFixed(3),
    "Gruppen: "+gtxt.join(" | "),
    "Abst√§nde: ["+gaps.join(", ")+"]"
  ].join("\n");
}

/* ===== Buttons ===== */
$("#start").addEventListener("click", startAnalysis);
function startAnalysis(){
  if(!g_draws.length){ alert("Bitte zuerst ein Archiv laden."); return; }
  const S = parseInt($("#kenoType").value,10)||6;
  const targetSec = parseInt($("#target").value,10)||0;
  buildWorker();
  runState="running";
  $("#start").disabled=true; $("#pause").disabled=false; $("#resume").disabled=true; $("#stop").disabled=false; $("#showFinal").disabled=true;
  $("#prog").style.display=""; $("#prog").value=0;
  text($("#status"), `Start ‚Äì S=${S} ¬∑ Zielzeit=${targetSec>0?(targetSec+"s"):"High-End"} ¬∑ Archiv=${fmtInt(g_draws.length)} Ziehungen`);
  const beam = targetSec===0 ? 18000 : targetSec>=600 ? 12000 : 8000;
  const branchPerStep = targetSec===0 ? 18 : targetSec>=600 ? 14 : 10;
  worker.postMessage({cmd:"start", cfg:{
    S, targetSec, drawsAll: g_draws, showN: parseInt($("#topShow").value,10)||24, beam, branchPerStep
  }});
}
$("#pause").addEventListener("click", ()=>{ if(worker && runState==="running"){ worker.postMessage({cmd:"pause"}); } });
$("#resume").addEventListener("click", ()=>{ if(worker && runState==="paused"){ worker.postMessage({cmd:"resume"}); } });
$("#stop").addEventListener("click", ()=>{ if(worker){ worker.postMessage({cmd:"stop"}); } });
$("#showFinal").addEventListener("click", ()=> document.getElementById("finalBlock").scrollIntoView({behavior:"smooth", block:"start"}));

/* Tipp Analyse Button */
$("#results").addEventListener("click",(e)=>{
  const btn=e.target.closest("button[data-tip]");
  if(!btn) return;
  $("#tipInput").value = btn.getAttribute("data-tip").split("-").join(" ");
  document.getElementById("p-tip").scrollIntoView({behavior:"smooth", block:"start"});
  setTimeout(()=>$("#checkTip").click(), 80);
});
$("#checkTip").addEventListener("click", ()=>{}); // Handler ist in runTipAnalysis gebunden
})();
</script>