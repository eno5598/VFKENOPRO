<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO CRAZY – Vorhersage der nächsten 6 Ziehungen</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041; --text:#e5e7eb;
    --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444; --pink:#a78bfa;
  }
  html,body{height:100%}
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  a{color:#93c5fd;text-decoration:none}
  .box{max-width:1140px;margin:0 auto}
  input[type="file"],select,input[type="number"]{
    width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid var(--muted);background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 240px}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .block{border:1px dashed var(--muted);border-radius:10px;padding:10px}
  .head{font-weight:800;margin-bottom:6px}
  .chips{display:flex;flex-wrap:wrap;gap:8px}
  .chip{border:1px solid var(--muted);border-radius:999px;padding:4px 8px}
  .combos{margin-top:8px;display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:6px}
  .line{border:1px solid var(--muted);border-radius:8px;padding:6px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:8px}

  @keyframes crazyPulse {
    0% { background-color:#0b1220; box-shadow: inset 0 0 0 0 rgba(167,139,250,0.00); }
    50%{ background-color:#120f2b; box-shadow: inset 0 0 60px 0 rgba(167,139,250,0.14); }
    100%{ background-color:#0f0b26; box-shadow: inset 0 0 60px 0 rgba(236,72,153,0.12); }
  }
  body.crazy { animation: crazyPulse 1.2s infinite alternate; }

  .crazyBanner{
    background:linear-gradient(135deg,#a78bfa,#ec4899);
    color:#120a1a;border:1px solid #9a7ff8;border-radius:12px;padding:10px;font-weight:800;
    text-align:center;margin-bottom:6px
  }

  progress{width:100%;height:12px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-bar{background:var(--bg)}
  progress::-webkit-progress-value{background:#22c55e}
</style>
</head>
<body class="crazy">
<div class="box">

  <!-- 🗂️ Archiv -->
  <div class="panel" id="p-archiv" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">🗂️</span><h2 style="margin:0">Archiv laden</h2><span class="badge">ZIP wird lokal entpackt</span></div>

    <label>CSV/TXT oder ZIP auswählen</label>
    <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">

    <div class="status" id="statusTop">Bereit. (Kein Archiv geladen)</div>

    <div class="hint" style="margin-top:6px">
      Unterstützt: <b>„Zahl1..Zahl20“</b>-Tabellen, <b>eine Spalte „1-4-…“</b> oder <b>freie Zahlzeilen</b> (mind. 5 Zahlen).<br>
      ZIP darf eine CSV/TXT enthalten (am besten „keno/archiv“ im Namen).<br>
      Download (manuell):
      <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
    </div>

    <div class="row" style="margin-top:6px">
      <button id="clearCache" class="danger">Archiv löschen</button>
    </div>
  </div>

  <!-- 🎛️ Einstellungen -->
  <div class="panel" id="p-settings" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">🎛️</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div>
        <label>Kombi-Größe (KENO-Typ)</label>
        <select id="kenoType">
          <option value="2">Typ 2</option><option value="3">Typ 3</option><option value="4">Typ 4</option>
          <option value="5">Typ 5</option><option value="6" selected>Typ 6</option><option value="7">Typ 7</option>
          <option value="8">Typ 8</option><option value="9">Typ 9</option><option value="10">Typ 10</option>
        </select>
      </div>
      <div>
        <label>Datenbasis</label>
        <select id="fcLevel">
          <option value="normal" selected>Normal (erste 1.000)</option>
          <option value="medium">Mittel (erste 3.000)</option>
          <option value="hard">Hard (gesamtes Archiv)</option>
          <option value="maximum">Maximum (High-End)</option>
        </select>
      </div>
      <div>
        <label>Zielzeit</label>
        <select id="fcTarget">
          <option value="0" selected>Unbegrenzt</option>
          <option value="900">≈ 15 min</option>
          <option value="1800">≈ 30 min</option>
          <option value="3600">≈ 1 h</option>
          <option value="7200">≈ 2 h</option>
          <option value="10800">≈ 3 h</option>
        </select>
      </div>
      <div>
        <label>Sim-Burst pro Tick</label>
        <input type="number" id="fcBurst" value="2000" min="500" step="500">
      </div>
      <div>
        <label>Seed</label>
        <input type="number" id="seed" value="1" min="0">
      </div>
    </div>
  </div>

  <!-- 🔮 CRAZY Vorhersage -->
  <div class="panel" id="p-crazy" style="border-left:6px solid var(--pink)">
    <div class="crazyBanner">🔮 CRAZY-VORHERSAGE – Volle Power (Pause → Snapshot, Weiter → nahtlos)</div>

    <div class="row" style="margin-top:6px">
      <button id="fcStart" class="primary">Start</button>
      <button id="fcPause" class="secondary" disabled>Pause & sichern</button>
      <button id="fcResume" class="secondary" disabled>Weiter</button>
      <button id="fcReset" class="danger" disabled>Löschen (Snapshot)</button>
      <button id="fcTop6" class="ghost" disabled>🏁 Top-6 anzeigen</button>
    </div>

    <div class="row" style="margin-top:8px">
      <div style="flex:2 1 180px"><label>Status</label><div id="fcInfo" class="status">bereit</div></div>
      <div style="flex:1 1 180px"><label>Fortschritt</label><progress id="fcProg" value="0" max="1" style="display:none"></progress></div>
    </div>

    <div id="fcResults" class="results" style="margin-top:8px"></div>

    <div class="panel" id="finalBlock" style="margin-top:12px;border-left:6px solid var(--accent2);display:none">
      <div class="ph"><span class="emoji">🏁</span><h2 style="margin:0">Top-6 Vorschläge</h2></div>
      <div id="finalCombos" class="grid"></div>
    </div>
  </div>

</div>

<!-- JSZip (ZIP-Entpacken im Browser) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<!-- TEIL 2 WIRD HIER DIREKT DARUNTER EINGEFÜGT -->
<script>
(function(){
  "use strict";
  /*** Mini-Utils ***/
  const $=s=>document.querySelector(s);
  const text=(el,s)=>{ if(el) el.textContent=s; };
  const html=(el,s)=>{ if(el) el.innerHTML=s; };
  const uniqSorted=a=>Array.from(new Set(a)).sort((x,y)=>x-y);
  const fmtPct=x=> (x>0 && x<0.0001 ? "0,01%" : (x*100).toFixed(2).replace(".",",")+"%");
  const fmtNum=x=> x.toLocaleString();

  /*** Storage Keys ***/
  const CACHE_KEY="keno_archive_v3";
  const SNAP_KEY ="keno_snapshot_v2";
  const BEST_KEY ="keno_globalbest_v2";

  /*** Runtime ***/
  let g_draws=[], g_drawSize=0;
  let fcWorker=null, fcState="idle";
  let globalBest=new Map(); // aggregiert Top-Combos (über Runden/Läufe)
  let lastProgressAt=0;     // für Auto-Snapshot

  /*** Archiv: Status-Setter ***/
  const setTop = s => text($("#statusTop"), s);

  /*** CSV/TXT/ZIP Parsing ***/
  function splitSmart(line){
    if(/\t/.test(line)) return line.split("\t");
    if(line.includes(";")) return line.split(";");
    if(line.includes("|")) return line.split("|");
    if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
    return line.trim().split(/\s+/);
  }
  function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}

  function tryZahlHeader(rows){
    if(!rows.length) return null;
    const header=rows[0].map(x=>String(x).trim());
    const idx=[]; for(let i=0;i<header.length;i++) if(/^zahl\s*\d+$/i.test(header[i])) idx.push(i);
    if(idx.length>=5){
      const lists=[];
      for(let r=1;r<rows.length;r++){
        const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
        if(nums.length) lists.push(nums);
      }
      return {lists, info:`Header erkannt (${idx.length} Zahl-Spalten)`};
    }
    return null;
  }
  function detectDashCol(rows){
    let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
    let best=-1,score=-1;
    for(let c=0;c<maxCols;c++){
      let sc=0;
      for(const r of rows){
        if(c>=r.length) continue;
        const cell=String(r[c]??"").trim(); if(!cell) continue;
        const parts=cell.split("-");
        if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }
  function fallbackExtract(raw){
    const out=[];
    for(const lnRaw of raw.split(/\r?\n/)){
      const ln=lnRaw.trim(); if(!ln) continue;
      if(/^\d+(?:-\d+)+$/.test(ln)){
        out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); continue;
      }
      const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
      if(nums.length>=5) out.push(nums);
    }
    return out;
  }

  function loadArchiveFromRawText(raw, sourceLabel){
    setTop("Analysiere Datei…");
    const rows=parseTable(raw);
    let lists=[], detected="";
    const h=tryZahlHeader(rows);
    if(h){ lists=h.lists; detected=h.info; }
    else{
      const ncol=detectDashCol(rows);
      if(ncol>=0){
        for(const r of rows){
          if(ncol>=r.length) continue;
          const cell=String(r[ncol]??"").trim(); if(!cell) continue;
          const parts=cell.split("-").map(s=>s.trim());
          if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
        }
        detected="Spalte 1-4-…";
      }else{
        lists=fallbackExtract(raw);
        detected="Fallback: freie Zahlzeilen";
      }
    }
    if(!lists.length) throw new Error("Keine gültigen Zahlen erkannt.");

    // dominierende Länge (typisch 20)
    const freq=new Map();
    for(const a of lists){ if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1); }
    let bestLen=0,bestCnt=-1;
    for(const [k,v] of freq.entries()){ if(v>bestCnt){ bestCnt=v; bestLen=k; } }
    if(!bestLen) throw new Error("Keine Listen der Länge 5–20 erkannt.");

    g_drawSize=bestLen;
    g_draws = lists.filter(a=>a.length===g_drawSize).map(a=>uniqSorted(a.filter(Number.isInteger)));
    if(!g_draws.length) throw new Error("Nach Filter auf dominierende Länge keine Ziehungen übrig.");

    try{
      localStorage.setItem(CACHE_KEY, JSON.stringify({draws:g_draws, drawSize:g_drawSize, savedAt:Date.now(), source:sourceLabel||""}));
    }catch{}
    const ts=new Date();
    setTop(`Archiv geladen: ${g_draws.length} Ziehungen (Ziehungsgröße ${g_drawSize}) · ${detected}`+
           `${sourceLabel?` · Quelle: ${sourceLabel}`:""}\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`);

    // UI reset
    $("#fcResults").innerHTML=""; $("#finalBlock").style.display="none";
    text($("#fcInfo"),"bereit"); $("#fcProg").style.display="none";
    // Snapshot behalten, aber Buttons anpassen
    updateSnapshotButtons();
  }

  async function handleAnyFile(file){
    if(!file){ setTop("Keine Datei gewählt."); return; }
    setTop(`Lese Datei: ${file.name}`);
    const name=(file.name||"").toLowerCase();
    try{
      if(name.endsWith(".zip")){
        if(!window.JSZip){ setTop("Fehler: JSZip (CDN) nicht verfügbar."); return; }
        const ab=await file.arrayBuffer();
        const zip=await JSZip.loadAsync(ab);
        const candidates=[];
        zip.forEach((path, entry)=>{
          const p=path.toLowerCase();
          if(p.endsWith(".csv")||p.endsWith(".txt")){
            const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
            candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
          }
        });
        if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden. ZIP ggf. entpacken und CSV/TXT direkt wählen.");
        candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
        const target=candidates[0];
        setTop(`Entpacke & lese: ${target.path}`);
        let raw="";
        try{ raw=await target.entry.async("string"); }
        catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(raw, `ZIP: ${target.path}`);
      }else{
        let txt="";
        try{ txt=await file.text(); }
        catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(txt, file.name||"Upload");
      }
    }catch(e){
      setTop("Fehler beim Lesen: "+(e?.message||e));
      g_draws=[]; g_drawSize=0;
    }
  }

  $("#file").addEventListener("change", ()=> handleAnyFile($("#file").files[0]));
  $("#clearCache").addEventListener("click",()=>{
    try{ localStorage.removeItem(CACHE_KEY); }catch{}
    g_draws=[]; g_drawSize=0;
    setTop("Archiv gelöscht. Bitte Datei erneut laden.");
    $("#fcResults").innerHTML=""; $("#finalBlock").style.display="none";
    text($("#fcInfo"),"bereit"); $("#fcProg").style.display="none";
    // Snapshot bleibt bestehen – Buttons prüfen
    updateSnapshotButtons();
  });

  // Init aus localStorage (Archiv & evtl. Snapshot)
  (function init(){
    try{
      const raw=localStorage.getItem(CACHE_KEY);
      if(raw){
        const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
        if(g_draws.length){
          const ts=obj.savedAt?new Date(obj.savedAt):new Date();
          const src=obj.source?` · Quelle: ${obj.source}`:"";
          setTop(`Archiv aus Browser geladen: ${g_draws.length} Ziehungen (Ziehungsgröße ${g_drawSize})${src}\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`);
        }else setTop("Bereit. (Kein Archiv geladen)");
      }else setTop("Bereit. (Kein Archiv geladen)");
    }catch{ setTop("Bereit. (Kein Archiv geladen)"); }
    // globalBest wiederherstellen
    try{
      const bestRaw=localStorage.getItem(BEST_KEY);
      if(bestRaw){
        const arr=JSON.parse(bestRaw)||[];
        globalBest=new Map(arr.map(([k,c])=>[k,c|0]));
      }
    }catch{ globalBest=new Map(); }
    updateSnapshotButtons();
  })();

  /*** Worker bereitstellen ***/
  function ensureWorker(){
    if(fcWorker) return;
    const code = `
      let STATE=null; // gesamter Laufzustand
      let PAIR=null, GAPW=null;

      function rnd(seed){ let t=seed>>>0; return ()=>{ t=(t+0x6D2B79F5)>>>0; let r=t^(t>>>15); r=Math.imul(r^(r>>>7),61|r); r=(r^(r>>>14))>>>0; return r/4294967296; }; }
      function norm(p){ let s=0; for(let i=1;i<=70;i++) s+=p[i]; if(s<=0){ for(let i=1;i<=70;i++) p[i]=1/70; return p; } for(let i=1;i<=70;i++) p[i]/=s; return p; }
      function freq(draws){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=1&&v<=70) f[v]++; return f; }
      function lastSeen(draws){ const last=Array(71).fill(-1); for(let i=0;i<draws.length;i++) for(const v of draws[i]) last[v]=i; return last; }
      function pairCo(draws){
        const M=Array.from({length:71},()=>Array(71).fill(0));
        for(const d of draws){ for(let i=0;i<d.length;i++) for(let j=i+1;j<d.length;j++){ const a=d[i],b=d[j]; if(a>=1&&a<=70&&b>=1&&b<=70){ M[a][b]++; M[b][a]++; } } }
        return M;
      }
      function gapWeights(draws){
        const w=Array(70).fill(0);
        for(const d of draws){
          const s=d.slice().sort((a,b)=>a-b);
          for(let i=1;i<s.length;i++){
            const g=s[i]-s[i-1];
            if(g>=1 && g<=69) w[g]+=1;
          }
        }
        for(let i=2;i<69;i++) w[i]=0.25*w[i-1]+0.5*w[i]+0.25*w[i+1];
        let m=Math.max(1, ...w); for(let i=1;i<=69;i++) w[i]/=m;
        return w;
      }
      function baseP(drawsSub, drawsAll, level){
        const f=freq(drawsSub), last=lastSeen(drawsAll), nAll=drawsAll.length;
        let p=f.slice();
        for(let i=1;i<=70;i++){
          const since=(last[i]<0)?nAll:(nAll-1-last[i]);
          const boost = level==='maximum' ? (1 + Math.min(2.5, since/Math.max(8, nAll/25)))
                        : level==='hard'   ? (1 + Math.min(2.0, since/Math.max(10, nAll/20)))
                        : level==='medium' ? (1 + Math.min(1.5, since/Math.max(12, nAll/30)))
                                           : (1 + Math.min(1.2, since/Math.max(15, nAll/35)));
          p[i] = (p[i] + 0.5) * boost;
        }
        for(const [L,R,w] of [[1,23,1.05],[24,47,1.02],[48,70,1.00]]){
          let s=0; for(let i=L;i<=R;i++) s+=p[i];
          const avg=s/Math.max(1,(R-L+1));
          for(let i=L;i<=R;i++) p[i] = 0.8*p[i] + 0.2*avg*w;
        }
        return norm(p);
      }
      function sampleOne(p, used, rng){
        let sum=0; for(let i=1;i<=70;i++) if(!used.has(i)) sum+=p[i];
        let r=rng()*sum, acc=0;
        for(let i=1;i<=70;i++){ if(used.has(i)) continue; acc+=p[i]; if(acc>=r) return i; }
        for(let i=1;i<=70;i++) if(!used.has(i) && p[i]>0) return i; return -1;
      }
      function drawS(pBase, pair, S, rng){
        const used=new Set(); const out=[];
        while(out.length<S){
          const p=pBase.slice();
          if(out.length){
            for(let i=1;i<=70;i++){
              if(used.has(i)) { p[i]=0; continue; }
              let sc=0; for(const a of out){ sc+=pair[i][a]; }
              p[i]*=(1 + sc*0.0018);
            }
          }
          norm(p);
          const pick=sampleOne(p,used,rng);
          if(pick<0) break;
          used.add(pick); out.push(pick);
        }
        out.sort((a,b)=>a-b); return out;
      }
      function gapScore(arr){
        let sc=0;
        for(let i=1;i<arr.length;i++){
          const g=arr[i]-arr[i-1];
          if(g>=1 && g<=69) sc += (GAPW[g]||0);
        }
        return sc/(arr.length-1||1);
      }
      function scoreCombo(arr, pBase, pair){
        let sProb=0; for(const v of arr) sProb += Math.log(Math.max(1e-12, pBase[v]));
        let sPair=0; for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) sPair += pair[arr[i]][arr[j]];
        let sGap = gapScore(arr);
        let low=0, mid=0, high=0; for(const v of arr){ if(v<=23) low++; else if(v<=47) mid++; else high++; }
        const bal = 1 - (Math.abs(low-mid)+Math.abs(mid-high)+Math.abs(low-high))/(2*arr.length);
        return  1.00*sProb + 0.002*sPair + 0.50*sGap + 0.25*bal;
      }

      function makeEmptyState(){
        return {
          round:0, rounds:6, S:6, level:"hard",
          targetSec:0, burst:2000,
          seed:1, iter:0, elapsed:0,
          paused:false,
          pbase:Array(71).fill(1/70),
          appear:Array(71).fill(0),
          combos:new Map(), // key -> score
          drawsSub:[], drawsAll:[]
        };
      }

      function toSnapshot(){
        // Top 500 zur Größe sparen
        const items=[...STATE.combos.entries()].sort((a,b)=>b[1]-a[1] || (a[0]<b[0]?-1:1)).slice(0,500);
        return {
          meta:{
            round:STATE.round, rounds:STATE.rounds, S:STATE.S, level:STATE.level,
            targetSec:STATE.targetSec, burst:STATE.burst, seed:STATE.seed,
            iter:STATE.iter, elapsed:STATE.elapsed
          },
          pbase:STATE.pbase.slice(0),
          appear:STATE.appear.slice(0),
          combos:items
        };
      }

      function fromSnapshot(snap, drawsSub, drawsAll){
        STATE = makeEmptyState();
        STATE.round    = snap.meta.round|0;
        STATE.rounds   = snap.meta.rounds|0;
        STATE.S        = snap.meta.S|0;
        STATE.level    = snap.meta.level||"hard";
        STATE.targetSec= snap.meta.targetSec|0;
        STATE.burst    = snap.meta.burst|0;
        STATE.seed     = snap.meta.seed|0;
        STATE.iter     = snap.meta.iter|0;
        STATE.elapsed  = snap.meta.elapsed||0;
        STATE.pbase    = (snap.pbase||Array(71).fill(1/70)).slice(0);
        STATE.appear   = (snap.appear||Array(71).fill(0)).slice(0);
        STATE.combos   = new Map(snap.combos||[]);
        STATE.drawsSub = drawsSub;
        STATE.drawsAll = drawsAll;
        PAIR = pairCo(STATE.drawsSub);
        GAPW = gapWeights(STATE.drawsAll.length>20000 ? STATE.drawsAll.slice(-20000) : STATE.drawsAll);
      }

      function startFresh(params){
        STATE = makeEmptyState();
        STATE.S        = params.S|0;
        STATE.level    = params.level||"hard";
        STATE.targetSec= params.targetSec|0;
        STATE.burst    = params.burst|0;
        STATE.seed     = params.seed|0;
        STATE.drawsSub = params.drawsSub||[];
        STATE.drawsAll = params.drawsAll||[];
        PAIR = pairCo(STATE.drawsSub);
        GAPW = gapWeights(STATE.drawsAll.length>20000 ? STATE.drawsAll.slice(-20000) : STATE.drawsAll);
        STATE.pbase = baseP(STATE.drawsSub, STATE.drawsAll, STATE.level);
      }

      function bestCombos(topK){
        const items=[...STATE.combos.entries()].sort((a,b)=>b[1]-a[1] || (a[0]<b[0]?-1:1)).slice(0, topK);
        return items.map(([k,c])=>({k,c}));
      }
      function topNums(total){
        const arr=[]; for(let i=1;i<=70;i++) arr.push({n:i, p: total>0? STATE.appear[i]/total : 0, c: STATE.appear[i]});
        arr.sort((a,b)=>b.p-a.p || b.c-a.c || a.n-b.n); return arr;
      }

      function stepOnce(){
        const rng = rnd(STATE.seed + STATE.round*7919 + STATE.iter);
        for(let t=0;t<STATE.burst;t++){
          const tip = drawS(STATE.pbase, PAIR, STATE.S, rng);
          const sc  = scoreCombo(tip, STATE.pbase, PAIR);
          const key = tip.join('-');
          const prev= STATE.combos.get(key)||0;
          const val = prev + Math.max(1, Math.floor(3 + sc*10));
          STATE.combos.set(key, val);
          for(const v of tip) STATE.appear[v]++;
          STATE.iter++;
        }
        // adaptives Tuning
        const total=STATE.iter;
        const topN = topNums(total);
        const cut  = Math.max(0.010, 0.85*(topN[Math.min(19,topN.length-1)]?.p||0));
        const cool = 0.995, warm=1.006;
        for(let i=1;i<=70;i++){
          const pNow = (STATE.appear[i]/total) || 0;
          STATE.pbase[i] = STATE.pbase[i] * (pNow>=cut ? cool : warm);
          if(STATE.pbase[i]<1e-12) STATE.pbase[i]=1e-12;
        }
        let s=0; for(let i=1;i<=70;i++) s+=STATE.pbase[i]; for(let i=1;i<=70;i++) STATE.pbase[i]/=s;
      }

      function emitProgress(){
        postMessage({
          type:'progress',
          round:STATE.round,
          iter:STATE.iter,
          top:bestCombos(64),
          nums:topNums(STATE.iter),
          meta:{round:STATE.round, rounds:STATE.rounds, S:STATE.S, level:STATE.level, burst:STATE.burst, seed:STATE.seed}
        });
      }

      let TICK=null, START_TS=0;
      function loop(){
        if(!STATE || STATE.paused) return;
        if(!START_TS) START_TS=performance.now();
        stepOnce();
        if((STATE.iter % (STATE.burst*5))===0) emitProgress();

        const elapsed=(performance.now()-START_TS + STATE.elapsed)/1000;
        if(STATE.targetSec>0 && elapsed>=STATE.targetSec){
          // Runde beenden
          postMessage({type:'roundDone', round:STATE.round, top:bestCombos(64), nums:topNums(STATE.iter), iter:STATE.iter});
          STATE.round++;
          STATE.elapsed += (performance.now()-START_TS);
          START_TS=performance.now();
          STATE.iter=0; STATE.appear=Array(71).fill(0); STATE.combos=new Map();
          for(let i=1;i<=70;i++) STATE.pbase[i]=Math.max(1e-12, STATE.pbase[i]*1.02);
          let s=0; for(let i=1;i<=70;i++) s+=STATE.pbase[i]; for(let i=1;i<=70;i++) STATE.pbase[i]/=s;
          if(STATE.round>=STATE.rounds){ postMessage({type:'allDone'}); STATE=null; return; }
        }
        TICK=setTimeout(loop,0);
      }

      function pauseAndSnapshot(){
        if(!STATE) return;
        STATE.paused=true;
        if(START_TS){ STATE.elapsed += (performance.now()-START_TS); START_TS=0; }
        postMessage({type:'paused', snapshot: toSnapshot()});
      }

      onmessage = e=>{
        const m=e.data;
        if(m.cmd==='startFresh'){ startFresh(m.params); postMessage({type:'started'}); loop(); }
        else if(m.cmd==='resumeSnap'){ fromSnapshot(m.snapshot, m.drawsSub, m.drawsAll); postMessage({type:'resumed'}); loop(); }
        else if(m.cmd==='pause'){ pauseAndSnapshot(); }
        else if(m.cmd==='stop'){ STATE=null; if(TICK) clearTimeout(TICK); postMessage({type:'stopped'}); }
        else if(m.cmd==='progress'){ emitProgress(); }
      };
    `;
    fcWorker=new Worker(URL.createObjectURL(new Blob([code],{type:"application/javascript"})));

    fcWorker.onmessage=(ev)=>{
      const m=ev.data;
      if(m.type==='started'){
        fcState="running";
        $("#fcProg").style.display="";
        $("#fcStart").disabled=true; $("#fcPause").disabled=false; $("#fcResume").disabled=true; $("#fcReset").disabled=false; $("#fcTop6").disabled=false;
        text($("#fcInfo"),"läuft…");
      }else if(m.type==='progress'){
        handleProgress(m);
      }else if(m.type==='paused'){
        // persist Snapshot & globalBest
        try{ localStorage.setItem(SNAP_KEY, JSON.stringify(m.snapshot)); }catch{}
        persistBest();
        fcState="paused";
        $("#fcPause").disabled=true; $("#fcResume").disabled=false; $("#fcReset").disabled=false;
        $("#fcProg").style.display="none";
        text($("#fcInfo"),"Pausiert & gespeichert (Snapshot)");
      }else if(m.type==='resumed'){
        fcState="running";
        $("#fcPause").disabled=false; $("#fcResume").disabled=true; $("#fcReset").disabled=false;
        $("#fcProg").style.display="";
        text($("#fcInfo"),"läuft weiter…");
      }else if(m.type==='roundDone'){
        // sammle und zeige Zwischenergebnis
        mergeGlobal(m.top);
        renderRound(m.round, m.top, m.nums, m.iter, true);
      }else if(m.type==='allDone'){
        fcState="idle";
        $("#fcPause").disabled=true; $("#fcResume").disabled=true; $("#fcReset").disabled=false;
        $("#fcProg").style.display="none";
        text($("#fcInfo"),"fertig – Top-6 bereit");
        showTop6();
        // automatisch Snapshot (damit Fortschritt bleibt)
        fcWorker.postMessage({cmd:'pause'});
      }else if(m.type==='stopped'){
        fcState="idle";
        $("#fcPause").disabled=true; $("#fcResume").disabled=false; $("#fcProg").style.display="none";
        text($("#fcInfo"),"gestoppt");
      }
    };

    // Auto-Pause + Snapshot bei Tab-Verlassen (damit nichts verloren geht)
    document.addEventListener("visibilitychange",()=>{
      if(document.hidden && fcState==="running" && fcWorker){
        fcWorker.postMessage({cmd:'pause'});
      }
    });
  }

  /*** Progress & Render ***/
  function updateProgressUI(round){
    const seg=6, perSeg=1/seg;
    let base=Math.min(round,5)*perSeg;
    // Anzeige: wir lassen in der Runde „laufend“ pulsieren
    const t=Date.now()/1000;
    const frac=(Math.sin(t)+1)/2 * 0.9; // 0..0.9
    $("#fcProg").value=Math.min(1, base + frac*perSeg);
  }

  function renderRound(idx, topCombos, topNums, iter, final=false){
    let wrap=document.getElementById("r-"+idx);
    if(!wrap){
      wrap=document.createElement("div");
      wrap.className="block";
      wrap.id="r-"+idx;
      wrap.innerHTML=`
        <div class="head">Ziehung ${idx+1}${final? ' (Runde abgeschlossen)':''}</div>
        <div class="chips" id="topnums-${idx}"></div>
        <div class="combos" id="combos-${idx}"></div>
      `;
      $("#fcResults").appendChild(wrap);
    }else{
      wrap.querySelector(".head").textContent = `Ziehung ${idx+1}${final? ' (Runde abgeschlossen)':''}`;
    }

    const tn=$("#topnums-"+idx);
    const cb=$("#combos-"+idx);
    const t20=(topNums||[]).slice(0,20).map(x=>`<span class="chip">${x.n} <span class="badge">${fmtPct(x.p)} · ${fmtNum(x.c)}x</span></span>`).join("");
    html(tn, t20 || "(noch keine Daten)");
    const lines=(topCombos||[]).slice(0,24).map(o=>{
      const p = (iter>0) ? (o.c/iter) : 0;
      return `<div class="line"><b>${o.k.replace(/-/g," ")}</b> <span class="badge">${fmtPct(p)} · ${fmtNum(o.c)}x</span></div>`;
    }).join("");
    html(cb, lines || "(noch keine Daten)");
  }

  function mergeGlobal(list){
    for(const it of (list||[])){
      const k=it.k, c=it.c|0;
      globalBest.set(k, (globalBest.get(k)||0)+c);
    }
  }
  function persistBest(){
    try{
      const top = Array.from(globalBest.entries())
        .sort((a,b)=>b[1]-a[1] || (a[0]<b[0]?-1:1))
        .slice(0,800); // begrenzen
      localStorage.setItem(BEST_KEY, JSON.stringify(top));
    }catch{}
  }

  function handleProgress(m){
    updateProgressUI(m.round);
    mergeGlobal(m.top);
    renderRound(m.round, m.top, m.nums, m.iter, false);

    // alle 5s leichten Snapshot (Progress) sichern, damit „Weiter“ nach Reload nicht leer ist
    const now=Date.now();
    if(now - lastProgressAt > 5000){
      try{
        const lightSnap={
          meta:m.meta,
          pbase:null, // nur bei Pause kommt echte pbase; hier reicht Meta + Top
          appear:null,
          combos:m.top.map(x=>[x.k,x.c])
        };
        localStorage.setItem(SNAP_KEY, JSON.stringify(lightSnap));
      }catch{}
      persistBest();
      lastProgressAt=now;
    }
  }

  function showTop6(){
    const items = Array.from(globalBest.entries())
      .map(([k,c])=>({k,score:c}))
      .sort((a,b)=>b.score-a.score || (a.k<b.k?-1:1))
      .slice(0,6);

    const box=$("#finalCombos"); box.innerHTML="";
    if(!items.length){
      $("#finalBlock").style.display="";
      box.innerHTML='<div class="status">(noch keine Daten – erst laufen lassen / Pause abwarten)</div>';
      return;
    }
    for(const it of items){
      const div=document.createElement("div");
      div.className="line";
      div.innerHTML=`<b>${it.k.replace(/-/g," ")}</b><div class="badge">Score: ${fmtNum(it.score)}</div>`;
      box.appendChild(div);
    }
    $("#finalBlock").style.display="";
  }

  /*** Snapshot-Buttons je nach Zustand ***/
  function updateSnapshotButtons(){
    const hasSnap = !!localStorage.getItem(SNAP_KEY);
    $("#fcResume").disabled = !hasSnap;
    $("#fcReset").disabled  = !hasSnap && fcState!=="running";
    $("#fcTop6").disabled   = (globalBest.size===0);
  }

  /*** Steuerung ***/
  function startRun(){
    if(!g_draws.length){ alert("Bitte zuerst Archiv laden (ZIP/CSV/TXT auswählen)."); return; }
    ensureWorker();
    // Level/Datenbasis
    const level=$("#fcLevel").value||"normal";
    let N = level==="normal" ? 1000 : level==="medium" ? 3000 : g_draws.length;
    if(level==="maximum") N=g_draws.length;
    N=Math.min(N, g_draws.length);

    const params={
      S: parseInt($("#kenoType").value,10)||6,
      level,
      targetSec: parseInt($("#fcTarget").value,10)||0,
      burst: Math.max(500, parseInt($("#fcBurst").value,10)||2000),
      seed: (+$("#seed").value)>>>0,
      drawsSub: g_draws.slice(0,N),
      drawsAll: g_draws
    };

    // Reset Anzeige (aber globalBest behalten – kumulativ)
    $("#fcResults").innerHTML="";
    $("#finalBlock").style.display="none";
    $("#fcProg").style.display="";
    text($("#fcInfo"),"starte…");

    // Start frisch
    fcWorker.postMessage({cmd:'startFresh', params});
    fcState="running";
    $("#fcStart").disabled=true; $("#fcPause").disabled=false; $("#fcResume").disabled=true; $("#fcReset").disabled=false; $("#fcTop6").disabled=false;
  }

  function pauseRun(){ if(fcWorker){ fcWorker.postMessage({cmd:'pause'}); } }
  function resumeRun(){
    if(!g_draws.length){ alert("Bitte zuerst Archiv laden."); return; }
    const raw=localStorage.getItem(SNAP_KEY);
    if(!raw){ alert("Kein Snapshot gefunden."); return; }
    const snap=JSON.parse(raw);
    ensureWorker();

    // Wenn Light-Snapshot (nur combos/meta), starte trotzdem – Worker setzt pbase/appear frisch
    const snapshot = {
      meta: snap.meta || {round:0,rounds:6,S:parseInt($("#kenoType").value,10)||6,level:$("#fcLevel").value||"hard",targetSec:0,burst:2000,seed:(+$("#seed").value)>>>0,iter:0,elapsed:0},
      pbase: snap.pbase || Array(71).fill(1/70),
      appear: snap.appear || Array(71).fill(0),
      combos: snap.combos || []
    };

    $("#fcProg").style.display="";
    text($("#fcInfo"),"Snapshot laden…");
    fcWorker.postMessage({
      cmd:'resumeSnap',
      snapshot,
      drawsSub: g_draws.slice(0, ( $("#fcLevel").value==="normal"?1000 : $("#fcLevel").value==="medium"?3000 : g_draws.length )),
      drawsAll: g_draws
    });
    fcState="running";
    $("#fcStart").disabled=true; $("#fcPause").disabled=false; $("#fcResume").disabled=true; $("#fcReset").disabled=false; $("#fcTop6").disabled=false;
  }

  function resetRun(){
    if(fcWorker){ fcWorker.postMessage({cmd:'stop'}); try{fcWorker.terminate();}catch{} fcWorker=null; }
    try{ localStorage.removeItem(SNAP_KEY); }catch{}
    text($("#fcInfo"),"Zurückgesetzt. Neu starten möglich.");
    $("#fcProg").style.display="none";
    $("#fcStart").disabled=false; $("#fcPause").disabled=true; $("#fcResume").disabled=!localStorage.getItem(SNAP_KEY);
    $("#fcReset").disabled=true;
  }

  // Buttons
  $("#fcStart").addEventListener("click", startRun);
  $("#fcPause").addEventListener("click", pauseRun);
  $("#fcResume").addEventListener("click", resumeRun);
  $("#fcReset").addEventListener("click", resetRun);
  $("#fcTop6").addEventListener("click", showTop6);

  // Beim Laden: falls Snapshot vorhanden → "Weiter" aktivieren
  updateSnapshotButtons();
})();
</script>
</body>
</html>