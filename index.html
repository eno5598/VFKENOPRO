<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO Ultra ‚Äì Archiv ‚Ä¢ Map ‚Ä¢ Gruppen ‚Ä¢ Hot-Paare/Triples ‚Ä¢ Generator</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041;
    --text:#e5e7eb; --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  a{color:var(--accent2)}
  .box{max-width:1240px;margin:0 auto}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .row{display:flex;flex-wrap:wrap;gap:12px}
  .col{flex:1 1 220px;min-width:220px}
  label{display:block;margin:4px 0 6px;font-size:14px;opacity:.9}
  input,select,textarea,button{font:inherit}
  input,select,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid var(--muted);
    background:var(--bg);color:var(--text);outline:none}
  input[type="color"]{padding:0;height:42px}
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .ghost{background:transparent;border:1px dashed var(--muted);color:var(--text)}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);
    border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  progress{width:100%;height:14px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-value{background:#22c55e}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .fc-line{border:1px solid var(--muted);border-radius:10px;padding:8px;margin-bottom:6px}
  .badge{display:inline-block;padding:2px 6px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:6px;font-size:12px}
  .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
  .legend-item{display:flex;align-items:center;gap:6px;border:1px solid var(--muted);border-radius:8px;padding:4px 8px}
  .swatch{width:16px;height:16px;border-radius:4px;border:1px solid #0003}
  .mapWrap{display:flex;gap:16px;flex-wrap:wrap}
  .mapPanel{flex:1 1 440px;min-width:320px}
  canvas{width:100%;height:auto;background:#0d1426;border:1px solid var(--muted);border-radius:12px}
  .hint{font-size:13px;opacity:.85}
  .pill{padding:2px 8px;border:1px solid var(--muted);border-radius:999px;font-size:12px}
  .small{font-size:12px;opacity:.9}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px}
  .collapse{display:none}
</style>
</head>
<body>
<div class="box">

  <!-- 1) ARCHIV -->
  <div class="panel">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv</h2></div>
    <div class="row">
      <div class="col" style="flex:2 1 420px">
        <input type="file" id="file" accept=".csv,.txt,.zip">
        <div class="small" style="margin-top:6px">
          Offizielles ZIP: <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="btnExport" class="ghost" disabled>Normalisiertes CSV herunterladen</button>
        </div>
      </div>
      <div class="col">
        <label>Anzahl Zahlen (S)</label>
        <select id="pickSize">
          <option>2</option><option>3</option><option>4</option><option>5</option>
          <option selected>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
        </select>
        <label style="margin-top:10px">Rechenstufe</label>
        <select id="computeMode">
          <option value="normal" selected>normal</option>
          <option value="medium">mittel</option>
          <option value="hard">hard</option>
        </select>
      </div>
    </div>
    <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
  </div>

  <!-- 2) MAP -->
  <div class="panel">
    <div class="ph"><span class="emoji">üó∫Ô∏è</span><h2 style="margin:0">Map 1‚Äì70</h2></div>
    <div class="mapWrap">
      <div class="mapPanel">
        <canvas id="map" width="880" height="560"></canvas>
        <div class="hint">10 Spalten √ó 7 Reihen. √úberlagerte Punkte = aktuelle Hotspots.</div>
      </div>
      <div class="col" style="flex:1 1 320px">
        <div class="legend" id="legend"></div>
        <div class="row" style="align-items:center;gap:8px;margin-top:6px">
          <input id="toggleColors" type="checkbox">
          <label for="toggleColors" style="margin:0">Farben-Einstellungen anzeigen</label>
        </div>
        <div id="colorConfigWrap" class="collapse">
          <div id="colorGrid" class="grid" style="margin-top:8px"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- 3) GRUPPEN -->
  <div class="panel">
    <div class="ph"><span class="emoji">üéØ</span><h2 style="margin:0">Gruppen & Zielverteilung</h2></div>

    <div class="row">
      <div class="col">
        <label>Gruppen-Modus</label>
        <select id="groupMode">
          <option value="7" selected>7er (1‚Äì10,11‚Äì20,...,61‚Äì70)</option>
          <option value="5">5er (1‚Äì14,15‚Äì28,29‚Äì42,43‚Äì56,57‚Äì70)</option>
          <option value="3">3er (1‚Äì23,24‚Äì47,48‚Äì70)</option>
        </select>
      </div>
      <div class="col">
        <label>Hot bevorzugen</label>
        <div class="row">
          <label class="small"><input type="checkbox" id="preferPairs" checked> Hot-Paare</label>
          <label class="small"><input type="checkbox" id="preferTriples"> Hot-Triples</label>
        </div>
      </div>
      <div class="col" style="flex:2 1 420px;display:flex;align-items:flex-end;gap:8px">
        <button id="autoEven" class="secondary">Counts gleich verteilen</button>
        <button id="autoByArchive" class="secondary">Counts nach Archiv</button>
        <span class="pill" id="sumInfo">Summe: 0 / S</span>
      </div>
    </div>

    <div id="groupCounts" class="grid" style="margin-top:8px"></div>
    <div id="groupStatus" class="status">Gruppen initialisiert.</div>
  </div>

  <!-- 4) GENERIEREN -->
  <div class="panel">
    <div class="ph"><span class="emoji">üßÆ</span><h2 style="margin:0">Generator</h2></div>
    <div class="row" style="margin-bottom:8px">
      <div class="col">
        <label>Wie viele Kombinationen ausgeben?</label>
        <select id="outCount">
          <option>1</option><option>2</option><option>3</option><option selected>4</option>
          <option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
        </select>
      </div>
      <div class="col" style="display:flex;align-items:flex-end;gap:8px">
        <button id="start" class="primary" disabled>Start</button>
        <button id="pause" class="secondary" disabled>Pause</button>
        <button id="resume" class="secondary" disabled>Weiter</button>
        <button id="stop" class="danger" disabled>Stopp</button>
        <span class="pill" id="liveInfo">idle</span>
      </div>
    </div>
    <progress id="prog" value="0" max="1" style="display:none"></progress>
    <div id="status" class="status">bereit</div>
    <div id="results" class="results"></div>
  </div>

</div>

<!-- ==== TEIL 2 direkt hier unten einf√ºgen ==== -->
</body>
</html>
<script>
(function(){
"use strict";

/* ===== Helpers ===== */
const $ = s => document.querySelector(s);
const text = (el,s)=>{ if(el) el.textContent=s; };
const html = (el,s)=>{ if(el) el.innerHTML=s; };
const fmt = n => (n||0).toLocaleString("de-DE");
const uniqSorted = a => Array.from(new Set(a)).sort((x,y)=>x-y);

/* ===== Globals ===== */
const CK_ARCH="keno_base_arch_v1", CK_COLORS="keno_base_colors_v1";
let g_draws=[], g_dates=[], g_drawSize=0;
let g_groups=[]; // {from,to,color}
let g_counts=[]; // gew√ºnschte Anzahl per Gruppe (sum == S)
let g_colorsOpen=false;

let worker=null, runState="idle", lastList=[];

/* ===== Map & Colors ===== */
const default7 = [
  {from:1,to:10,color:"#3b82f6"},
  {from:11,to:20,color:"#22c55e"},
  {from:21,to:30,color:"#f59e0b"},
  {from:31,to:40,color:"#ef4444"},
  {from:41,to:50,color:"#a78bfa"},
  {from:51,to:60,color:"#14b8a6"},
  {from:61,to:70,color:"#eab308"},
];
const default5 = [
  {from:1,to:14,color:"#60a5fa"},
  {from:15,to:28,color:"#34d399"},
  {from:29,to:42,color:"#fbbf24"},
  {from:43,to:56,color:"#f87171"},
  {from:57,to:70,color:"#c084fc"},
];
const default3 = [
  {from:1,to:23,color:"#93c5fd"},
  {from:24,to:47,color:"#86efac"},
  {from:48,to:70,color:"#fde68a"},
];

const map=$("#map"), ctx=map.getContext("2d");
function cellRect(n){ const col=(n-1)%10, row=Math.floor((n-1)/10); const pad=8, cw=(map.width-pad*2)/10, ch=(map.height-pad*2)/7; return {x:pad+col*cw,y:pad+row*ch,w:cw,h:ch}; }
function drawMap(highlights){
  ctx.clearRect(0,0,map.width,map.height);
  ctx.lineWidth=1; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.font="14px ui-sans-serif,system-ui";
  // group backgrounds (light tint)
  for(const g of g_groups){
    ctx.fillStyle = hexWithAlpha(g.color, 0.18);
    for(let v=g.from; v<=g.to; v++){ const r=cellRect(v); ctx.fillRect(r.x,r.y,r.w,r.h); }
  }
  // grid + numbers
  ctx.strokeStyle="#223046"; ctx.fillStyle="#dbeafe";
  for(let v=1;v<=70;v++){ const r=cellRect(v); ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.fillText(String(v), r.x+r.w/2, r.y+r.h/2); }
  // highlights
  if(Array.isArray(highlights)){
    for(const {num,weight} of highlights){
      const r=cellRect(num);
      ctx.beginPath(); ctx.arc(r.x+r.w/2,r.y+r.h/2,Math.min(r.w,r.h)*0.38,0,Math.PI*2);
      ctx.fillStyle=hexWithAlpha("#ffffff", 0.08 + 0.12*(weight||0));
      ctx.fill();
      ctx.beginPath(); ctx.arc(r.x+r.w/2,r.y+r.h/2,Math.min(r.w,r.h)*0.2,0,Math.PI*2);
      ctx.fillStyle="#e5e7eb"; ctx.fill(); ctx.strokeStyle="#00000055"; ctx.stroke();
    }
  }
}
function hexWithAlpha(hex, a){
  const h=hex.replace("#",""); const r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}
function buildLegend(){
  const L=$("#legend");
  html(L, g_groups.map((g,i)=>`
    <div class="legend-item">
      <span class="swatch" style="background:${g.color}"></span>
      <span>G${i+1}: ${g.from}-${g.to}</span>
    </div>`).join(""));
}
function buildColorEditor(){
  const wrap=$("#colorGrid"); html(wrap,"");
  html(wrap, g_groups.map((g,i)=>`
    <div class="panel" style="padding:8px">
      <div style="font-weight:700;margin-bottom:6px">Gruppe ${i+1} (${g.from}-${g.to})</div>
      <input type="color" value="${g.color}" data-idx="${i}" class="colPicker">
    </div>`).join(""));
  document.querySelectorAll(".colPicker").forEach(inp=>{
    inp.addEventListener("input", e=>{
      const idx=+e.target.getAttribute("data-idx"); g_groups[idx].color=e.target.value; saveColors(); buildLegend(); drawMap();
    });
  });
}
function saveColors(){ try{ localStorage.setItem(CK_COLORS, JSON.stringify(g_groups.map(g=>({from:g.from,to:g.to,color:g.color})))) }catch{} }

$("#toggleColors").addEventListener("change",()=>{
  g_colorsOpen = $("#toggleColors").checked;
  $("#colorConfigWrap").classList.toggle("collapse", !g_colorsOpen);
});

/* ===== Gruppen-Modus & Ziel-Counts ===== */
function setGroupMode(mode){
  if(mode==="7") g_groups = JSON.parse(JSON.stringify(default7));
  else if(mode==="5") g_groups = JSON.parse(JSON.stringify(default5));
  else g_groups = JSON.parse(JSON.stringify(default3));
  // restore saved colors (if matching layout)
  try{
    const saved = JSON.parse(localStorage.getItem(CK_COLORS)||"[]");
    if(saved.length===g_groups.length){
      for(let i=0;i<g_groups.length;i++){
        if(saved[i].from===g_groups[i].from && saved[i].to===g_groups[i].to) g_groups[i].color=saved[i].color;
      }
    }
  }catch{}
  buildLegend(); buildColorEditor(); buildCountInputs(); drawMap();
  text($("#groupStatus"), "Gruppen initialisiert.");
}
function buildCountInputs(){
  const S = parseInt($("#pickSize").value,10)||6;
  if(!g_counts || g_counts.length!==g_groups.length) g_counts = Array(g_groups.length).fill(0);
  const wrap=$("#groupCounts");
  html(wrap, g_groups.map((g,i)=>`
    <div class="panel" style="padding:8px">
      <div style="font-weight:700;margin-bottom:6px">G${i+1}: ${g.from}-${g.to}</div>
      <input type="number" min="0" max="${S}" step="1" value="${g_counts[i]||0}" data-idx="${i}" class="cntInp">
      <div class="small" style="margin-top:6px">Wieviele Zahlen aus dieser Gruppe?</div>
    </div>
  `).join(""));
  wrap.querySelectorAll(".cntInp").forEach(inp=>{
    inp.addEventListener("input", onCountChange);
  });
  updateSumInfo();
}
function onCountChange(e){
  const S = parseInt($("#pickSize").value,10)||6;
  const idx = +e.target.getAttribute("data-idx");
  let v = parseInt(e.target.value,10); if(!Number.isFinite(v)||v<0) v=0; if(v>S) v=S;
  g_counts[idx]=v; e.target.value=v;
  updateSumInfo();
}
function updateSumInfo(){
  const S = parseInt($("#pickSize").value,10)||6;
  const sum = (g_counts||[]).reduce((a,b)=>a+(b||0),0);
  text($("#sumInfo"), `Summe: ${sum} / ${S}`);
  const ok = (sum===S) && (g_groups.length>=3 && g_groups.length<=7);
  $("#start").disabled = !(ok && g_draws.length);
  text($("#groupStatus"), ok ? "Zielverteilung OK ‚úì" : "Summe muss genau S ergeben.");
}

/* ===== Archiv laden / exportieren ===== */
function splitSmart(line){
  if(/\t/.test(line)) return line.split("\t");
  if(line.includes(";")) return line.split(";");
  if(line.includes("|")) return line.split("|");
  if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
  return line.trim().split(/\s+/);
}
function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}
function tryZahlHeader(rows){
  if(!rows.length) return null;
  const header=rows[0].map(x=>String(x).trim()); const idx=[], dateIdx=[];
  for(let i=0;i<header.length;i++){
    if(/^zahl\s*\d+$/i.test(header[i])) idx.push(i);
    if(/datum|date|ziehung|draw|tag/i.test(header[i])) dateIdx.push(i);
  }
  if(idx.length>=5){
    const lists=[], dates=[];
    for(let r=1;r<rows.length;r++){
      const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
      if(nums.length) lists.push(nums);
      let dt=null; if(dateIdx.length){ dt=String(rows[r][dateIdx[0]]??"").trim(); }
      dates.push(dt);
    }
    return {lists, dates, info:`Header erkannt (${idx.length} Zahl-Spalten${dateIdx.length?"+Datum":""})`};
  }
  return null;
}
function detectDashCol(rows){
  let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
  let best=-1,score=-1;
  for(let c=0;c<maxCols;c++){
    let sc=0;
    for(const r of rows){
      if(c>=r.length) continue;
      const cell=String(r[c]??"").trim(); if(!cell) continue;
      const parts=cell.split("-");
      if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
    }
    if(sc>score){score=sc;best=c;}
  }
  return best;
}
function fallbackExtract(raw){
  const out=[], dates=[];
  for(const lnRaw of raw.split(/\r?\n/)){
    const ln=lnRaw.trim(); if(!ln) continue;
    const dtMatch=ln.match(/(\d{4}[-.\/]\d{1,2}[-.\/]\d{1,2})/);
    if(/^\d+(?:-\d+)+$/.test(ln)){
      out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); dates.push(dtMatch?dtMatch[1]:null); continue;
    }
    const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    if(nums.length>=5){ out.push(nums); dates.push(dtMatch?dtMatch[1]:null); }
  }
  return {lists:out, dates};
}
async function ensureJSZip(){
  if(window.JSZip) return;
  await new Promise((res,rej)=>{
    const s=document.createElement("script");
    s.src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
    s.onload=res; s.onerror=()=>rej(new Error("JSZip laden fehlgeschlagen"));
    document.head.appendChild(s);
  });
}
async function handleAnyFile(file){
  if(!file){ text($("#statusTop"),"Keine Datei gew√§hlt."); return; }
  text($("#statusTop"),`Lese Datei: ${file.name}`);
  const name=(file.name||"").toLowerCase();
  try{
    let raw="", sourceLabel="";
    if(name.endsWith(".zip")){
      await ensureJSZip();
      const ab=await file.arrayBuffer();
      const zip=await JSZip.loadAsync(ab);
      const candidates=[];
      zip.forEach((path, entry)=>{
        const p=path.toLowerCase();
        if(p.endsWith(".csv")||p.endsWith(".txt")){
          const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
          candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
        }
      });
      if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
      candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
      const target=candidates[0];
      sourceLabel=`ZIP: ${target.path}`;
      try{ raw=await target.entry.async("string"); }
      catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
    }else{
      sourceLabel=file.name||"Upload";
      try{ raw=await file.text(); }
      catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
    }
    loadArchiveFromRawText(raw, sourceLabel);
  }catch(e){
    text($("#statusTop"),"Fehler beim Lesen: "+(e?.message||e));
    g_draws=[]; g_dates=[]; g_drawSize=0; $("#start").disabled=true; $("#btnExport").disabled=true;
  }
}
function loadArchiveFromRawText(raw, sourceLabel){
  text($("#statusTop"),"Analysiere Datei ‚Ä¶");
  const rows=parseTable(raw);
  let lists=[], dates=[], detected="";
  const h=tryZahlHeader(rows);
  if(h){ lists=h.lists; dates=h.dates; detected=h.info; }
  else{
    const ncol=detectDashCol(rows);
    if(ncol>=0){
      for(const r of rows){
        if(ncol>=r.length) continue;
        const cell=String(r[ncol]??"").trim(); if(!cell) continue;
        const parts=cell.split("-").map(s=>s.trim());
        if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
      }
      detected="Spalte 1-4-‚Ä¶";
    }else{
      const fb=fallbackExtract(raw); lists=fb.lists; dates=fb.dates; detected="Fallback: freie Zahlzeilen";
    }
  }
  if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");

  // dominante L√§nge
  const freq=new Map();
  for(const a of lists){ if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1); }
  let bestLen=0,bestCnt=-1;
  for(const [k,v] of freq.entries()){ if(v>bestCnt){bestCnt=v;bestLen=k;} }
  if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");

  g_drawSize=bestLen;
  g_draws = lists.filter(a=>a.length===g_drawSize)
                 .map(a=>uniqSorted(a.filter(Number.isInteger).filter(x=>x>=1&&x<=70)));
  g_dates = dates && dates.length===lists.length ? dates.filter((_,i)=>lists[i].length===g_drawSize) : new Array(g_draws.length).fill(null);
  if(!g_draws.length) throw new Error("Nach Filter keine Ziehungen √ºbrig.");

  try{ localStorage.setItem(CK_ARCH, JSON.stringify({draws:g_draws, dates:g_dates, drawSize:g_drawSize, savedAt:Date.now(), source:sourceLabel||""})); }catch{}
  $("#btnExport").disabled=false;

  const ts=new Date();
  text($("#statusTop"),
    `Archiv geladen: ${fmt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}`+
    (sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:"")+
    `\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`
  );
  drawMap();
  updateSumInfo();
}
$("#file").addEventListener("change",()=>handleAnyFile($("#file").files[0]));
$("#btnExport").addEventListener("click", ()=>{
  if(!g_draws.length) return;
  const rows = g_draws.map((d,i)=>[g_dates[i]||"", ...d].join(",")).join("\n");
  const csv = "date,"+Array.from({length:g_drawSize},(_,i)=>"zahl"+(i+1)).join(",")+"\n"+rows;
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="keno_normalisiert.csv";
  a.click();
});

/* ===== Worker ===== */
function buildWorker(){
  if(worker) try{worker.terminate();}catch{}
  const code = `
  let CFG=null, STATE=null;

  function inRange(v,a,b){ return v>=a && v<=b; }
  function freq(draws,a,b){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(inRange(v,a,b)) f[v]++; return f; }
  function coPairs(draws,a,b){
    const M=Array.from({length:71},()=>Array(71).fill(0));
    for(const d of draws){
      const s=d.filter(v=>inRange(v,a,b));
      for(let i=0;i<s.length;i++) for(let j=i+1;j<s.length;j++){ const x=s[i],y=s[j]; M[x][y]++; M[y][x]++; }
    }
    return M;
  }
  function coTriples(draws,a,b){
    const T=new Map(); // key "a-b-c" sorted
    for(const d of draws){
      const s=d.filter(v=>inRange(v,a,b)).sort((x,y)=>x-y);
      for(let i=0;i<s.length;i++) for(let j=i+1;j<s.length;j++) for(let k=j+1;k<s.length;k++){
        const key=s[i]+"-"+s[j]+"-"+s[k]; T.set(key,(T.get(key)||0)+1);
      }
    }
    return T;
  }

  function makePool(groups, minV, maxV){
    const pool = groups.map(()=>[]);
    for(let v=minV; v<=maxV; v++){
      for(let gi=0; gi<groups.length; gi++){
        const g=groups[gi];
        if(v>=g.from && v<=g.to){ pool[gi].push(v); break; }
      }
    }
    return pool;
  }

  function scoreCombo(arr, ctx){
    const {baseF, pairM, triM, wBase, wPair, wTri} = ctx;
    let s = 0;
    for(const v of arr) s += Math.log( (baseF[v]||0.5) + 1e-9 );
    // pairs
    for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++){
      s += wPair * Math.log( (pairM[arr[i]][arr[j]]||0) + 1e-6 );
    }
    // triples (lookup map)
    if(wTri>0 && arr.length>=3){
      const a=arr.slice().sort((x,y)=>x-y);
      for(let i=0;i<a.length;i++) for(let j=i+1;j<a.length;j++) for(let k=j+1;k<a.length;k++){
        const key=a[i]+"-"+a[j]+"-"+a[k];
        const c=triM.get(key)||0;
        if(c>0) s += wTri * Math.log(c + 1e-6);
      }
    }
    return s * wBase;
  }

  function start(cfg){
    CFG=cfg;
    const {drawsAll, rangeMin, rangeMax, groups, counts, preferPairs, preferTriples, S, outCount, mode} = CFG;
    const baseF=freq(drawsAll, rangeMin, rangeMax);
    const pairM=coPairs(drawsAll, rangeMin, rangeMax);
    const triM= preferTriples ? coTriples(drawsAll, rangeMin, rangeMax) : new Map();

    // Gewichte je Modus
    const MODES = {
      normal:{iters: 25_000,  pause: 10, wBase:1.00, wPair:preferPairs?0.45:0.15, wTri:preferTriples?0.30:0.0},
      medium:{iters: 90_000,  pause: 8,  wBase:1.05, wPair:preferPairs?0.55:0.18, wTri:preferTriples?0.40:0.0},
      hard:  {iters: 260_000, pause: 6,  wBase:1.10, wPair:preferPairs?0.65:0.20, wTri:preferTriples?0.50:0.0},
    };
    const M = MODES[mode]||MODES.normal;

    const pool = makePool(groups, rangeMin, rangeMax);

    // Vorbereitete Slots pro Gruppe nach Count
    const plan=[]; for(let gi=0; gi<groups.length; gi++) for(let k=0;k<counts[gi];k++) plan.push(gi);
    plan.sort((a,b)=> (pool[b].length-pool[a].length) || (a-b)); // zuerst gro√üe Pools

    // Simulated-Greedy Random Search
    STATE={
      start: performance.now(),
      best: new Map(), // key->score
      sent: 0, iter:0, nextTick: performance.now()+300,
      ctx: {baseF, pairM, triM, wBase:M.wBase, wPair:M.wPair, wTri:M.wTri},
      M, pool, plan, outCount, S
    };

    loop();
  }

  function randomChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function buildCandidate(STATE){
    const {pool, plan, S} = STATE;
    const used=new Uint8Array(71);
    const pick=[];
    for(const gi of plan){
      const candidates = pool[gi];
      // bis zu 6 Versuche eine neue Zahl zu ziehen
      let tries=0, v=null;
      while(tries++<6){
        v = randomChoice(candidates);
        if(!used[v]) break;
        v=null;
      }
      if(v==null){
        // fallback: linear suchen
        for(const c of candidates){ if(!used[c]){ v=c; break; } }
      }
      if(v==null){
        // harter Fallback: irgendeine freie Zahl im Range
        for(let x=1;x<=70;x++){ if(!used[x]){ v=x; break; } }
      }
      if(v!=null){ used[v]=1; pick.push(v); }
    }
    if(pick.length>S){
      pick.length=S;
    }else if(pick.length<S){
      for(let x=1; x<=70 && pick.length<S; x++){
        if(!used[x]){ used[x]=1; pick.push(x); }
      }
    }
    return pick.sort((a,b)=>a-b);
  }

  function loop(){
    if(!STATE) return;
    const {M, ctx, outCount} = STATE;

    for(let t=0; t< M.iters; t++){
      const cand = buildCandidate(STATE);
      const key = cand.join("-");
      if(!STATE.best.has(key)){
        const s = scoreCombo(cand, ctx);
        STATE.best.set(key, s);
      }else{
        // leichte Mutation
        let arr=cand.slice();
        if(arr.length>=2){
          const i=Math.floor(Math.random()*arr.length);
          const j=Math.floor(Math.random()*arr.length);
          [arr[i],arr[j]]=[arr[j],arr[i]];
          arr=Array.from(new Set(arr)).sort((a,b)=>a-b);
          const k2=arr.join("-");
          if(!STATE.best.has(k2)){
            const s2=scoreCombo(arr, ctx);
            STATE.best.set(k2,s2);
          }
        }
      }
      STATE.iter++;
      if(STATE.iter%2000===0){
        const list = topList(STATE, Math.max(outCount*4, 20));
        postMessage({type:"progress", iter:STATE.iter, elapsed:(performance.now()-STATE.start)/1000, list});
      }
    }

    const list = topList(STATE, outCount);
    postMessage({type:"done", list});
    STATE=null;
  }

  function topList(STATE, n){
    return Array.from(STATE.best.entries())
      .sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]))
      .slice(0,n)
      .map(([k,score],i,arr)=>({k, idx:+((score/((arr[0]?.[1]||1)))*100).toFixed(1), raw:+score.toFixed(3)}));
  }

  onmessage=e=>{
    const m=e.data;
    if(m.cmd==="start") start(m.cfg);
    // Pause/Resume/Stop k√∂nnten hier erweitert werden (einfachere erste Version: einmal pro Start)
    // F√ºr sp√§tere Iteration: iterative Loop mit setTimeout und Flags.
  };
  `;
  worker=new Worker(URL.createObjectURL(new Blob([code],{type:"application/javascript"})));
  worker.onmessage = onWorkerMsg;
  worker.onerror = e=>{ text($("#status"), "Worker-Fehler: "+(e.message||"unbekannt")); endButtons(); };
}

/* ===== Historie (Subset) ===== */
function occurrences(arr){
  const set=new Set(arr);
  const hits=[];
  for(let i=0;i<g_draws.length;i++){
    const d=g_draws[i];
    let ok=true; for(const v of set){ if(!d.includes(v)){ ok=false; break; } }
    if(ok) hits.push({idx:i, date:g_dates[i]||null});
  }
  return hits;
}

/* ===== Worker Events ===== */
function onWorkerMsg(ev){
  const m=ev.data;
  if(m.type==="progress"){
    $("#prog").style.display="";
    text($("#status"), `Iterationen: ${fmt(m.iter)} ¬∑ Zeit: ${m.elapsed.toFixed(1)}s ¬∑ Kandidaten: ${fmt(m.list.length)}`);
    lastList=m.list||[];
    renderList(lastList);
    updateHotspots(lastList);
  }else if(m.type==="done"){
    $("#prog").style.display="none";
    text($("#status"), `Fertig. Kandidaten: ${fmt((m.list||[]).length)}`);
    renderList(m.list||[]);
    updateHotspots(m.list||[]);
    endButtons();
  }
}

/* ===== Render ===== */
function renderList(list){
  const out = (list||[]).map((it,i)=>{
    const nums = it.k.split("-").map(Number);
    const hits = occurrences(nums);
    const last = hits.at(-1);
    const hx = hits.length ? (last?.date?`#${hits.at(-1).idx} (${last.date})`:`#${hits.at(-1).idx}`) : "‚Äì";
    return `<div class="fc-line">
      <b>${i+1}. ${it.k.replace(/-/g," ")}</b>
      <span class="badge">Score-Idx: ${it.idx}</span>
      <span class="badge">Historie: ${hits.length}√ó (letzte: ${hx})</span>
    </div>`;
  }).join("");
  html($("#results"), out || "<div class='fc-line'>(keine Kandidaten)</div>");
}
function updateHotspots(list){
  const hot=new Map();
  (list||[]).forEach((it,rank)=>{
    const w = 1 - (rank/Math.max(1,(list.length-1)||1));
    it.k.split("-").map(Number).forEach(n=> hot.set(n, Math.max(hot.get(n)||0, w)));
  });
  const highlights=Array.from(hot.entries()).map(([num,weight])=>({num,weight}));
  drawMap(highlights);
}

/* ===== Controls ===== */
function startSearch(){
  if(!g_draws.length) return alert("Bitte zuerst ein Archiv laden.");
  const S = parseInt($("#pickSize").value,10)||6;
  const counts = g_counts.slice();
  const sum = counts.reduce((a,b)=>a+b,0);
  if(sum!==S) { alert("Die Summe der Gruppen-Counts muss genau S ergeben."); return; }

  // Config
  const outCount = parseInt($("#outCount").value,10)||4;
  const mode = $("#computeMode").value; // normal / medium / hard

  // Bereich = volle 1‚Äì70 (durch die festen Modis); Range kann sp√§ter erg√§nzt werden
  const cfg = {
    drawsAll: g_draws,
    rangeMin: 1,
    rangeMax: 70,
    groups: g_groups,
    counts,
    preferPairs: $("#preferPairs").checked,
    preferTriples: $("#preferTriples").checked,
    S, outCount, mode
  };

  buildWorker();
  beginButtons();
  text($("#status"), "Starte Suche ‚Ä¶");
  worker.postMessage({cmd:"start", cfg});
}
function beginButtons(){
  $("#start").disabled=true; $("#pause").disabled=true; $("#resume").disabled=true; $("#stop").disabled=true;
  $("#prog").style.display="";
  text($("#liveInfo"), "running");
}
function endButtons(){
  $("#start").disabled=false; $("#pause").disabled=true; $("#resume").disabled=true; $("#stop").disabled=true;
  text($("#liveInfo"), "idle");
}
$("#start").addEventListener("click", startSearch);

/* ===== Init ===== */
(function initFromCache(){
  try{
    const raw=localStorage.getItem(CK_ARCH);
    if(raw){
      const obj=JSON.parse(raw)||{};
      g_draws=obj.draws||[]; g_dates=obj.dates||[]; g_drawSize=obj.drawSize||0;
      if(g_draws.length){
        const ts=obj.savedAt?new Date(obj.savedAt):new Date(); const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
        text($("#statusTop"),`Archiv aus Browser: ${fmt(g_draws.length)} Ziehungen (ZL ${g_drawSize})${src}\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`);
        $("#btnExport").disabled=false;
      }
    }
  }catch{}
})();
$("#groupMode").addEventListener("change", ()=> setGroupMode($("#groupMode").value));
$("#pickSize").addEventListener("change", ()=> buildCountInputs());
$("#autoEven").addEventListener("click", ()=>{
  const S=parseInt($("#pickSize").value,10)||6;
  g_counts = evenSplit(S, g_groups.length); buildCountInputs(); updateSumInfo();
});
$("#autoByArchive").addEventListener("click", ()=>{
  if(!g_draws.length){ alert("Archiv zuerst laden."); return; }
  const S=parseInt($("#pickSize").value,10)||6;
  const shares = groupSharesFromArchive();
  g_counts = proportionalSplit(S, shares); buildCountInputs(); updateSumInfo();
});

function evenSplit(S, G){
  const arr=Array(G).fill(0);
  for(let i=0;i<S;i++) arr[i%G]++;
  return arr;
}
function proportionalSplit(S, shares){
  // shares: L√§nge = Gruppen, Summe>0
  const raw=shares.map(x=>x*S);
  const base=raw.map(Math.floor);
  let rest=S-base.reduce((a,b)=>a+b,0);
  const frac=raw.map((x,i)=>({i,f:x-base[i]})).sort((a,b)=> b.f-a.f);
  for(let i=0;i<rest;i++) base[frac[i%frac.length].i]++;
  return base;
}
function groupSharesFromArchive(){
  const counts=Array(g_groups.length).fill(0);
  for(const d of g_draws){
    for(const v of d){
      for(let i=0;i<g_groups.length;i++){ const g=g_groups[i]; if(v>=g.from && v<=g.to){ counts[i]++; break; } }
    }
  }
  const N = g_draws.length || 1;
  return counts.map(x=> x/(N*g_drawSize||1));
}

/* Default mode & UI build */
setGroupMode($("#groupMode").value);

/* Map initial */
drawMap();

})();
</script>