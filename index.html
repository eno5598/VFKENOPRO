<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO Ultra++ ‚Äì Archiv ‚Ä¢ Range ‚Ä¢ Gruppen ‚Ä¢ Hot-Analyse ‚Ä¢ Generator</title>
<style>
  :root{
    --bg:#070b16; --panel:#0f172a; --border:#1f2a44; --muted:#23304a;
    --text:#e5e7eb; --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444;
    --shine:rgba(255,255,255,.08);
    --strobo-intensity: .55; /* 0..1 */
  }
  *{box-sizing:border-box}
  /* Hintergrund: leichtes Flackern + Schimmer */
  @keyframes flicker {
    0%,100%{opacity:1}
    49%{opacity:.99}
    50%{opacity:.985}
    51%{opacity:1}
  }
  @keyframes shimmer {
    0%{background-position:-200% 0}
    100%{background-position:200% 0}
  }
  body{
    margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--text);
    background:
      linear-gradient(120deg, #0b1220 0%, #0b1322 40%, #0b1220 60%),
      radial-gradient(1200px 600px at 50% -20%, rgba(96,165,250,.10), transparent 60%),
      radial-gradient(800px 400px at 80% 120%, rgba(34,197,94,.08), transparent 60%),
      var(--bg);
    background-blend-mode:screen,normal,normal,normal;
    animation: flicker 8s infinite steps(200,end);
  }
  .box{max-width:1260px;margin:0 auto; position:relative}
  .glow{
    position:absolute; inset:-60px;
    background:linear-gradient(90deg, transparent, var(--shine), transparent);
    background-size:200% 100%;
    pointer-events:none; filter:blur(22px) saturate(120%);
    animation: shimmer 18s linear infinite;
  }

  .panel{background:linear-gradient(180deg, #0f172a, #0c1424);
    border:1px solid var(--border); border-radius:14px; padding:14px; margin:12px 0 0;
    box-shadow: 0 8px 22px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .row{display:flex;flex-wrap:wrap;gap:12px}
  .col{flex:1 1 220px;min-width:220px}
  label{display:block;margin:4px 0 6px;font-size:14px;opacity:.9}
  input,select,textarea,button{font:inherit}
  input,select,textarea{
    width:100%;padding:10px;border-radius:10px;border:1px solid var(--muted);
    background:#0a1222;color:var(--text);outline:none
  }
  input[type="color"]{padding:0;height:42px}
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700;transition:transform .05s}
  button:active{transform:translateY(1px)}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .ghost{background:transparent;border:1px dashed var(--muted);color:var(--text)}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:#0a1222;
    border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  progress{width:100%;height:14px;border-radius:8px;overflow:hidden;background:#0a1222;border:1px solid var(--muted)}
  progress::-webkit-progress-value{background:#22c55e}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .fc-line{border:1px solid var(--muted);border-radius:10px;padding:8px;margin-bottom:6px;background:#0a1222}
  .badge{display:inline-block;padding:2px 6px;border-radius:999px;background:#0a1222;border:1px solid var(--muted);margin-left:6px;font-size:12px}
  .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
  .legend-item{display:flex;align-items:center;gap:6px;border:1px solid var(--muted);border-radius:8px;padding:4px 8px;background:#0a1222}
  .swatch{width:16px;height:16px;border-radius:4px;border:1px solid #0003}
  .mapWrap{display:flex;gap:16px;flex-wrap:wrap}
  .mapPanel{flex:1 1 520px;min-width:320px}
  canvas{width:100%;height:auto;background:#0b1426;border:1px solid var(--muted);border-radius:12px;box-shadow:inset 0 0 30px rgba(0,0,0,.5)}
  .hint{font-size:13px;opacity:.85}
  .pill{padding:2px 8px;border:1px solid var(--muted);border-radius:999px;font-size:12px}
  .small{font-size:12px;opacity:.9}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px}
  .collapse{display:none}

  /* Generieren: Strobo-Effekt (sanft) ‚Äì wird via .strobo auf body aktiviert */
  @keyframes strobo {
    0%,100%{box-shadow:0 0 0 rgba(255,255,255,0)}
    50%{box-shadow:0 0 60px rgba(255,255,255,var(--strobo-intensity));}
  }
  body.strobo .panel{animation: strobo .6s infinite;}
</style>
</head>
<body>
<div class="box">
  <div class="glow"></div>

  <!-- 1) ARCHIV -->
  <div class="panel">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv</h2></div>
    <div class="row">
      <div class="col" style="flex:2 1 420px">
        <input type="file" id="file" accept=".csv,.txt,.zip">
        <div class="small" style="margin-top:6px">
          Offizielles ZIP: <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="btnExport" class="ghost" disabled>Normalisiertes CSV herunterladen</button>
          <button id="btnClearArch" class="secondary">Archiv l√∂schen</button>
        </div>
      </div>
      <div class="col">
        <label>Anzahl Zahlen (S)</label>
        <select id="pickSize">
          <option>2</option><option>3</option><option>4</option><option>5</option>
          <option selected>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
        </select>
        <label style="margin-top:10px">Rechenstufe</label>
        <select id="computeMode">
          <option value="normal">normal</option>
          <option value="medium">mittel</option>
          <option value="hard">hard</option>
          <option value="ultra" selected>Ultra++</option>
        </select>
      </div>
      <div class="col">
        <label>Range (min‚Äìmax)</label>
        <div class="row">
          <input id="minVal" type="number" min="1" max="70" value="1">
          <input id="maxVal" type="number" min="1" max="70" value="70">
        </div>
        <div class="small">z. B. 4‚Äì67</div>
      </div>
    </div>
    <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
  </div>

  <!-- 2) MAP -->
  <div class="panel">
    <div class="ph"><span class="emoji">üó∫Ô∏è</span><h2 style="margin:0">Map 1‚Äì70</h2></div>
    <div class="mapWrap">
      <div class="mapPanel">
        <canvas id="map" width="880" height="560"></canvas>
        <div class="hint">10 Spalten √ó 7 Reihen. √úberlagerte Punkte = Hotspots aus Ergebnissen/Analyse.</div>
      </div>
      <div class="col" style="flex:1 1 320px">
        <div class="legend" id="legend"></div>
        <div class="row" style="align-items:center;gap:8px;margin-top:6px">
          <input id="toggleColors" type="checkbox">
          <label for="toggleColors" style="margin:0">Farben-Einstellungen anzeigen</label>
        </div>
        <div id="colorConfigWrap" class="collapse">
          <div id="colorGrid" class="grid" style="margin-top:8px"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- 3) GRUPPEN -->
  <div class="panel">
    <div class="ph"><span class="emoji">üéØ</span><h2 style="margin:0">Gruppen & Zielverteilung</h2></div>

    <div class="row">
      <div class="col">
        <label>Gruppen-Modus</label>
        <select id="groupMode">
          <option value="7" selected>7er (1‚Äì10,11‚Äì20,...,61‚Äì70)</option>
          <option value="5">5er (1‚Äì14,15‚Äì28,29‚Äì42,43‚Äì56,57‚Äì70)</option>
          <option value="3">3er (1‚Äì23,24‚Äì47,48‚Äì70)</option>
        </select>
      </div>
      <div class="col">
        <label>Hot bevorzugen</label>
        <div class="row">
          <label class="small"><input type="checkbox" id="preferPairs" checked> Hot-Paare</label>
          <label class="small"><input type="checkbox" id="preferTriples"> Hot-Triples</label>
        </div>
      </div>
      <div class="col" style="flex:2 1 420px;display:flex;align-items:flex-end;gap:8px">
        <button id="autoEven" class="secondary">Counts gleich verteilen</button>
        <button id="autoByArchive" class="secondary">Counts nach Archiv</button>
        <span class="pill" id="sumInfo">Summe: 0 / S</span>
      </div>
    </div>

    <div id="groupCounts" class="grid" style="margin-top:8px"></div>
    <div id="groupStatus" class="status">Gruppen initialisiert.</div>
  </div>

  <!-- 4) ANALYSE -->
  <div class="panel">
    <div class="ph"><span class="emoji">üìä</span><h2 style="margin:0">Archiv-Analyse (Hot-Paare/Triples im Range)</h2></div>
    <div class="row">
      <div class="col">
        <label>Min. H√§ufigkeit (Paare)</label>
        <input id="minPairFreq" type="number" min="1" value="3">
      </div>
      <div class="col">
        <label>Min. H√§ufigkeit (Triples)</label>
        <input id="minTriFreq" type="number" min="1" value="2">
      </div>
      <div class="col" style="display:flex;align-items:flex-end">
        <button id="runAnalysis" class="secondary">Analyse starten</button>
      </div>
    </div>
    <div id="analysisOut" class="results"></div>
  </div>

  <!-- 5) GENERATOR -->
  <div class="panel">
    <div class="ph"><span class="emoji">üßÆ</span><h2 style="margin:0">Generator</h2></div>
    <div class="row" style="margin-bottom:8px">
      <div class="col">
        <label>Wie viele Kombinationen ausgeben?</label>
        <select id="outCount">
          <option>1</option><option>2</option><option>3</option><option selected>4</option>
          <option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
        </select>
      </div>
      <div class="col" style="display:flex;align-items:flex-end;gap:8px">
        <button id="start" class="primary" disabled>Start</button>
        <button id="stop" class="danger" disabled>Stopp</button>
        <button id="clearResults" class="ghost">Ergebnisse l√∂schen</button>
        <span class="pill" id="liveInfo">idle</span>
      </div>
    </div>
    <progress id="prog" value="0" max="1" style="display:none"></progress>
    <div id="status" class="status">bereit</div>
    <div id="results" class="results"></div>
  </div>

</div>

<!-- ==== TEIL 2 direkt hier unten einf√ºgen ==== -->
</body>
</html>
<script>
(function(){
"use strict";

/* ===== Helpers ===== */
const $ = s => document.querySelector(s);
const text=(el,s)=>{ if(el) el.textContent=s; };
const html=(el,s)=>{ if(el) el.innerHTML=s; };
const fmt=n=>(n||0).toLocaleString("de-DE");
const uniqSorted=a=>Array.from(new Set(a)).sort((x,y)=>x-y);

/* ===== Persist Keys ===== */
const CK_ARCH="keno_ultrap_arch_v3";
const CK_RESULTS="keno_ultrap_results_v1";
const CK_COLORS="keno_ultrap_colors_v1";

/* ===== Globals ===== */
let g_draws=[], g_dates=[], g_drawSize=0;
let g_groups=[]; // [{from,to,color}]
let g_counts=[]; // gew√ºnschte Anzahl pro Gruppe
let worker=null, running=false;
let lastList=[];

/* ===== Map & Colors ===== */
const default7=[{from:1,to:10,color:"#3b82f6"},{from:11,to:20,color:"#22c55e"},{from:21,to:30,color:"#f59e0b"},{from:31,to:40,color:"#ef4444"},{from:41,to:50,color:"#a78bfa"},{from:51,to:60,color:"#14b8a6"},{from:61,to:70,color:"#eab308"}];
const default5=[{from:1,to:14,color:"#60a5fa"},{from:15,to:28,color:"#34d399"},{from:29:42}]; // will be fixed below
/* fix default5 object */
default5[2]={from:29,to:42,color:"#fbbf24"};
default5.push({from:43,to:56,color:"#f87171"},{from:57,to:70,color:"#c084fc"});
const default3=[{from:1,to:23,color:"#93c5fd"},{from:24,to:47,color:"#86efac"},{from:48,to:70,color:"#fde68a"}];

const map=$("#map"), ctx=map.getContext("2d");
function hexWithAlpha(hex,a){const h=hex.replace("#","");const r=parseInt(h.slice(0,2),16),g=parseInt(h.slice(2,4),16),b=parseInt(h.slice(4,6),16);return `rgba(${r},${g},${b},${a})`;}
function cellRect(n){ const col=(n-1)%10, row=Math.floor((n-1)/10); const pad=8, cw=(map.width-pad*2)/10, ch=(map.height-pad*2)/7; return {x:pad+col*cw,y:pad+row*ch,w:cw,h:ch}; }
function drawMap(highlights){
  ctx.clearRect(0,0,map.width,map.height);
  // groups bg
  for(const g of g_groups){ ctx.fillStyle=hexWithAlpha(g.color,0.18); for(let v=g.from;v<=g.to;v++){ const r=cellRect(v); ctx.fillRect(r.x,r.y,r.w,r.h);} }
  // grid + numbers
  ctx.strokeStyle="#223046"; ctx.fillStyle="#dbeafe"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.font="14px ui-sans-serif,system-ui";
  for(let v=1;v<=70;v++){ const r=cellRect(v); ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.fillText(String(v), r.x+r.w/2, r.y+r.h/2); }
  // highlights
  if(Array.isArray(highlights)){
    for(const {num,weight} of highlights){
      const r=cellRect(num);
      ctx.beginPath(); ctx.arc(r.x+r.w/2,r.y+r.h/2,Math.min(r.w,r.h)*0.38,0,Math.PI*2);
      ctx.fillStyle=hexWithAlpha("#ffffff",0.08+0.12*(weight||0));
      ctx.fill();
      ctx.beginPath(); ctx.arc(r.x+r.w/2,r.y+r.h/2,Math.min(r.w,r.h)*0.20,0,Math.PI*2);
      ctx.fillStyle="#e5e7eb"; ctx.fill(); ctx.strokeStyle="#00000055"; ctx.stroke();
    }
  }
}
function buildLegend(){
  const L=$("#legend");
  html(L, g_groups.map((g,i)=>`
    <div class="legend-item">
      <span class="swatch" style="background:${g.color}"></span>
      <span>G${i+1}: ${g.from}-${g.to}</span>
    </div>`).join(""));
}
function buildColorEditor(){
  const wrap=$("#colorGrid"); html(wrap,"");
  html(wrap, g_groups.map((g,i)=>`
    <div class="panel" style="padding:8px">
      <div style="font-weight:700;margin-bottom:6px">Gruppe ${i+1} (${g.from}-${g.to})</div>
      <input type="color" value="${g.color}" data-idx="${i}" class="colPicker">
    </div>`).join(""));
  document.querySelectorAll(".colPicker").forEach(inp=>{
    inp.addEventListener("input", e=>{
      const idx=+e.target.getAttribute("data-idx"); g_groups[idx].color=e.target.value; saveColors(); buildLegend(); drawMap();
    });
  });
}
function saveColors(){ try{ localStorage.setItem(CK_COLORS, JSON.stringify(g_groups.map(g=>({from:g.from,to:g.to,color:g.color})))) }catch{} }
$("#toggleColors").addEventListener("change",()=> $("#colorConfigWrap").classList.toggle("collapse", !$("#toggleColors").checked));

/* ===== Gruppen ===== */
function setGroupMode(mode){
  if(mode==="7") g_groups = JSON.parse(JSON.stringify(default7));
  else if(mode==="5") g_groups = JSON.parse(JSON.stringify(default5));
  else g_groups = JSON.parse(JSON.stringify(default3));
  try{
    const saved=JSON.parse(localStorage.getItem(CK_COLORS)||"[]");
    if(saved.length===g_groups.length){
      for(let i=0;i<g_groups.length;i++){
        if(saved[i].from===g_groups[i].from && saved[i].to===g_groups[i].to) g_groups[i].color=saved[i].color;
      }
    }
  }catch{}
  buildLegend(); buildColorEditor(); buildCountInputs(); drawMap();
  text($("#groupStatus"),"Gruppen initialisiert.");
}
function buildCountInputs(){
  const S=parseInt($("#pickSize").value,10)||6;
  if(!g_counts || g_counts.length!==g_groups.length) g_counts=Array(g_groups.length).fill(0);
  const wrap=$("#groupCounts");
  html(wrap, g_groups.map((g,i)=>`
    <div class="panel" style="padding:8px">
      <div style="font-weight:700;margin-bottom:6px">G${i+1}: ${g.from}-${g.to}</div>
      <input type="number" min="0" max="${S}" step="1" value="${g_counts[i]||0}" data-idx="${i}" class="cntInp">
      <div class="small" style="margin-top:6px">Wieviele Zahlen aus dieser Gruppe?</div>
    </div>`).join(""));
  wrap.querySelectorAll(".cntInp").forEach(inp=> inp.addEventListener("input", onCountChange));
  updateSumInfo();
}
function onCountChange(e){
  const S=parseInt($("#pickSize").value,10)||6;
  const idx=+e.target.getAttribute("data-idx");
  let v=parseInt(e.target.value,10); if(!Number.isFinite(v)||v<0) v=0; if(v>S) v=S; g_counts[idx]=v; e.target.value=v;
  updateSumInfo();
}
function updateSumInfo(){
  const S=parseInt($("#pickSize").value,10)||6;
  const sum=(g_counts||[]).reduce((a,b)=>a+(b||0),0);
  text($("#sumInfo"),`Summe: ${sum} / ${S}`);
  const ok=(sum===S) && g_draws.length>0;
  $("#start").disabled=!ok;
}

/* ===== Archiv laden / speichern / export ===== */
function splitSmart(line){
  if(/\t/.test(line)) return line.split("\t");
  if(line.includes(";")) return line.split(";");
  if(line.includes("|")) return line.split("|");
  if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
  return line.trim().split(/\s+/);
}
function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}
function tryZahlHeader(rows){
  if(!rows.length) return null;
  const header=rows[0].map(x=>String(x).trim()); const idx=[], dateIdx=[];
  for(let i=0;i<header.length;i++){
    if(/^zahl\s*\d+$/i.test(header[i])) idx.push(i);
    if(/datum|date|ziehung|draw|tag/i.test(header[i])) dateIdx.push(i);
  }
  if(idx.length>=5){
    const lists=[], dates=[];
    for(let r=1;r<rows.length;r++){
      const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
      if(nums.length) lists.push(nums);
      let dt=null; if(dateIdx.length){ dt=String(rows[r][dateIdx[0]]??"").trim(); }
      dates.push(dt);
    }
    return {lists, dates, info:`Header erkannt (${idx.length} Zahl-Spalten${dateIdx.length?"+Datum":""})`};
  }
  return null;
}
function detectDashCol(rows){
  let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
  let best=-1,score=-1;
  for(let c=0;c<maxCols;c++){
    let sc=0;
    for(const r of rows){
      if(c>=r.length) continue;
      const cell=String(r[c]??"").trim(); if(!cell) continue;
      const parts=cell.split("-");
      if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
    }
    if(sc>score){score=sc;best=c;}
  }
  return best;
}
function fallbackExtract(raw){
  const out=[], dates=[];
  for(const lnRaw of raw.split(/\r?\n/)){
    const ln=lnRaw.trim(); if(!ln) continue;
    const dtMatch=ln.match(/(\d{4}[-.\/]\d{1,2}[-.\/]\d{1,2})/);
    if(/^\d+(?:-\d+)+$/.test(ln)){ out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); dates.push(dtMatch?dtMatch[1]:null); continue; }
    const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    if(nums.length>=5){ out.push(nums); dates.push(dtMatch?dtMatch[1]:null); }
  }
  return {lists:out, dates};
}
async function ensureJSZip(){
  if(window.JSZip) return;
  await new Promise((res,rej)=>{
    const s=document.createElement("script");
    s.src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
    s.onload=res; s.onerror=()=>rej(new Error("JSZip laden fehlgeschlagen"));
    document.head.appendChild(s);
  });
}
async function handleAnyFile(file){
  if(!file){ text($("#statusTop"),"Keine Datei gew√§hlt."); return; }
  text($("#statusTop"),`Lese Datei: ${file.name}`);
  const name=(file.name||"").toLowerCase();
  try{
    let raw="", sourceLabel="";
    if(name.endsWith(".zip")){
      await ensureJSZip();
      const ab=await file.arrayBuffer();
      const zip=await JSZip.loadAsync(ab);
      const candidates=[];
      zip.forEach((path, entry)=>{
        const p=path.toLowerCase();
        if(p.endsWith(".csv")||p.endsWith(".txt")){
          const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
          candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
        }
      });
      if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
      candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
      const target=candidates[0];
      sourceLabel=`ZIP: ${target.path}`;
      try{ raw=await target.entry.async("string"); }
      catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
    }else{
      sourceLabel=file.name||"Upload";
      try{ raw=await file.text(); }
      catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
    }
    loadArchiveFromRawText(raw, sourceLabel);
  }catch(e){
    text($("#statusTop"),"Fehler beim Lesen: "+(e?.message||e));
    g_draws=[]; g_dates=[]; g_drawSize=0; $("#btnExport").disabled=true; updateSumInfo();
  }
}
function loadArchiveFromRawText(raw, sourceLabel){
  text($("#statusTop"),"Analysiere Datei ‚Ä¶");
  const rows=parseTable(raw);
  let lists=[], dates=[], detected="";
  const h=tryZahlHeader(rows);
  if(h){ lists=h.lists; dates=h.dates; detected=h.info; }
  else{
    const ncol=detectDashCol(rows);
    if(ncol>=0){
      for(const r of rows){
        if(ncol>=r.length) continue;
        const cell=String(r[ncol]??"").trim(); if(!cell) continue;
        const parts=cell.split("-").map(s=>s.trim());
        if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
      }
      detected="Spalte 1-4-‚Ä¶";
    }else{
      const fb=fallbackExtract(raw); lists=fb.lists; dates=fb.dates; detected="Fallback: freie Zahlzeilen";
    }
  }
  if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");

  // dominante L√§nge
  const lenCount=new Map();
  for(const a of lists){ if(a.length>=5 && a.length<=20) lenCount.set(a.length,(lenCount.get(a.length)||0)+1); }
  let bestLen=0,bestCnt=-1; for(const [k,v] of lenCount.entries()){ if(v>bestCnt){bestCnt=v;bestLen=k;} }
  if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");

  g_drawSize=bestLen;
  g_draws = lists.filter(a=>a.length===g_drawSize).map(a=>uniqSorted(a.filter(Number.isInteger).filter(x=>x>=1&&x<=70)));
  g_dates = dates && dates.length===lists.length ? dates.filter((_,i)=>lists[i].length===g_drawSize) : new Array(g_draws.length).fill(null);
  if(!g_draws.length) throw new Error("Nach Filter keine Ziehungen √ºbrig.");

  try{ localStorage.setItem(CK_ARCH, JSON.stringify({draws:g_draws, dates:g_dates, drawSize:g_drawSize, savedAt:Date.now(), source:sourceLabel||""})); }catch{}
  $("#btnExport").disabled=false;

  const ts=new Date();
  text($("#statusTop"),
    `Archiv geladen: ${fmt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}`+
    (sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:"")+
    `\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`
  );
  drawMap(); updateSumInfo();
}
$("#file").addEventListener("change",()=>handleAnyFile($("#file").files[0]));
$("#btnExport").addEventListener("click", ()=>{
  if(!g_draws.length) return;
  const rows=g_draws.map((d,i)=>[g_dates[i]||"",...d].join(",")).join("\n");
  const csv="date,"+Array.from({length:g_drawSize},(_,i)=>"zahl"+(i+1)).join(",")+"\n"+rows;
  const a=document.createElement("a"); a.href=URL.createObjectURL(new Blob([csv],{type:"text/csv;charset=utf-8"})); a.download="keno_normalisiert.csv"; a.click();
});
$("#btnClearArch").addEventListener("click", ()=>{
  localStorage.removeItem(CK_ARCH);
  g_draws=[]; g_dates=[]; g_drawSize=0;
  text($("#statusTop"),"Archiv gel√∂scht."); $("#btnExport").disabled=true;
  updateSumInfo(); drawMap();
});

/* ===== Results Persist ===== */
function saveResults(list){
  try{ localStorage.setItem(CK_RESULTS, JSON.stringify(list||[])); }catch{}
}
function loadResults(){
  try{
    const raw=localStorage.getItem(CK_RESULTS);
    if(raw){ const l=JSON.parse(raw)||[]; if(Array.isArray(l)&&l.length){ lastList=l; renderList(lastList); updateHotspots(lastList); } }
  }catch{}
}
$("#clearResults").addEventListener("click", ()=>{ localStorage.removeItem(CK_RESULTS); lastList=[]; html($("#results"),""); drawMap(); text($("#status"),"Ergebnisse gel√∂scht."); });

/* ===== Analysis Rendering ===== */
function renderAnalysis(data){
  const {pairs,triples}=data||{};
  const topPairs=(pairs||[]).slice(0,80).map(p=>`<div class="fc-line"><b>${p.a} ${p.b}</b><span class="badge">freq: ${p.c}</span></div>`).join("");
  const topTriples=(triples||[]).slice(0,60).map(t=>`<div class="fc-line"><b>${t.a} ${t.b} ${t.c}</b><span class="badge">freq: ${t.n}</span></div>`).join("");
  html($("#analysisOut"),
    (topPairs?`<h3>üî• Top-Paare</h3>${topPairs}`:"<div class='fc-line'>(keine Paare)</div>")+
    (topTriples?`<h3 style="margin-top:12px">üí• Top-Triples</h3>${topTriples}`:"<div class='fc-line'>(keine Triples)</div>")
  );
  // map highlights aus Analysis
  const m=new Map();
  (pairs||[]).slice(0,50).forEach((p,i)=>{ const w=1-(i/50); m.set(p.a,Math.max(m.get(p.a)||0,w)); m.set(p.b,Math.max(m.get(p.b)||0,w));});
  (triples||[]).slice(0,40).forEach((t,i)=>{ const w=1-(i/40); [t.a,t.b,t.c].forEach(n=> m.set(n,Math.max(m.get(n)||0,w))); });
  const highlights=Array.from(m.entries()).map(([num,weight])=>({num,weight}));
  drawMap(highlights);
}

/* ===== Worker ===== */
function buildWorker(){
  if(worker) try{worker.terminate();}catch{}
  const code=`
  let CFG=null, STATE=null, STOP=false;

  function inR(v,a,b){return v>=a&&v<=b;}
  function freq(draws,a,b){const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(inR(v,a,b)) f[v]++; return f;}
  function coPairs(draws,a,b){
    const M=Array.from({length:71},()=>Array(71).fill(0));
    for(const d of draws){
      const s=d.filter(v=>inR(v,a,b));
      for(let i=0;i<s.length;i++) for(let j=i+1;j<s.length;j++){ const x=s[i],y=s[j]; M[x][y]++; M[y][x]++; }
    }
    return M;
  }
  function coTriples(draws,a,b){
    const T=new Map();
    for(const d of draws){
      const s=d.filter(v=>inR(v,a,b)).sort((x,y)=>x-y);
      for(let i=0;i<s.length;i++) for(let j=i+1;j<s.length;j++) for(let k=j+1;k<s.length;k++){
        const key=s[i]+"-"+s[j]+"-"+s[k]; T.set(key,(T.get(key)||0)+1);
      }
    }
    return T;
  }
  function makePool(groups,a,b){
    const pool=groups.map(()=>[]);
    for(let v=a; v<=b; v++){
      for(let gi=0;gi<groups.length;gi++){ const g=groups[gi]; if(inR(v,g.from,g.to)){ pool[gi].push(v); break; } }
    }
    return pool;
  }

  function score(arr, ctx){
    const {baseF, pairM, triM, W} = ctx;
    let s=0;
    for(const v of arr) s += Math.log((baseF[v]||0.5)+1e-9)*W.base;
    for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++){
      const c=pairM[arr[i]][arr[j]]||0; s += Math.log(c+1e-6)*W.pair;
    }
    if(W.tri>0 && arr.length>=3){
      const a=arr.slice().sort((x,y)=>x-y);
      for(let i=0;i<a.length;i++) for(let j=i+1;j<a.length;j++) for(let k=j+1;k<a.length;k++){
        const c=triM.get(a[i]+"-"+a[j]+"-"+a[k])||0; s += Math.log(c+1e-6)*W.tri;
      }
    }
    return s;
  }

  function randChoice(a){ return a[Math.floor(Math.random()*a.length)] }

  function buildCandidate(pool, plan, a, b){
    const used=new Uint8Array(71), out=[];
    for(const gi of plan){
      const cand=pool[gi]; let v=null, tries=0;
      while(tries++<8){ const t=randChoice(cand); if(!used[t]){v=t;break;} }
      if(v==null){ for(const t of cand){ if(!used[t]){v=t;break;} } }
      if(v==null){ for(let x=a;x<=b;x++){ if(!used[x]){v=x;break;} } }
      if(v!=null){ used[v]=1; out.push(v); }
    }
    return out.sort((x,y)=>x-y);
  }

  function mutate(arr, pool, plan, a, b){
    let out=arr.slice();
    const r=Math.random();
    if(r<0.34 && out.length>=2){
      const i=Math.floor(Math.random()*out.length), j=Math.floor(Math.random()*out.length);
      [out[i],out[j]]=[out[j],out[i]];
    }else if(r<0.67){
      // replace one with a number from same group's pool
      const idx=Math.floor(Math.random()*out.length), v=out[idx];
      // find group of v
      let gi=0;
      for(let g=0; g<pool.length; g++){ if(pool[g].includes(v)){ gi=g; break; } }
      const cand=pool[gi];
      out[idx]=randChoice(cand);
    }else{
      // insert & trim (exploration)
      const v=a + Math.floor(Math.random()*(b-a+1));
      if(!out.includes(v)) out.push(v);
      out=Array.from(new Set(out)).sort((x,y)=>x-y);
      if(out.length>plan.length) out.splice(Math.floor(Math.random()*out.length),1);
    }
    // enforce plan length
    if(out.length>plan.length) out=out.slice(0,plan.length);
    while(out.length<plan.length){ const v=a + Math.floor(Math.random()*(b-a+1)); if(!out.includes(v)) out.push(v); }
    return Array.from(new Set(out)).sort((x,y)=>x-y);
  }

  function analyze(draws,a,b,minPair,minTri){
    const M=coPairs(draws,a,b);
    const T=coTriples(draws,a,b);
    const pairs=[];
    for(let i=a;i<=b;i++) for(let j=i+1;j<=b;j++){
      const c=M[i][j]||0; if(c>=minPair) pairs.push({a:i,b:j,c});
    }
    pairs.sort((x,y)=> y.c-x.c || x.a-y.a || x.b-y.b);
    const triples=[];
    for(const [k,v] of T.entries()){
      if(v>=minTri){ const [a1,b1,c1]=k.split("-").map(Number); triples.push({a:a1,b:b1,c:c1,n:v}); }
    }
    triples.sort((x,y)=> y.n-x.n || x.a-y.a || x.b-y.b || x.c-y.c);
    return {pairs,triples};
  }

  function start(cfg){
    CFG=cfg; STOP=false;
    const {drawsAll, rangeMin, rangeMax, groups, counts, preferPairs, preferTriples, S, outCount, mode} = CFG;
    const baseF=freq(drawsAll,rangeMin,rangeMax);
    const pairM=coPairs(drawsAll,rangeMin,rangeMax);
    const triM= preferTriples ? coTriples(drawsAll,rangeMin,rangeMax) : new Map();

    const MODES={
      normal:{iters:25_000, batches:1, W:{base:1.00,pair:preferPairs?0.45:0.15,tri:preferTriples?0.30:0}},
      medium:{iters:95_000, batches:2, W:{base:1.05,pair:preferPairs?0.55:0.20,tri:preferTriples?0.40:0}},
      hard:{iters:280_000, batches:3, W:{base:1.10,pair:preferPairs?0.65:0.25,tri:preferTriples?0.50:0}},
      ultra:{iters:700_000, batches:5, W:{base:1.18,pair:preferPairs?0.78:0.32,tri:preferTriples?0.65:0}}
    };
    const M=MODES[mode]||MODES.normal;

    const pool=makePool(groups,rangeMin,rangeMax);

    const plan=[]; for(let gi=0;gi<groups.length;gi++) for(let k=0;k<counts[gi];k++) plan.push(gi);
    plan.sort((a,b)=> (pool[b].length-pool[a].length) || (a-b));

    STATE={
      start:performance.now(), best:new Map(), iter:0,
      ctx:{baseF,pairM,triM,W:M.W},
      pool, plan, outCount, S, a:rangeMin, b:rangeMax, M
    };

    loop();
  }

  function loop(){
    if(!STATE||STOP) return;
    const {M, ctx, outCount, pool, plan, a, b} = STATE;

    for(let batch=0; batch<M.batches; batch++){
      for(let i=0;i<M.iters;i++){
        let cand=buildCandidate(pool,plan,a,b);
        // local improvement cycles
        for(let k=0;k<4;k++){
          const m=mutate(cand,pool,plan,a,b);
          if(score(m,ctx)>score(cand,ctx)) cand=m;
        }
        const k=cand.join("-");
        if(!STATE.best.has(k)) STATE.best.set(k, score(cand,ctx));
        STATE.iter++;
        if(STATE.iter % 5000 === 0){
          const list=topList(STATE, Math.max(outCount*4, 20));
          postMessage({type:"progress", iter:STATE.iter, elapsed:(performance.now()-STATE.start)/1000, list});
        }
      }
    }
    const list=topList(STATE, outCount);
    postMessage({type:"done", list});
    STATE=null;
  }

  function topList(STATE,n){
    return Array.from(STATE.best.entries())
      .sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]))
      .slice(0,n)
      .map(([k,score],i,arr)=>({k,idx:+((score/((arr[0]?.[1]||1)))*100).toFixed(1),raw:+score.toFixed(3)}));
  }

  onmessage=e=>{
    const m=e.data;
    if(m.cmd==="start") start(m.cfg);
    else if(m.cmd==="analyze"){
      const r=analyze(m.cfg.drawsAll, m.cfg.rangeMin, m.cfg.rangeMax, m.cfg.minPair, m.cfg.minTri);
      postMessage({type:"analysis", data:r});
    }else if(m.cmd==="stop"){ STOP=true; postMessage({type:"stopped"}); }
  };
  `;
  worker=new Worker(URL.createObjectURL(new Blob([code],{type:"application/javascript"})));
  worker.onmessage=onWorkerMsg;
  worker.onerror=e=>{ text($("#status"),"Worker-Fehler: "+(e.message||"unbekannt")); stopUI(); };
}
function onWorkerMsg(ev){
  const m=ev.data;
  if(m.type==="progress"){
    $("#prog").style.display="";
    text($("#status"), `Iterationen: ${fmt(m.iter)} ¬∑ Zeit: ${m.elapsed.toFixed(1)}s ¬∑ Kandidaten: ${fmt(m.list.length)}`);
    lastList=m.list||[]; renderList(lastList); updateHotspots(lastList); saveResults(lastList);
  }else if(m.type==="done"){
    $("#prog").style.display="none";
    text($("#status"), `Fertig ¬∑ Kandidaten: ${fmt((m.list||[]).length)}`);
    lastList=m.list||[]; renderList(lastList); updateHotspots(lastList); saveResults(lastList); stopUI();
  }else if(m.type==="analysis"){
    renderAnalysis(m.data||{}); stopUI(false);
  }else if(m.type==="stopped"){
    stopUI();
  }
}

/* ===== Rendering ===== */
function renderList(list){
  const out=(list||[]).map((it,i)=>{
    const nums=it.k.split("-").map(Number);
    const hits=occurrences(nums);
    const last=hits.at(-1);
    const hx = hits.length ? (last?.date?`#${hits.at(-1).idx} (${last.date})`:`#${hits.at(-1).idx}`) : "‚Äì";
    return `<div class="fc-line">
      <b>${i+1}. ${it.k.replace(/-/g," ")}</b>
      <span class="badge">Score-Idx: ${it.idx}</span>
      <span class="badge">Historie: ${hits.length}√ó (letzte: ${hx})</span>
    </div>`;
  }).join("");
  html($("#results"), out || "<div class='fc-line'>(keine Kandidaten)</div>");
}
function updateHotspots(list){
  const m=new Map();
  (list||[]).forEach((it,rank)=>{
    const w=1-(rank/Math.max(1,(list.length-1)||1));
    it.k.split("-").map(Number).forEach(n=> m.set(n,Math.max(m.get(n)||0,w)));
  });
  drawMap(Array.from(m.entries()).map(([num,weight])=>({num,weight})));
}
function occurrences(arr){
  const set=new Set(arr); const hits=[];
  for(let i=0;i<g_draws.length;i++){
    const d=g_draws[i]; let ok=true; for(const v of set){ if(!d.includes(v)){ ok=false; break; } }
    if(ok) hits.push({idx:i, date:g_dates[i]||null});
  }
  return hits;
}

/* ===== Controls ===== */
function startSearch(){
  if(!g_draws.length) return alert("Bitte zuerst ein Archiv laden.");
  const S=parseInt($("#pickSize").value,10)||6;
  const counts=g_counts.slice();
  const sum=counts.reduce((a,b)=>a+(b||0),0);
  if(sum!==S) return alert("Summe der Gruppen-Counts muss S ergeben.");
  const minV=Math.max(1, Math.min(70, parseInt($("#minVal").value,10)||1));
  const maxV=Math.max(minV, Math.min(70, parseInt($("#maxVal").value,10)||70));

  buildWorker();
  running=true; startUI();

  worker.postMessage({cmd:"start", cfg:{
    drawsAll:g_draws, rangeMin:minV, rangeMax:maxV,
    groups:g_groups, counts, preferPairs:$("#preferPairs").checked, preferTriples:$("#preferTriples").checked,
    S, outCount:parseInt($("#outCount").value,10)||4,
    mode: $("#computeMode").value==="ultra" ? "ultra" : ($("#computeMode").value)
  }});
}
function runAnalysis(){
  if(!g_draws.length) return alert("Bitte zuerst ein Archiv laden.");
  const minV=Math.max(1, Math.min(70, parseInt($("#minVal").value,10)||1));
  const maxV=Math.max(minV, Math.min(70, parseInt($("#maxVal").value,10)||70));
  const minPair=Math.max(1, parseInt($("#minPairFreq").value,10)||3);
  const minTri=Math.max(1, parseInt($("#minTriFreq").value,10)||2);
  buildWorker(); startUI();
  worker.postMessage({cmd:"analyze", cfg:{drawsAll:g_draws, rangeMin:minV, rangeMax:maxV, minPair, minTri}});
}
function stopSearch(){
  if(worker){ worker.postMessage({cmd:"stop"}); }
}

/* UI toggles (Strobo) */
function startUI(){
  $("#start").disabled=true; $("#stop").disabled=false;
  $("#prog").style.display="";
  document.body.classList.add("strobo");
  text($("#liveInfo"),"running");
}
function stopUI(reset=true){
  $("#start").disabled=false; $("#stop").disabled=true;
  $("#prog").style.display="none";
  document.body.classList.remove("strobo");
  text($("#liveInfo"),"idle");
  if(reset){ worker&&worker.terminate(); worker=null; running=false; }
}

$("#start").addEventListener("click", startSearch);
$("#stop").addEventListener("click", stopSearch);
$("#runAnalysis").addEventListener("click", runAnalysis);
$("#groupMode").addEventListener("change", ()=> setGroupMode($("#groupMode").value));
$("#pickSize").addEventListener("change", ()=> buildCountInputs());
$("#autoEven").addEventListener("click", ()=>{
  const S=parseInt($("#pickSize").value,10)||6;
  g_counts = evenSplit(S, g_groups.length); buildCountInputs();
});
$("#autoByArchive").addEventListener("click", ()=>{
  if(!g_draws.length){ alert("Archiv zuerst laden."); return; }
  const S=parseInt($("#pickSize").value,10)||6;
  const shares = groupSharesFromArchive();
  g_counts = proportionalSplit(S, shares); buildCountInputs();
});

function evenSplit(S,G){ const arr=Array(G).fill(0); for(let i=0;i<S;i++) arr[i%G]++; return arr; }
function proportionalSplit(S, shares){
  const raw=shares.map(x=>x*S); const base=raw.map(Math.floor);
  let rest=S-base.reduce((a,b)=>a+b,0);
  const frac=raw.map((x,i)=>({i,f:x-base[i]})).sort((a,b)=> b.f-a.f);
  for(let i=0;i<rest;i++) base[frac[i%frac.length].i]++;
  return base;
}
function groupSharesFromArchive(){
  const counts=Array(g_groups.length).fill(0);
  for(const d of g_draws){
    for(const v of d){
      for(let i=0;i<g_groups.length;i++){ const g=g_groups[i]; if(v>=g.from && v<=g.to){ counts[i]++; break; } }
    }
  }
  const N=g_draws.length||1;
  return counts.map(x=> x/(N*g_drawSize||1));
}

/* ===== Init from storage ===== */
(function initFromCache(){
  try{
    const raw=localStorage.getItem(CK_ARCH);
    if(raw){
      const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_dates=obj.dates||[]; g_drawSize=obj.drawSize||0;
      if(g_draws.length){
        const ts=obj.savedAt?new Date(obj.savedAt):new Date(); const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
        text($("#statusTop"),`Archiv aus Browser: ${fmt(g_draws.length)} Ziehungen (ZL ${g_drawSize})${src}\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`);
        $("#btnExport").disabled=false;
      }
    }
  }catch{}
  // default group mode
  setGroupMode($("#groupMode").value);
  // load persisted results
  loadResults();
})();
})();
</script>