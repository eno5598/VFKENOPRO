<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO ‚Äì Deterministische Analyse (Archiv ‚Üí Wahrscheinlichkeits-Score)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041; --text:#e5e7eb;
    --accent:#22c55e; --accent2:#60a5fa; --warm:#fb923c; --danger:#ef4444; --pink:#a78bfa;
  }
  html,body{height:100%}
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  a{color:#93c5fd;text-decoration:none}
  .box{max-width:1200px;margin:0 auto}
  input[type="file"],input[type="number"],input[type="text"],select,textarea{
    width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid var(--muted);background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .ghost{background:transparent;border:1px dashed var(--muted);color:var(--text)}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 240px}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .pill{display:inline-block;padding:4px 10px;border-radius:999px;border:1px solid var(--muted);background:var(--bg);margin-left:8px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:8px}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  .hint{color:#9ca3af;font-size:14px;margin-top:4px}
  .mono{font-family:ui-monospace,Consolas,Menlo,monospace}

  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .resItem{border:1px solid var(--muted);border-radius:10px;padding:8px}
  .resHead{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px}
  .resNums{font-weight:800}
  .chip{display:inline-block;border:1px solid var(--muted);border-radius:999px;padding:3px 8px;margin:2px 4px 0 0}
  .chip.good{border-color:#16a34a}
  .chip.warn{border-color:#f59e0b}
  .chip.bad{border-color:#ef4444}
  .secTitle{font-weight:900;margin:0 0 6px}
  .fc-line{border:1px dashed var(--muted);border-radius:8px;padding:6px;margin-top:6px}

  /* Progressbar mit Dauer-Infos */
  .progWrap{display:flex;align-items:center;gap:10px}
  progress{width:100%;height:12px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-bar{background:var(--bg)}
  progress::-webkit-progress-value{background:#22c55e}

  /* Tippanalyse: rote Hot-Paare */
  .hotnum{color:#ef4444;font-weight:800}

  /* Anker-Rahmen farblich */
  #p-archiv{border-left:6px solid var(--accent2)}
  #p-settings{border-left:6px solid var(--accent)}
  #p-analyze{border-left:6px solid var(--pink)}
  #p-results{border-left:6px solid var(--warm)}
</style>
</head>
<body>
<div class="box">

  <!-- üóÇÔ∏è Archiv -->
  <div class="panel" id="p-archiv">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2><span class="pill">CSV/TXT/ZIP ¬∑ lokal</span></div>
    <div class="row">
      <div>
        <label>CSV/TXT oder ZIP ausw√§hlen</label>
        <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">
        <div class="hint">
          Unterst√ºtzt: Tabellen mit ‚ÄûZahl1..Zahl20‚Äú, eine Spalte ‚Äû1-4-‚Ä¶‚Äú oder freie Zahlzeilen (‚â•5 Zahlen).<br>
          ZIP darf eine CSV/TXT enthalten (z. B. <i>archiv_keno.csv</i>).<br>
          Manuell laden: <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
        </div>
      </div>
      <div>
        <label>Archiv-Status</label>
        <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
        <div class="row" style="margin-top:6px">
          <button id="clearCache" class="danger">Archiv l√∂schen</button>
        </div>
      </div>
    </div>
  </div>

  <!-- üéõÔ∏è Einstellungen -->
  <div class="panel" id="p-settings">
    <div class="ph"><span class="emoji">üéõÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div>
        <label>KENO-Typ (Kombi-Gr√∂√üe S)</label>
        <select id="kenoType">
          <option value="2">Typ 2</option><option value="3">Typ 3</option><option value="4">Typ 4</option>
          <option value="5">Typ 5</option><option value="6" selected>Typ 6</option><option value="7">Typ 7</option>
          <option value="8">Typ 8</option><option value="9">Typ 9</option><option value="10">Typ 10</option>
        </select>
      </div>
      <div>
        <label>Analyse-Stufe</label>
        <select id="level">
          <option value="normal" selected>Normal (schnell)</option>
          <option value="medium">Mittel (gr√ºndlich)</option>
          <option value="high">High-End (maximal gr√ºndlich)</option>
        </select>
      </div>
      <div>
        <label>Wie viele Kombis ausgeben?</label>
        <input type="number" id="topN" value="12" min="3" max="60">
      </div>
    </div>
    <div class="row" style="margin-top:6px">
      <button id="run" class="primary">Deterministisch analysieren</button>
      <div class="progWrap" style="flex:1 1 420px">
        <progress id="prog" value="0" max="1" style="display:none"></progress>
        <span id="progTxt" class="mono" style="min-width:210px;display:inline-block"></span>
      </div>
    </div>
  </div>

  <!-- üîé Tipp analysieren -->
  <div class="panel" id="p-analyze">
    <div class="ph"><span class="emoji">üß†</span><h2 style="margin:0">Tipp analysieren</h2><span class="pill">Auto-Scroll von Ergebnissen</span></div>
    <label>Dein Tipp (Zahlen mit Leerzeichen/Komma)</label>
    <input type="text" id="tipInput" placeholder="z. B. 10 11 16 22 24 44">
    <div class="row" style="margin-top:6px">
      <button id="checkTip" class="secondary">Tipp analysieren</button>
    </div>
    <div id="tipStatus" class="status" style="display:none"></div>
  </div>

  <!-- üìã Ergebnisse -->
  <div class="panel" id="p-results">
    <div class="ph"><span class="emoji">üìã</span><h2 style="margin:0">Ergebnisse</h2></div>
    <div id="results" class="grid"></div>
    <div id="explain" class="status" style="display:none;margin-top:10px"></div>
  </div>

</div>

<!-- JSZip (ZIP-Entpacken im Browser) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
(function(){
  "use strict";
  /* ========= Kurzhelfer ========= */
  const $=s=>document.querySelector(s);
  const html=(el,s)=>{ if(el) el.innerHTML=s; };
  const text=(el,s)=>{ if(el) el.textContent=s; };
  const uniqSorted=a=>Array.from(new Set(a)).sort((x,y)=>x-y);
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const sum=a=>a.reduce((s,x)=>s+x,0);

  const CACHE_KEY="keno_archive_det_v1";
  const STATS_KEY="keno_stats_v1";

  let g_draws=[], g_drawSize=0;
  let g_stats=null; // {p:[0..70], last:[0..70], due:[0..70], pairPMI: Map "i-j"->pmi, gapProb:[0..69], lmhabias: {low,mid,high}}
  let g_hotPairs=[]; // [{i,j,pmi,count}]
  let g_ready=false;

  /* ========= Archiv laden ========= */
  function splitSmart(line){
    if(/\t/.test(line)) return line.split("\t");
    if(line.includes(";")) return line.split(";");
    if(line.includes("|")) return line.split("|");
    if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
    return line.trim().split(/\s+/);
  }
  function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}
  function tryZahlHeader(rows){
    if(!rows.length) return null;
    const idx=[]; const h=rows[0].map(x=>String(x).trim());
    for(let i=0;i<h.length;i++) if(/^zahl\s*\d+$/i.test(h[i])) idx.push(i);
    if(idx.length>=5){
      const lists=[];
      for(let r=1;r<rows.length;r++){
        const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
        if(nums.length) lists.push(nums);
      }
      return {lists,info:`Header erkannt (${idx.length} Zahl-Spalten)`};
    }
    return null;
  }
  function detectDashCol(rows){
    let max=0; for(const r of rows) if(r.length>max) max=r.length;
    let best=-1,score=-1;
    for(let c=0;c<max;c++){
      let sc=0;
      for(const r of rows){
        if(c>=r.length) continue;
        const cell=String(r[c]??"").trim(); if(!cell) continue;
        const parts=cell.split("-");
        if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }
  function fallbackExtract(raw){
    const out=[];
    for(const lnRaw of raw.split(/\r?\n/)){
      const ln=lnRaw.trim(); if(!ln) continue;
      if(/^\d+(?:-\d+)+$/.test(ln)){ out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); continue; }
      const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
      if(nums.length>=5) out.push(nums);
    }
    return out;
  }
  function loadArchiveFromRawText(raw, source){
    const rows=parseTable(raw);
    let lists=[],detected="";
    const z=tryZahlHeader(rows);
    if(z){ lists=z.lists; detected=z.info; }
    else{
      const ncol=detectDashCol(rows);
      if(ncol>=0){
        for(const r of rows){
          const cell=String(r[ncol]??"").trim(); if(!cell) continue;
          const parts=cell.split("-").map(s=>s.trim());
          if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
        }
        detected="Spalte 1-4-‚Ä¶";
      }else{
        lists=fallbackExtract(raw);
        detected="Fallback: freie Zahlzeilen";
      }
    }
    if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");
    const freq=new Map(); for(const a of lists){ if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1); }
    let bestLen=0,bestCnt=-1; for(const [k,v] of freq.entries()){ if(v>bestCnt){bestCnt=v;bestLen=k;} }
    if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");
    g_drawSize=bestLen;
    g_draws = lists.filter(a=>a.length===g_drawSize).map(a=>uniqSorted(a.filter(Number.isInteger)));
    if(!g_draws.length) throw new Error("Nach Filter keine Ziehungen √ºbrig.");

    localStorage.setItem(CACHE_KEY, JSON.stringify({draws:g_draws, drawSize:g_drawSize, savedAt:Date.now(), source:source||""}));
    const ts=new Date();
    text($("#statusTop"), `Archiv geladen: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}${source?` ¬∑ Quelle: ${source}`:""}\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`);
    g_ready=true; g_stats=null; localStorage.removeItem(STATS_KEY);
  }
  async function handleAnyFile(file){
    if(!file){ text($("#statusTop"), "Keine Datei gew√§hlt."); return; }
    text($("#statusTop"), `Lese Datei: ${file.name}`);
    try{
      if((file.name||"").toLowerCase().endsWith(".zip")){
        if(!window.JSZip){ text($("#statusTop"), "Fehler: JSZip fehlt (CDN)."); return; }
        const zip=await JSZip.loadAsync(await file.arrayBuffer());
        const cand=[];
        zip.forEach((path,entry)=>{
          const p=path.toLowerCase();
          if(p.endsWith(".csv")||p.endsWith(".txt")){
            const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
            cand.push({path,entry,score,size:entry._dataUncompressedSize||0});
          }
        });
        if(!cand.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
        cand.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
        const tgt=cand[0];
        let raw="";
        try{ raw=await tgt.entry.async("string"); }
        catch(_){ const u8=new Uint8Array(await tgt.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(raw, `ZIP:${tgt.path}`);
      }else{
        let txt="";
        try{ txt=await file.text(); }
        catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(txt, file.name||"Upload");
      }
    }catch(e){
      text($("#statusTop"), "Fehler beim Lesen: "+(e?.message||e));
      g_draws=[]; g_drawSize=0; g_ready=false; g_stats=null;
    }
  }
  $("#file").addEventListener("change",()=>handleAnyFile($("#file").files[0]));
  $("#clearCache").addEventListener("click",()=>{
    localStorage.removeItem(CACHE_KEY); localStorage.removeItem(STATS_KEY);
    g_draws=[]; g_drawSize=0; g_ready=false; g_stats=null;
    text($("#statusTop"), "Archiv gel√∂scht. Bitte Datei erneut laden.");
    $("#results").innerHTML=""; $("#explain").style.display="none";
  });
  (function init(){
    try{
      const raw=localStorage.getItem(CACHE_KEY);
      if(raw){
        const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
        if(g_draws.length){
          const ts=obj.savedAt?new Date(obj.savedAt):new Date();
          const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
          text($("#statusTop"), `Archiv aus Browser geladen: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize})${src}\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`);
          g_ready=true;
        }
      }
    }catch{}
  })();

  /* ========= Stats (deterministisch, voll) ========= */
  function computeStats(){
    if(g_stats) return g_stats;
    if(!g_ready||!g_draws.length){ alert("Bitte Archiv laden."); return null; }

    // Einzel-Frequenzen & letzte Sichtung
    const f=Array(71).fill(0), last=Array(71).fill(-1);
    for(let t=0;t<g_draws.length;t++){
      for(const v of g_draws[t]){
        if(v>=1&&v<=70){ f[v]++; last[v]=t; }
      }
    }
    const n=g_draws.length;
    // Laplace smoothing
    const p=Array(71).fill(0); for(let i=1;i<=70;i++) p[i]=(f[i]+1)/(n+70);

    // Due-Index (wie "√ºberf√§llig"): Z ~ (since - E)/std  mit Bernoulli-Geometrie
    const due=Array(71).fill(0);
    for(let i=1;i<=70;i++){
      const pi=p[i], E=(1-pi)/pi, Var=(1-pi)/ (pi*pi), std=Math.sqrt(Var);
      const since = (last[i]<0)? n : (n-1-last[i]);
      due[i] = std>0 ? (since - E)/std : 0;
    }

    // Pair PMI + counts
    const pairCnt=new Map(); // "i-j" as key
    for(const d of g_draws){
      for(let a=0;a<d.length;a++){
        for(let b=a+1;b<d.length;b++){
          const i=d[a], j=d[b]; const key=i<j?`${i}-${j}`:`${j}-${i}`;
          pairCnt.set(key,(pairCnt.get(key)||0)+1);
        }
      }
    }
    const pairPMI=new Map();
    const tot = n; // Ziehungen = Ereignisse
    for(const [key,c] of pairCnt){
      const [si,sj]=key.split("-").map(Number);
      const pij = (c+0.5)/(tot+1); // gl√§tten
      const pi = p[si], pj = p[sj];
      const val = Math.log( (pij) / (pi*pj) + 1e-12 );
      pairPMI.set(key, val);
    }
    // Hot-Paare Liste (f√ºr Anzeige/Tipanalyse)
    g_hotPairs = [...pairPMI.entries()]
      .map(([k,v])=>({i:+k.split("-")[0], j:+k.split("-")[1], pmi:v, count: pairCnt.get(k)||0}))
      .sort((a,b)=> b.pmi-a.pmi || b.count-a.count)
      .slice(0,200);

    // Gap Histogram (global, aus allen Ziehungen)
    const gapCount=Array(70).fill(0);
    let gapTotal=0;
    for(const d of g_draws){
      for(let i=1;i<d.length;i++){
        const g=d[i]-d[i-1];
        if(g>=1 && g<=69){ gapCount[g]++; gapTotal++; }
      }
    }
    // Gl√§ttung (dreipunkt)
    const gapProb=Array(70).fill(0);
    if(gapTotal>0){
      const tmp=gapCount.slice();
      for(let g=1; g<=69; g++){
        const v = (0.25*(tmp[g-1]||tmp[g]) + 0.5*tmp[g] + 0.25*(tmp[g+1]||tmp[g])) / gapTotal;
        gapProb[g]=v;
      }
    }else{
      for(let g=1; g<=69; g++) gapProb[g]=1/69;
    }

    // Low/Mid/High Basis
    const LMH={low:0,mid:0,high:0};
    for(const d of g_draws){
      let l=0,m=0,h=0;
      for(const v of d){ if(v<=23) l++; else if(v<=47) m++; else h++; }
      LMH.low+=l; LMH.mid+=m; LMH.high+=h;
    }
    const LMHsum=LMH.low+LMH.mid+LMH.high || 1;
    const lmhBias={low:LMH.low/LMHsum, mid:LMH.mid/LMHsum, high:LMH.high/LMHsum};

    g_stats={p,last,due,pairPMI,gapProb:gapProb, lmhBias:lmhBias, tot:n};
    try{ localStorage.setItem(STATS_KEY, JSON.stringify(g_stats)); }catch{}
    return g_stats;
  }
  (function loadCachedStats(){
    try{
      const raw=localStorage.getItem(STATS_KEY);
      if(raw){ g_stats=JSON.parse(raw); }
    }catch{}
  })();

  /* ========= Score einer Kombi ========= */
  function scoreCombo(arr, S, stats, level){
    const {p,due,pairPMI,gapProb,lmhBias} = stats;
    // 1) Sum log p_i
    let sProb=0; for(const v of arr) sProb += Math.log(Math.max(1e-12, p[v]));
    // 2) Sum PMI
    let sPMI=0;
    for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++){
      const a=arr[i], b=arr[j]; const key=a<b?`${a}-${b}`:`${b}-${a}`;
      sPMI += (pairPMI.get(key)||0);
    }
    // 3) GapScore: √ò log P(gap)
    let sGap=0; for(let i=1;i<arr.length;i++){ const g=arr[i]-arr[i-1]; sGap += Math.log(Math.max(1e-12, gapProb[g]||1e-12)); }
    sGap = sGap/Math.max(1,(arr.length-1));
    // 4) Balance (low/mid/high)
    let L=0,M=0,H=0; for(const v of arr){ if(v<=23) L++; else if(v<=47) M++; else H++; }
    const idealL = Math.round(S*lmhBias.low), idealM=Math.round(S*lmhBias.mid), idealH=S-idealL-idealM;
    const bal = 1 - (Math.abs(L-idealL)+Math.abs(M-idealM)+Math.abs(H-idealH))/S; // 1 .. 0
    // 5) Due avg
    let sDue=0; for(const v of arr) sDue+=due[v]; sDue/=S;

    // Gewichte je Level (deterministisch)
    const W = (level==="high")
      ? {prob:1.0, pmi:0.35, gap:0.55, bal:0.25, due:0.20}
      : (level==="medium")
      ? {prob:1.0, pmi:0.30, gap:0.45, bal:0.20, due:0.15}
      : {prob:1.0, pmi:0.25, gap:0.35, bal:0.15, due:0.12};

    return (W.prob*sProb) + (W.pmi*sPMI) + (W.gap*sGap) + (W.bal*bal) + (W.due*sDue);
  }

  /* ========= Kandidaten-Pool & Beam Search ========= */
  function buildNumberUtility(stats){
    const {p,due}=stats;
    // Nutzen u_i: Kombination aus log p und Due
    const u=Array(71).fill(0);
    for(let i=1;i<=70;i++) u[i]= 1.0*Math.log(Math.max(1e-12,p[i])) + 0.25*due[i];
    return u;
  }
  function topMNumbers(stats, M){
    const u=buildNumberUtility(stats);
    const arr=[]; for(let i=1;i<=70;i++) arr.push({n:i, u:u[i]});
    arr.sort((a,b)=> b.u-a.u || a.n-b.n);
    return arr.slice(0,M).map(o=>o.n).sort((a,b)=>a-b);
  }

  function beamSearch(S, level, stats, wantN){
    // Stufen-Parameter (deterministisch)
    const P = (level==="high") ? {M:32, B:8000}
          : (level==="medium") ? {M:28, B:2000}
          : {M:24, B:600};
    const base = topMNumbers(stats, P.M);

    // Precompute best-additive bound (heuristisch): f√ºr Upper Bound
    // Wir nehmen die Top-(S) aus base nach "u_i" als grobe obere Schranke.
    const u=buildNumberUtility(stats);
    const baseDesc=[...base].sort((a,b)=> u[b]-u[a]);
    const bestUcum=[]; // kumulative "maximale Utility" aus den besten restlichen Zahlen
    bestUcum[0]=0;
    for(let i=1;i<=S;i++) bestUcum[i]=bestUcum[i-1] + (u[baseDesc[i-1]]||0);

    // Partial = {arr, idxStart, scorePartial, ub}
    let frontier=[{arr:[], startIdx:0, scorePartial:0, ub:Infinity}];
    let totalExpanded=0, totalKept=0;

    function upperBound(part){
      // Grobe UB: aktueller Score + (Rest * max durchschnittlicher Zuwachs)
      // F√ºr Stabilit√§t verwenden wir Utility-Reserve:
      const k=part.arr.length;
      const rest=S-k;
      if(rest<=0) return part.scorePartial;
      // maximal m√∂gliche "u" aus noch nicht benutzten baseDesc
      // (ohne Verbote ‚Äì heuristisch)
      return part.scorePartial + bestUcum[rest];
    }

    // expand Ebene f√ºr Ebene
    for(let depth=0; depth<S; depth++){
      const next=[];
      for(const node of frontier){
        const used=new Set(node.arr);
        for(let i=node.startIdx; i<base.length; i++){
          const v=base[i]; if(used.has(v)) continue;
          // monotone wachsende Kombi
          const ok = (node.arr.length===0) || (v>node.arr[node.arr.length-1]);
          if(!ok) continue;
          const arrNew = node.arr.concat(v);
          // schneller Partials-Score: sch√§tze mit vereinfachter Komponente
          // Wir k√∂nnen schon "scoreCombo" nehmen (deterministisch) ‚Äì reicht bei P.B so.
          const sc = scoreCombo(arrNew, S, stats, level);
          next.push({arr:arrNew, startIdx:i+1, scorePartial:sc});
          totalExpanded++;
        }
      }
      // Pruning auf Top-B nach UpperBound
      for(const node of next){ node.ub = upperBound(node); }
      next.sort((a,b)=> b.ub-a.ub || b.scorePartial-a.scorePartial);
      frontier = next.slice(0, P.B);
      totalKept += frontier.length;
      // Progress
      const p = (depth+1)/S;
      $("#prog").style.display=""; $("#prog").value=p;
      text($("#progTxt"), `Beam Tiefe ${depth+1}/${S} ¬∑ Kandidaten behalten ${frontier.length} ¬∑ exp=${totalExpanded.toLocaleString()}`);
    }

    // finale Scoring & Sortierung
    frontier.sort((a,b)=> b.scorePartial-a.scorePartial);
    const unique = [];
    const seen=new Set();
    for(const it of frontier){
      if(it.arr.length!==S) continue;
      const key=it.arr.join("-");
      if(seen.has(key)) continue; seen.add(key);
      unique.push({arr:it.arr, score:it.scorePartial});
      if(unique.length>=Math.max(60,wantN)) break;
    }
    return unique.slice(0,wantN);
  }

  /* ========= Darstellung ========= */
  function badge(txt, kind){ return `<span class="chip ${kind||""}">${txt}</span>`; }
  function fmtPct(x){ return (x*100).toFixed(2).replace(".",",")+"%"; }

  function explainPanel(stats, S){
    const lines=[];
    lines.push(`Ziehungen: ${stats.tot} ¬∑ Kombigr√∂√üe S=${S}`);
    lines.push(`Hot-Paare (Top 10 nach PMI): `+
      g_hotPairs.slice(0,10).map(p=>`${p.i}-${p.j} (PMI ${p.pmi.toFixed(2)})`).join(" | "));
    lines.push(`Gap-Hotspots: `+
      Array.from({length:69},(_,g)=>({g:g+1,p:stats.gapProb[g+1]||0}))
      .sort((a,b)=>b.p-a.p).slice(0,8)
      .map(o=>`${o.g}`).join(", "));
    $("#explain").style.display=""; $("#explain").textContent=lines.join("\n");
  }

  function renderResults(items, stats, level){
    const S = parseInt($("#kenoType").value,10)||6;
    explainPanel(stats, S);

    const box=$("#results"); box.innerHTML="";
    items.forEach((it,idx)=>{
      const a=it.arr, k=a.join(" ");
      // Gr√ºnde/Badges f√ºr die Kombi:
      // ‚Äì Hot-Paare die enthalten sind
      const set=new Set(a);
      const hotHits=g_hotPairs.filter(h=> set.has(h.i) && set.has(h.j)).slice(0,3);
      const gapBadges = []; for(let i=1;i<a.length;i++){ const g=a[i]-a[i-1]; const gp=stats.gapProb[g]||0; if(gp>(1/69)*1.5) gapBadges.push(g); }
      let L=0,M=0,H=0; for(const v of a){ if(v<=23)L++; else if(v<=47)M++; else H++; }

      const chips = [];
      if(hotHits.length) chips.push(badge("Hot-Paare: "+hotHits.map(h=>`${h.i}-${h.j}`).join(", "),"good"));
      if(gapBadges.length) chips.push(badge("beliebte Gaps: "+gapBadges.join(","),"good"));
      chips.push(badge(`Balance L/M/H: ${L}/${M}/${H}`,""));
      chips.push(badge(`Score: ${it.score.toFixed(3)}`,"warn"));

      const div=document.createElement("div");
      div.className="resItem";
      div.innerHTML = `
        <div class="resHead">
          <div class="resNums">#${idx+1} ¬∑ ${k}</div>
          <div>
            <button class="secondary" data-an="${a.join(",")}">Analysieren</button>
          </div>
        </div>
        <div class="mono">${chips.join(" ")}</div>
      `;
      box.appendChild(div);
    });
  }

  /* ========= Hauptlauf (Deterministisch) ========= */
  $("#run").addEventListener("click", ()=>{
    if(!g_ready || !g_draws.length){ alert("Bitte zuerst Archiv laden."); return; }
    // Stats vorbereiten/cachen
    const stats = computeStats(); if(!stats) return;

    const S = parseInt($("#kenoType").value,10)||6;
    const level = $("#level").value||"normal";
    const wantN = clamp(parseInt($("#topN").value,10)||12, 3, 60);

    // Startanzeige
    $("#results").innerHTML=""; $("#explain").style.display="none";
    $("#prog").style.display=""; $("#prog").value=0; text($("#progTxt"), "Initialisiere‚Ä¶");

    // Beam Search
    const t0=performance.now();
    const top = beamSearch(S, level, stats, wantN);
    const dt=((performance.now()-t0)/1000).toFixed(2);

    renderResults(top, stats, level);
    $("#prog").style.display="none";
    text($("#progTxt"), `fertig in ${dt}s ¬∑ Top ${top.length}`);
    // Auto-Scroll zu Ergebnissen
    document.getElementById("p-results").scrollIntoView({behavior:"smooth", block:"start"});
  });

  /* ========= Tipp analysieren ========= */
  function analyzeTip(arr){
    if(!g_ready||!g_draws.length){ alert("Bitte Archiv laden."); return; }
    const stats=computeStats(); if(!stats) return;

    const tip=uniqSorted(arr.filter(x=>x>=1&&x<=70)); if(!tip.length){ alert("Kein g√ºltiger Tipp."); return; }
    const S=tip.length;
    // Overlaps
    let maxOv=0, cEq=0;
    for(const d of g_draws){
      let i=0,j=0,ov=0;
      while(i<tip.length && j<d.length){
        if(tip[i]===d[j]){ ov++; i++; j++; }
        else if(tip[i]<d[j]) i++; else j++;
      }
      if(ov>maxOv) maxOv=ov;
      if(ov===S) cEq++;
    }
    // Hot-Paare im Tipp
    const set=new Set(tip);
    const hotIn = g_hotPairs.filter(h=> set.has(h.i)&&set.has(h.j) ).slice(0,20);

    // Score der Kombi
    const sc = scoreCombo(tip, S, stats, $("#level").value||"normal");

    const hotHTML = hotIn.length
      ? hotIn.map(h=>`<span class="hotnum">${h.i}-${h.j}</span>`).join(", ")
      : "(keine starken Paare)";

    const lines = [
      `Tipp: ${tip.join(" ")}`,
      `S=${S}`,
      `Max. √úberschneidung √ºber Archiv: ${maxOv}` + (cEq? ` ¬∑ komplett enthalten: ${cEq}√ó`:""),
      `Score (det.): ${sc.toFixed(3)}`,
      `Hot-Paare im Tipp: ${hotHTML}`
    ];
    $("#tipStatus").style.display=""; $("#tipStatus").innerHTML=lines.join("<br>");
    document.getElementById("p-analyze").scrollIntoView({behavior:"smooth", block:"start"});
  }

  $("#checkTip").addEventListener("click", ()=>{
    const raw=String($("#tipInput").value||"").trim();
    const nums=(raw.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    if(!nums.length){ alert("Kein Tipp erkannt."); return; }
    analyzeTip(nums);
  });

  // Analyse-Buttons in Ergebnissen (scrollt hoch zur Tipp-Sektion)
  $("#results").addEventListener("click",(e)=>{
    const btn=e.target.closest("button[data-an]"); if(!btn) return;
    const arr=btn.getAttribute("data-an").split(",").map(x=>parseInt(x,10)).filter(Number.isInteger);
    $("#tipInput").value=arr.join(" ");
    analyzeTip(arr);
  });
})();
</script>
</body>
</html>