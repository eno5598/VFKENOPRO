<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO CRAZY ‚Äì Vorhersage (Normal / Mittel / High-End)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041; --text:#e5e7eb;
    --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444; --pink:#a78bfa;
    --warm:#fb923c;
  }
  html,body{height:100%}
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  a{color:#93c5fd;text-decoration:none}
  .box{max-width:1140px;margin:0 auto}
  input[type="file"],select,input[type="number"]{
    width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid var(--muted);background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 240px}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .fc-block{border:1px dashed var(--muted);border-radius:10px;padding:10px}
  .fc-head{font-weight:800;margin-bottom:6px}
  .fc-topnums{display:flex;flex-wrap:wrap;gap:8px}
  .fc-chip{border:1px solid var(--muted);border-radius:999px;padding:4px 8px}
  .fc-combos{margin-top:8px;display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:6px}
  .fc-line{border:1px solid var(--muted);border-radius:8px;padding:6px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:8px}
  .tiny{font-size:12px;opacity:.9}
  .pill{display:inline-block;padding:4px 10px;border-radius:999px;border:1px solid var(--muted);background:var(--bg);margin-left:8px}

  @keyframes crazyPulse {
    0% { background-color:#0b1220; box-shadow: inset 0 0 0 0 rgba(167,139,250,0.00); }
    50%{ background-color:#120f2b; box-shadow: inset 0 0 60px 0 rgba(167,139,250,0.14); }
    100%{ background-color:#0f0b26; box-shadow: inset 0 0 60px 0 rgba(236,72,153,0.12); }
  }
  body.crazy { animation: crazyPulse 1.2s infinite alternate; }

  .crazyBanner{
    background:linear-gradient(135deg,#a78bfa,#ec4899);
    color:#120a1a;border:1px solid #9a7ff8;border-radius:12px;padding:10px;font-weight:800;
    text-align:center;margin-bottom:6px
  }

  progress{width:100%;height:12px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-bar{background:var(--bg)}
  progress::-webkit-progress-value{background:#22c55e}

  /* Finale kompakt */
  .finalCard{border:1px solid var(--muted);border-radius:10px;padding:8px}
  .finalHead{font-weight:700;margin-bottom:4px}
</style>
</head>
<body class="crazy">
<div class="box">

  <!-- üóÇÔ∏è Archiv -->
  <div class="panel" id="p-archiv" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2><span class="pill">ZIP wird lokal entpackt</span></div>

    <label>CSV/TXT oder ZIP ausw√§hlen</label>
    <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">

    <div class="tiny" style="margin-top:6px">
      Unterst√ºtzt: <b>‚ÄûZahl1..Zahl20‚Äú</b>-Tabellen, <b>eine Spalte ‚Äû1-4-‚Ä¶‚Äú</b> oder <b>freie Zahlzeilen</b> (mind. 5 Zahlen).
      ZIP darf eine CSV/TXT enthalten (am besten ‚Äûkeno/archiv‚Äú im Namen).<br>
      Download (manuell): 
      <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
    </div>

    <div id="statusTop" class="status" style="margin-top:10px">Bereit. (Kein Archiv geladen)</div>
    <div class="row" style="margin-top:6px"><button id="clearCache" class="danger">Archiv l√∂schen</button></div>
  </div>

  <!-- üéõÔ∏è Einstellungen -->
  <div class="panel" id="p-settings" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">üéõÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div>
        <label>Kombi-Gr√∂√üe (KENO-Typ)</label>
        <select id="kenoType">
          <option value="2">Typ 2</option><option value="3">Typ 3</option><option value="4">Typ 4</option>
          <option value="5">Typ 5</option><option value="6" selected>Typ 6</option><option value="7">Typ 7</option>
          <option value="8">Typ 8</option><option value="9">Typ 9</option><option value="10">Typ 10</option>
        </select>
      </div>
      <div>
        <label>Rechenmodus</label>
        <select id="mode">
          <option value="normal" selected>Normal (‚âà 1‚Äì2 min)</option>
          <option value="medium">Mittel (‚âà 5‚Äì10 min)</option>
          <option value="highend">High-End (lange / unbegrenzt)</option>
        </select>
      </div>
      <div>
        <label>Zielzeit</label>
        <select id="target">
          <option value="90" selected>‚âà 1¬Ω min</option>
          <option value="300">‚âà 5 min</option>
          <option value="600">‚âà 10 min</option>
          <option value="1800">‚âà 30 min</option>
          <option value="3600">‚âà 1 h</option>
          <option value="0">Unbegrenzt</option>
        </select>
      </div>
      <div>
        <label>Vorschl√§ge (Finale Anzahl)</label>
        <input type="number" id="finalCount" value="6" min="1" max="30">
      </div>
      <div>
        <label>Seed</label>
        <input type="number" id="seed" value="1" min="0">
      </div>
    </div>
  </div>

  <!-- üîÆ CRAZY Vorhersage -->
  <div class="panel" id="p-crazy" style="border-left:6px solid var(--pink)">
    <div class="crazyBanner">üîÆ CRAZY-VORHERSAGE ‚Äì volle Power (Normal / Mittel / High-End)</div>

    <div class="row" style="margin-top:6px">
      <button id="btnStart" class="primary">Start</button>
      <button id="btnPause" class="secondary" disabled>Pause</button>
      <button id="btnResume" class="secondary" disabled>Weiter</button>
      <button id="btnReset" class="danger" disabled>L√∂schen</button>
      <button id="btnShowTop" class="secondary" disabled>Top 6 sofort zeigen</button>
    </div>

    <div class="row" style="margin-top:8px">
      <div style="flex:2 1 180px">
        <label>Status</label>
        <div id="info" class="status">bereit</div>
      </div>
      <div style="flex:1 1 180px">
        <label>Fortschritt</label>
        <progress id="prog" value="0" max="1" style="display:none"></progress>
        <div id="meters" class="tiny" style="margin-top:6px"></div>
      </div>
    </div>

    <div id="rounds" class="results" style="margin-top:8px"></div>

    <div class="panel" id="finalWrap" style="margin-top:12px;border-left:6px solid var(--accent2);display:none">
      <div class="ph"><span class="emoji">üèÅ</span><h2 style="margin:0">Finale Vorschl√§ge</h2></div>
      <div id="finalGrid" class="grid"></div>
    </div>
  </div>
</div>

<!-- JSZip (ZIP-Entpacken im Browser) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(function(){
  "use strict";
  /* ===== Helpers ===== */
  const $=s=>document.querySelector(s);
  const text=(el,s)=>{ if(el) el.textContent=s; };
  const html=(el,s)=>{ if(el) el.innerHTML=s; };
  const fmtNum=n=> (n||0).toLocaleString('de-DE');
  const fmtPct=x=>{
    const v=x*100;
    if(v>0 && v<0.01) return "0,01%";
    return v.toFixed(2).replace('.',',')+"%";
  };
  const uniqSorted=a=>Array.from(new Set(a)).sort((x,y)=>x-y);

  /* ===== Persistent Keys ===== */
  const AK="keno_archive_v5";
  const SNAP="keno_snap_v2";

  let g_draws=[], g_drawSize=0;

  /* ===== Archiv laden (CSV/TXT/ZIP) ===== */
  function splitSmart(line){
    if(/\t/.test(line)) return line.split("\t");
    if(line.includes(";")) return line.split(";");
    if(line.includes("|")) return line.split("|");
    if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
    return line.trim().split(/\s+/);
  }
  function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}
  function tryZahlHeader(rows){
    if(!rows.length) return null;
    const head=rows[0].map(x=>String(x).trim());
    const idx=[]; for(let i=0;i<head.length;i++) if(/^zahl\s*\d+$/i.test(head[i])) idx.push(i);
    if(idx.length>=5){
      const lists=[];
      for(let r=1;r<rows.length;r++){
        const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
        if(nums.length) lists.push(nums);
      }
      return {lists,info:`Header erkannt (${idx.length} Zahl-Spalten)`};
    }
    return null;
  }
  function detectDashCol(rows){
    let best=-1,score=-1,maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
    for(let c=0;c<maxCols;c++){
      let sc=0;
      for(const r of rows){
        if(c>=r.length) continue;
        const cell=String(r[c]??"").trim(); if(!cell) continue;
        const parts=cell.split("-");
        if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }
  function fallbackExtract(raw){
    const out=[];
    for(const lnRaw of raw.split(/\r?\n/)){
      const ln=lnRaw.trim(); if(!ln) continue;
      if(/^\d+(?:-\d+)+$/.test(ln)){
        out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); continue;
      }
      const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
      if(nums.length>=5) out.push(nums);
    }
    return out;
  }
  function loadArchiveFromRawText(raw, sourceLabel){
    const rows=parseTable(raw);
    let lists=[], detected="";
    const h=tryZahlHeader(rows);
    if(h){ lists=h.lists; detected=h.info; }
    else{
      const ncol=detectDashCol(rows);
      if(ncol>=0){
        for(const r of rows){
          if(ncol>=r.length) continue;
          const cell=String(r[ncol]??"").trim(); if(!cell) continue;
          const parts=cell.split("-").map(s=>s.trim());
          if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
        }
        detected="Spalte 1-4-‚Ä¶";
      }else{
        lists=fallbackExtract(raw);
        detected="Fallback: freie Zahlzeilen";
      }
    }
    if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");

    const cnt=new Map();
    for(const a of lists){ const L=a.length; if(L>=5 && L<=20) cnt.set(L,(cnt.get(L)||0)+1); }
    let bestLen=0,bestCnt=-1;
    for(const [k,v] of cnt.entries()){ if(v>bestCnt){bestCnt=v; bestLen=k;} }
    if(!bestLen) throw new Error("Keine Listen 5‚Äì20 erkannt.");

    g_drawSize=bestLen;
    g_draws = lists.filter(a=>a.length===g_drawSize).map(a=>uniqSorted(a.filter(Number.isInteger)));
    if(!g_draws.length) throw new Error("Nach Filter keine Ziehungen.");

    const ts=Date.now();
    try{ localStorage.setItem(AK, JSON.stringify({draws:g_draws,drawSize:g_drawSize,savedAt:ts,source:sourceLabel||""})); }catch{}
    text($("#statusTop"), `Archiv geladen: ${fmtNum(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}${sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:""}\nGespeichert am ${new Date(ts).toLocaleString()}`);
    // Reset Anzeige
    $("#rounds").innerHTML=""; $("#finalWrap").style.display="none"; setInfo("bereit"); $("#prog").style.display="none";
    toggleRunButtons('idle');
  }
  async function handleAnyFile(file){
    if(!file){ text($("#statusTop"),"Keine Datei gew√§hlt."); return; }
    text($("#statusTop"),`Lese Datei: ${file.name}`);
    const name=(file.name||"").toLowerCase();
    try{
      if(name.endsWith(".zip")){
        if(!window.JSZip){ text($("#statusTop"),"Fehler: JSZip nicht verf√ºgbar."); return; }
        const ab=await file.arrayBuffer();
        const zip=await JSZip.loadAsync(ab);
        const candidates=[];
        zip.forEach((path,entry)=>{
          const p=path.toLowerCase();
          if(p.endsWith(".csv")||p.endsWith(".txt")){
            const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
            candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
          }
        });
        if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
        candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
        const target=candidates[0];
        text($("#statusTop"),`Entpacke & lese: ${target.path}`);
        let raw="";
        try{ raw = await target.entry.async("string"); }
        catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(raw, `ZIP: ${target.path}`);
      }else{
        let txt="";
        try{ txt=await file.text(); }
        catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(txt, file.name||"Upload");
      }
    }catch(e){
      text($("#statusTop"), "Fehler: "+(e?.message||e));
      g_draws=[]; g_drawSize=0;
    }
  }
  $("#file").addEventListener("change", ()=> handleAnyFile($("#file").files[0]));
  $("#clearCache").addEventListener("click",()=>{
    try{ localStorage.removeItem(AK); localStorage.removeItem(SNAP);}catch{}
    g_draws=[]; g_drawSize=0;
    text($("#statusTop"),"Archiv gel√∂scht. Bitte erneut laden."); setInfo("bereit"); $("#prog").style.display="none";
    $("#rounds").innerHTML=""; $("#finalWrap").style.display="none";
    toggleRunButtons('idle');
  });
  (function init(){
    try{
      const raw=localStorage.getItem(AK);
      if(raw){
        const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
        if(g_draws.length){
          const ts=obj.savedAt?new Date(obj.savedAt):new Date();
          const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
          text($("#statusTop"), `Archiv aus Browser geladen: ${fmtNum(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize})${src}\nGespeichert am ${ts.toLocaleString()}`);
        }
      }
    }catch{}
    toggleRunButtons('idle'); setInfo("bereit");
  })();

  /* ===== UI-Status ===== */
  function setInfo(s){ text($("#info"), s); }
  function toggleRunButtons(state){
    // state: idle | running | paused | finished
    const bS=$("#btnStart"), bP=$("#btnPause"), bR=$("#btnResume"), bX=$("#btnReset"), bT=$("#btnShowTop");
    if(state==='running'){ bS.disabled=true; bP.disabled=false; bR.disabled=true; bX.disabled=false; bT.disabled=false; }
    else if(state==='paused'){ bS.disabled=true; bP.disabled=true; bR.disabled=false; bX.disabled=false; bT.disabled=false; }
    else { // idle/finished
      bS.disabled=false; bP.disabled=true; bR.disabled=true; bX.disabled=true; bT.disabled=true;
    }
  }

  /* ===== Worker ===== */
  let worker=null;
  let globalBest=new Map(); // {k: "1-2-...", score: sumC}
  let roundSeen=new Map();
  let runStartTs=0;
  let modeCfg={ itersBase: 5_000_000, burst: 4000 }; // will be overridden

  function ensureWorker(){
    if(worker) return;
    const code = `
      let STATE=null; // {S, mode, targetSec, seed, burst, startTs, iter, stopTs, paused, drawsSub, drawsAll, topK}
      let COMB=null; let APPEAR=null; let PBASE=null; let PAIR=null; let GAPW=null;

      function rnd(seed){ let t=seed>>>0; return ()=>{ t=(t+0x6D2B79F5)>>>0; let r=t^(t>>>15); r=Math.imul(r^(r>>>7),61|r); r=(r^(r>>>14))>>>0; return r/4294967296; }; }
      function norm(p){ let s=0; for(let i=1;i<=70;i++) s+=p[i]; if(s<=0){ for(let i=1;i<=70;i++) p[i]=1/70; return p; } for(let i=1;i<=70;i++) p[i]/=s; return p; }
      function freq(draws){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=1&&v<=70) f[v]++; return f; }
      function lastSeen(draws){ const last=Array(71).fill(-1); for(let i=0;i<draws.length;i++) for(const v of draws[i]) last[v]=i; return last; }
      function pairCo(draws){
        const M=Array.from({length:71},()=>Array(71).fill(0));
        for(const d of draws){
          for(let i=0;i<d.length;i++) for(let j=i+1;j<d.length;j++){
            const a=d[i],b=d[j]; if(a>=1&&a<=70&&b>=1&&b<=70){ M[a][b]++; M[b][a]++; }
          }
        }
        return M;
      }
      function gapWeights(draws){
        const w=Array(70).fill(0);
        const src = draws.length>20000 ? draws.slice(-20000) : draws;
        for(const d of src){
          const s=d.slice().sort((a,b)=>a-b);
          for(let i=1;i<s.length;i++){ const g=s[i]-s[i-1]; if(g>=1&&g<=69) w[g]+=1; }
        }
        for(let i=2;i<69;i++) w[i]=0.25*w[i-1]+0.5*w[i]+0.25*w[i+1];
        let m=Math.max(1, ...w); for(let i=1;i<=69;i++) w[i]/=m;
        return w;
      }
      function baseP(drawsSub, drawsAll, mode){
        const f=freq(drawsSub), last=lastSeen(drawsAll), nAll=drawsAll.length;
        const p=Array(71).fill(0);
        for(let i=1;i<=70;i++){
          const since=(last[i]<0)? nAll : (nAll-1-last[i]);
          const boost = mode==='highend' ? (1 + Math.min(2.5, since/Math.max(8, nAll/25)))
                      : mode==='medium'  ? (1 + Math.min(1.8, since/Math.max(10, nAll/20)))
                                         : (1 + Math.min(1.3, since/Math.max(12, nAll/30)));
          p[i] = (f[i] + 0.5) * boost;
        }
        // Gl√§ttung nach Bereichen
        for(const [L,R,w] of [[1,23,1.04],[24,47,1.02],[48,70,1.00]]){
          let s=0; for(let i=L;i<=R;i++) s+=p[i];
          const avg=s/Math.max(1,(R-L+1));
          for(let i=L;i<=R;i++) p[i] = 0.8*p[i] + 0.2*avg*w;
        }
        return norm(p);
      }
      function sampleOne(p, used, rng){
        let sum=0; for(let i=1;i<=70;i++) if(!used.has(i)) sum+=p[i];
        let r=rng()*sum, acc=0;
        for(let i=1;i<=70;i++){ if(used.has(i)) continue; acc+=p[i]; if(acc>=r) return i; }
        for(let i=1;i<=70;i++) if(!used.has(i) && p[i]>0) return i;
        return -1;
      }
      function drawS(pBase, pair, S, rng){
        const used=new Set(); const out=[];
        while(out.length<S){
          const p=pBase.slice();
          if(out.length){
            for(let i=1;i<=70;i++){
              if(used.has(i)){ p[i]=0; continue; }
              let sc=0; for(const a of out){ sc+=pair[i][a]; }
              p[i]*=(1 + sc*0.0018);
            }
          }
          norm(p);
          const pick=sampleOne(p,used,rng);
          if(pick<0) break;
          used.add(pick); out.push(pick);
        }
        out.sort((a,b)=>a-b); return out;
      }
      function gapScore(arr){
        let sc=0;
        for(let i=1;i<arr.length;i++){
          const g=arr[i]-arr[i-1];
          if(g>=1 && g<=69) sc += (GAPW[g]||0);
        }
        return sc/(arr.length-1||1);
      }
      function scoreCombo(arr, pBase, pair){
        let sProb=0; for(const v of arr) sProb += Math.log(Math.max(1e-12, pBase[v]));
        let sPair=0; for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) sPair += pair[arr[i]][arr[j]];
        let sGap = gapScore(arr);
        let low=0, mid=0, high=0; for(const v of arr){ if(v<=23) low++; else if(v<=47) mid++; else high++; }
        const bal = 1 - (Math.abs(low-mid)+Math.abs(mid-high)+Math.abs(low-high))/(2*arr.length);
        // Gewichte je Modus sp√§ter adaptiv getuned
        return  1.00*sProb + 0.002*sPair + 0.50*sGap + 0.25*bal;
      }
      const keyOf = a=>a.join('-');

      function initState(cfg){
        STATE = {
          S:cfg.S, mode:cfg.mode, targetSec:cfg.targetSec, seed:(cfg.seed>>>0)||1,
          burst:cfg.burst, startTs:performance.now(), iter:0, paused:false,
          drawsSub:cfg.drawsSub, drawsAll:cfg.drawsAll, topK:cfg.topK||64
        };
        COMB=new Map(); APPEAR=Array(71).fill(0);
        PBASE = baseP(STATE.drawsSub, STATE.drawsAll, STATE.mode);
        PAIR  = pairCo(STATE.drawsSub);
        GAPW  = gapWeights(STATE.drawsAll);
      }
      function snapshot(){
        return {
          S:STATE.S, mode:STATE.mode, targetSec:STATE.targetSec, seed:STATE.seed, burst:STATE.burst,
          iter:STATE.iter, elapsed:(performance.now()-STATE.startTs),
          PBASE, APPEAR, // Arrays
          // COMB komprimiert ‚Üí Array von [k,c] Top N
          COMB: Array.from(COMB.entries()).sort((a,b)=>b[1]-a[1]).slice(0,2000),
          // Pair/GAP nicht n√∂tig erneut (rebuildbar aus drawsSub/All), aber f√ºr Genauigkeit speichern:
          // Weglassen, um Snapshot klein zu halten.
        };
      }
      function restore(state, cfg){
        STATE = {
          S:state.S, mode:state.mode, targetSec:state.targetSec, seed:state.seed,
          burst:state.burst, startTs:performance.now(), iter:state.iter||0, paused:false,
          drawsSub:cfg.drawsSub, drawsAll:cfg.drawsAll, topK:cfg.topK||64
        };
        PBASE = state.PBASE; APPEAR = state.APPEAR;
        COMB = new Map(state.COMB);
        // Rebuild PAIR/GAPW
        PAIR  = pairCo(STATE.drawsSub);
        GAPW  = gapWeights(STATE.drawsAll);
      }
      function topCombos(limit){
        const arr=[...COMB.entries()].sort((a,b)=>b[1]-a[1] || (a[0]<b[0]?-1:1));
        return arr.slice(0,limit).map(([k,c])=>({k,c}));
      }
      function topNums(total){
        const out=[]; for(let i=1;i<=70;i++) out.push({n:i, p: total? APPEAR[i]/total : 0, c: APPEAR[i]});
        out.sort((a,b)=>b.p-a.p || b.c-a.c || a.n-b.n);
        return out.slice(0,30);
      }

      function tick(){
        if(!STATE || STATE.paused) return;
        const now=performance.now();
        const elapsed = (now-STATE.startTs)/1000;

        // Zielzeit erreicht?
        if(STATE.targetSec>0 && elapsed>=STATE.targetSec){
          postMessage({type:'finish', top:topCombos(STATE.topK), nums:topNums(STATE.iter), iter:STATE.iter, elapsed});
          return;
        }

        const rng=rnd(STATE.seed + STATE.iter*13 + (STATE.mode==='highend'? 7919: 101));
        const B=STATE.burst;
        for(let t=0;t<B;t++){
          const tip = drawS(PBASE, PAIR, STATE.S, rng);
          const sc  = scoreCombo(tip, PBASE, PAIR);
          const key = keyOf(tip);
          const prev= COMB.get(key)||0;
          COMB.set(key, prev + Math.max(1, Math.floor(sc*10+3)));
          for(const v of tip) APPEAR[v]++;
        }
        STATE.iter += B;

        // leichte Adaption, damit Vielfalt bleibt
        if((STATE.iter/B)%10===0){
          const total=STATE.iter;
          const topN=topNums(total);
          const cut  = Math.max(0.010, 0.85*(topN[Math.min(19,topN.length-1)]?.p||0));
          const cool = STATE.mode==='highend'? 0.994 : 0.996;
          const warm = STATE.mode==='highend'? 1.007 : 1.005;
          for(let i=1;i<=70;i++){
            const pNow = (APPEAR[i]/total) || 0;
            PBASE[i] = PBASE[i] * (pNow>=cut ? cool : warm);
            if(PBASE[i]<1e-12) PBASE[i]=1e-12;
          }
          // normieren
          let s=0; for(let i=1;i<=70;i++) s+=PBASE[i]; for(let i=1;i<=70;i++) PBASE[i]/=s;
        }

        if((STATE.iter/B)%5===0){
          postMessage({type:'progress',
                       top:topCombos(STATE.topK), nums:topNums(STATE.iter),
                       iter:STATE.iter, elapsed, target:STATE.targetSec});
        }
        setTimeout(tick,0);
      }

      onmessage = (ev)=>{
        const m=ev.data;
        if(m.cmd==='start'){
          initState(m.cfg);
          postMessage({type:'started'});
          tick();
        }else if(m.cmd==='pause'){
          if(STATE){ STATE.paused=true; postMessage({type:'snapshot', snap:snapshot()}); }
        }else if(m.cmd==='resume'){
          if(!STATE){ // from snap
            restore(m.snap, m.cfg);
          }else{
            STATE.paused=false;
            STATE.startTs=performance.now();
          }
          postMessage({type:'resumed'}); tick();
        }else if(m.cmd==='reset'){
          STATE=null; COMB=null; APPEAR=null; PBASE=null; PAIR=null; GAPW=null;
          postMessage({type:'reset'});
        }
      };
    `;
    const blob=new Blob([code],{type:'application/javascript'});
    const url=URL.createObjectURL(blob);
    worker=new Worker(url);
    worker.onmessage=(ev)=>{
      const m=ev.data;
      if(m.type==='started'){
        runStartTs=performance.now(); toggleRunButtons('running'); $("#prog").style.display="";
        setInfo("l√§uft‚Ä¶"); updateMeters(0,0, getTargetSec());
      }else if(m.type==='progress'){
        applyTop(m.top, m.iter);
        applyNums(m.nums, m.iter);
        updateMeters(m.iter, m.elapsed, m.target||0);
        mergeGlobal(m.top);
      }else if(m.type==='finish'){
        applyTop(m.top, m.iter);
        applyNums(m.nums, m.iter);
        updateMeters(m.iter, m.elapsed, getTargetSec());
        finalize();
        toggleRunButtons('finished');
        $("#prog").style.display="none";
        setInfo("fertig");
      }else if(m.type==='snapshot'){
        saveSnapshot(m.snap);
        toggleRunButtons('paused');
        setInfo("pausiert (Snapshot gespeichert)");
      }else if(m.type==='resumed'){
        toggleRunButtons('running');
        setInfo("l√§uft weiter‚Ä¶");
        $("#prog").style.display="";
      }else if(m.type==='reset'){
        toggleRunButtons('idle');
        setInfo("bereit");
        $("#prog").style.display="none";
        $("#rounds").innerHTML="";
        $("#finalWrap").style.display="none";
        globalBest.clear(); roundSeen.clear();
        try{ localStorage.removeItem(SNAP);}catch{}
      }
    };
    worker.onerror=(e)=>{
      setInfo("Fehler im Worker: "+(e.message||"unbekannt"));
      toggleRunButtons('idle'); $("#prog").style.display="none";
    };
  }

  /* ===== Runden-/Top-UI ===== */
  function ensureRoundCard(idx){
    let wrap=document.getElementById("round-"+idx);
    if(wrap) return wrap;
    wrap=document.createElement("div");
    wrap.className="fc-block";
    wrap.id="round-"+idx;
    wrap.innerHTML=`
      <div class="fc-head">Live-Block ${idx+1}</div>
      <div class="fc-topnums" id="nums-${idx}"></div>
      <div class="fc-combos" id="combos-${idx}"></div>
    `;
    $("#rounds").appendChild(wrap);
    return wrap;
  }
  let blockIdx=0; // wir rotieren Bl√∂cke, damit DOM nicht explodiert
  function renderTopNums(idx, arr, iter){
    const el=$("#nums-"+idx); if(!el) return;
    const line = (arr||[]).slice(0,20).map(x=>`<span class="fc-chip">${x.n} <span class="badge">${fmtPct(iter?x.p:0)} ¬∑ ${fmtNum(x.c)}x</span></span>`).join("");
    html(el, line || "(noch keine Daten)");
  }
  function renderTopCombos(idx, list, iter){
    const el=$("#combos-"+idx); if(!el) return;
    const rows=(list||[]).slice(0,24).map(o=>{
      const p = iter>0 ? (o.c/Math.max(1,iter)) : 0;
      return `<div class="fc-line"><b>${o.k.replace(/-/g," ")}</b> <span class="badge">${fmtPct(p)} ¬∑ ${fmtNum(o.c)}x</span></div>`;
    }).join("");
    html(el, rows || "(noch keine Daten)");
  }
  function applyTop(list, iter){
    const idx=blockIdx%4; ensureRoundCard(idx);
    renderTopCombos(idx, list, iter);
  }
  function applyNums(nums, iter){
    const idx=blockIdx%4; ensureRoundCard(idx);
    renderTopNums(idx, nums, iter);
    blockIdx++;
  }

  function mergeGlobal(list){
    for(const it of (list||[])){
      const k=it.k, c=it.c|0;
      const prev=globalBest.get(k)||{c:0};
      prev.c += c; globalBest.set(k, prev);
    }
  }
  function finalize(){
    const N = Math.max(1, Math.min(30, parseInt($("#finalCount").value,10)||6));
    const items = Array.from(globalBest.entries()).map(([k,v])=>({k,score:v.c}))
      .sort((a,b)=> b.score-a.score || (a.k<b.k?-1:1)).slice(0,N);
    const box=$("#finalGrid"); box.innerHTML="";
    for(const it of items){
      const div=document.createElement("div");
      div.className="finalCard";
      div.innerHTML=`<div class="finalHead">${it.k.replace(/-/g," ")}</div><div class="tiny">Score: ${fmtNum(it.score)}</div>`;
      box.appendChild(div);
    }
    $("#finalWrap").style.display="";
  }

  /* ===== Meters / Progress ===== */
  function getTargetSec(){ const t=parseInt($("#target").value,10)||0; return t; }
  function updateMeters(iter, elapsedSec, targetSec){
    const itS = elapsedSec>0 ? iter/elapsedSec : 0;
    const txt =
      `Zeit: ${elapsedSec.toFixed(1)}s${targetSec>0?` / Ziel ${targetSec}s`:''}\n`+
      `Iterationen: ${fmtNum(iter)}  ¬∑  ~${fmtNum(Math.floor(itS))}/s`;
    text($("#meters"), txt);
    if(targetSec>0){
      $("#prog").style.display="";
      $("#prog").value = Math.min(1, elapsedSec/targetSec);
    }else{
      $("#prog").style.display="none";
    }
  }

  /* ===== Snapshots (Pause/Weiter) ===== */
  function saveSnapshot(snap){
    // lege zus√§tzliche Metadaten ab (Mode, Target, S, Seed, Zeit)
    const meta={
      when: Date.now(),
      mode: $("#mode").value,
      target: getTargetSec(),
      S: parseInt($("#kenoType").value,10)||6,
      seed: (+$("#seed").value)>>>0
    };
    try{ localStorage.setItem(SNAP, JSON.stringify({snap,meta})); }catch{}
  }
  function loadSnapshot(){
    try{
      const raw=localStorage.getItem(SNAP);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch{ return null; }
  }

  /* ===== Start/Pause/Weiter/Reset/Top ===== */
  function cfgByMode(mode){
    // Iterations/Burst so w√§hlen, dass es wirklich ‚Äûackert‚Äú
    if(mode==='normal')  return { burst: 4000 };
    if(mode==='medium')  return { burst: 6000 };
    /* highend */        return { burst: 8000 };
  }
  function startRun(){
    if(!g_draws.length){ alert("Bitte Archiv laden (CSV/TXT/ZIP)."); return; }
    ensureWorker();
    const mode=$("#mode").value||"normal";
    const targetSec=getTargetSec(); // 0 = unbegrenzt
    const S=parseInt($("#kenoType").value,10)||6;
    const seed=(+$("#seed").value)>>>0;
    const burst=cfgByMode(mode).burst;
    globalBest.clear(); roundSeen.clear();
    $("#rounds").innerHTML=""; $("#finalWrap").style.display="none";
    // gesamte Historie immer nutzen
    const drawsSub = g_draws; // (wir filtern nicht mehr)
    const cfg={ S, mode, targetSec, seed, burst, drawsSub, drawsAll:g_draws, topK:64 };
    worker.postMessage({cmd:'start', cfg});
  }
  function pauseRun(){ if(!worker){return;} worker.postMessage({cmd:'pause'}); }
  function resumeRun(){
    if(!g_draws.length){ alert("Kein Archiv geladen."); return; }
    ensureWorker();
    const data=loadSnapshot();
    if(!data){ alert("Kein Snapshot gefunden."); return; }
    const mode=data.meta?.mode || $("#mode").value || "normal";
    const S   =data.meta?.S    || parseInt($("#kenoType").value,10)||6;
    const target=data.meta?.target ?? getTargetSec();
    const seed=data.meta?.seed ?? ((+$("#seed").value)>>>0);
    const burst=cfgByMode(mode).burst;
    const cfg={ S, mode, targetSec:target, seed, burst, drawsSub:g_draws, drawsAll:g_draws, topK:64 };
    worker.postMessage({cmd:'resume', snap:data.snap, cfg});
  }
  function resetRun(){
    if(!worker){ toggleRunButtons('idle'); setInfo("bereit"); $("#prog").style.display="none"; $("#rounds").innerHTML=""; $("#finalWrap").style.display="none"; try{localStorage.removeItem(SNAP);}catch{}; return; }
    worker.postMessage({cmd:'reset'});
  }
  function showTopNow(){
    finalize();
    $("#finalWrap").scrollIntoView({behavior:"smooth", block:"start"});
  }

  $("#btnStart").addEventListener("click", ()=>{ toggleRunButtons('running'); $("#prog").value=0; $("#prog").style.display = (getTargetSec()>0); setInfo("starte‚Ä¶"); startRun(); });
  $("#btnPause").addEventListener("click", pauseRun);
  $("#btnResume").addEventListener("click", resumeRun);
  $("#btnReset").addEventListener("click", resetRun);
  $("#btnShowTop").addEventListener("click", showTopNow);

  /* ===== Archiv init aus Cache ===== */
  function setTop(s){ text($("#statusTop"), s); }
  function setInfoInit(){
    if(!g_draws.length){ setTop("Bereit. (Kein Archiv geladen)"); }
  }
  setInfoInit();

  // Datei-Handling (bereits oben mit Listener versehen)

})();
</script>
</body>
</html>