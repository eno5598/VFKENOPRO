<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>KENO Tool – ZIP speichern (IndexedDB) • Read‑only Map (v10)</title>

<!-- ZIP & CSV parsing (online laden) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root{
    --bg:#070a0f; --panel:#0f1421; --muted:#a2adbd; --text:#eef2f7;
    --accent:#22c55e; --warn:#f59e0b; --bad:#ef4444;
    --g1:#4f83ff; --g2:#22C55E; --g3:#A855F7; --g4:#F59E0B; --g5:#EF4444; --g6:#06B6D4; --g7:#C084FC;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(64,128,255,.12), transparent 50%),
      radial-gradient(800px 400px at 110% 10%, rgba(192,132,252,.12), transparent 50%),
      linear-gradient(180deg, #06080c 0%, #0b0f18 100%);
  }
  header{position:sticky; top:0; z-index:7; backdrop-filter: blur(8px);
    background:linear-gradient(180deg, rgba(15,20,33,.85), rgba(15,20,33,.55));
    border-bottom:1px solid rgba(255,255,255,.06); padding:18px 16px;
  }
  header h1{margin:0; font-size:1.1rem}
  header .sub{margin-top:6px; color:var(--muted); font-size:.92rem}
  main{max-width:1140px; margin:0 auto; padding:18px; display:grid; grid-template-columns: 1.05fr 1fr; gap:14px}
  @media (max-width:1080px){ main{grid-template-columns:1fr} }
  .card{background:linear-gradient(180deg, rgba(21,28,44,.92), rgba(15,20,33,.95)); border:1px solid rgba(255,255,255,.06); border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.4), inset 0 1px 0 rgba(255,255,255,.04)}
  .col-span-2{grid-column:1 / -1}
  .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
  .btn{border:1px solid rgba(255,255,255,.08); background:#0f1524; color:#eef2f7; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600}
  .btn:hover{transform:translateY(-1px)}
  .btn.ok{background:linear-gradient(180deg,#28c76f,#19995a); border:none}
  .btn.warn{background:linear-gradient(180deg,#f59e0b,#d97706); border:none}
  input[type="file"], input[type="number"], select, input[type="text"]{
    background:#0f1524; color:#eef2f7; border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius:10px; outline:none;
  }
  .small{font-size:.85rem} .muted{color:var(--muted)}
  .badge{padding:4px 8px; border-radius:999px; background:#0f172a; border:1px solid rgba(255,255,255,.1); font-size:.8rem}
  .tags{display:flex; gap:8px; flex-wrap:wrap}

  /* Groups */
  .groupBar{display:grid; grid-template-columns: auto 1fr auto auto auto; align-items:center; gap:10px;
    padding:8px 10px; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06); margin-bottom:8px}
  .qtyCtl{display:flex; gap:6px; align-items:center}
  .qtyBtn{width:32px; height:32px; display:grid; place-items:center; font-weight:900; border-radius:8px; cursor:pointer;
    border:1px solid rgba(255,255,255,.12); background:#0e1528}
  .qty{min-width:48px; text-align:center; font-weight:800; padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:#0e1528}

  /* MAP (READ-ONLY) */
  .mapWrap{display:grid; gap:12px}
  .mapGroup{border:1px solid rgba(255,255,255,.08); border-radius:14px; overflow:hidden; background:rgba(255,255,255,.02)}
  .mapHeader{display:flex; align-items:center; gap:10px; padding:10px 12px; font-weight:800}
  .mapHeader .status{margin-left:auto}
  .board{display:grid; grid-template-columns: repeat(10, 1fr); gap:10px; padding:12px; user-select:none}
  .cell{
    aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; border-radius:14px;
    background:#0f1930; position:relative; overflow:hidden; font-weight:900; border:1px solid rgba(255,255,255,.10);
    font-size:1.15rem; letter-spacing:.3px;
  }
  .cell.readonly{cursor:default}
  .g1{background:linear-gradient(180deg, rgba(79,131,255,.24), transparent 55%), #0f1930}
  .g2{background:linear-gradient(180deg, rgba(34,197,94,.24), transparent 55%), #0f1930}
  .g3{background:linear-gradient(180deg, rgba(168,85,247,.26), transparent 55%), #0f1930}
  .g4{background:linear-gradient(180deg, rgba(245,158,11,.26), transparent 55%), #0f1930}
  .g5{background:linear-gradient(180deg, rgba(239,68,68,.26), transparent 55%), #0f1930}
  .g6{background:linear-gradient(180deg, rgba(6,182,212,.26), transparent 55%), #0f1930}
  .g7{background:linear-gradient(180deg, rgba(192,132,252,.26), transparent 55%), #0f1930}

  /* Results */
  .resTable{width:100%; border-collapse:collapse; font-size:.95rem}
  .resTable th, .resTable td{border-bottom:1px solid rgba(255,255,255,.08); padding:10px 6px; text-align:left; vertical-align:middle}
  .combo{display:flex; gap:6px; flex-wrap:nowrap; overflow-x:auto; padding:2px 0}
  .pill{padding:3px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:#101a2f; font-family:ui-monospace,Consolas,Menlo,monospace; font-weight:800}
  .nowrap{white-space:nowrap}
</style>
</head>
<body>
<header>
  <h1>KENO Tool – ZIP speichern (IndexedDB) • Read‑only Map (v10)</h1>
  <div class="sub">ZIP/CSV/TXT Import • Archiv speichert zuverlässig in IndexedDB • Map ist nur Anzeige (kein Antippen)</div>
</header>

<main>
  <!-- Archiv -->
  <section class="card col-span-2">
    <h2>1) Archiv</h2>
    <div class="controls">
      <input id="fileInput" type="file" accept=".zip,.csv,.txt" />
      <a class="btn warn" href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">ZIP-Seite öffnen</a>
      <button class="btn" id="btnClear">Archiv löschen</button>
      <button class="btn" id="btnExportArc">Archiv exportieren</button>
      <input id="importArc" type="file" accept=".json" style="display:none">
      <button class="btn" id="btnImportArc">Archiv importieren</button>
      <span class="badge" id="bDraws">0 Ziehungen</span>
      <span class="badge" id="bRange">—</span>
      <span class="badge" id="bSaved">—</span>
    </div>
    <div class="small muted" id="saveHint">Archiv wird nach dem Laden automatisch gespeichert.</div>
  </section>

  <!-- Gruppen -->
  <section class="card">
    <h2>2) Gruppen & Keno-Typ</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Keno-Typ&nbsp;<select id="kenoType"></select></label>
      <span class="badge" id="sumBadge">Summe: 0</span>
      <span class="badge" id="fitBadge">—</span>
      <button class="btn" id="btnResetQuotas">Quoten zurücksetzen</button>
    </div>
    <div id="groups"></div>
  </section>

  <!-- Map (read-only) -->
  <section class="card">
    <h2>3) Map (1–70)</h2>
    <div id="mapWrap" class="mapWrap"></div>
  </section>

  <!-- Generator -->
  <section class="card col-span-2">
    <h2>4) Generator</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Anzahl Ergebnisse&nbsp;<input id="genCount" type="number" min="1" max="2000" value="20" style="width:100px"></label>
      <button class="btn ok" id="btnGenerate">Generieren</button>
      <button class="btn" id="btnExport">CSV Export</button>
    </div>
    <table class="resTable" id="resTable">
      <thead><tr><th>#</th><th>Kombi</th><th class="nowrap">Aktion</th></tr></thead>
      <tbody id="resBody"></tbody>
    </table>
  </section>

  <!-- Tipp-Analyse -->
  <section class="card col-span-2">
    <h2>5) Tipp-Analyse</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Dein Tipp&nbsp;<input id="tipInput" type="text" placeholder="z. B. 5 12 18 19 33 44 55 66"></label>
      <label>Schwelle A (≥)&nbsp;<input id="thrA" type="number" min="1" max="20" value="7" style="width:80px"></label>
      <label>Schwelle B (≥)&nbsp;<input id="thrB" type="number" min="1" max="20" value="8" style="width:80px"></label>
      <label><input type="checkbox" id="autoThr" checked> automatisch an Keno-Typ koppeln</label>
      <button class="btn" id="btnAnalyze">Analysieren</button>
    </div>
    <div id="anaBox" class="badge" style="display:none; background:#0d162d"></div>
  </section>
</main>

<script>
/* ===== IndexedDB helper ===== */
const DB_NAME='keno_db_v1', STORE='kv';
function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME,1);
    req.onupgradeneeded = ()=>{ const db=req.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE); };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbSet(key, value){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite'); const st = tx.objectStore(STORE);
    st.put(value, key);
    tx.oncomplete = ()=> resolve();
    tx.onerror = ()=> reject(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const req=st.get(key);
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbDel(key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(STORE,'readwrite'); const st=tx.objectStore(STORE); st.delete(key);
    tx.oncomplete = ()=> resolve();
    tx.onerror = ()=> reject(tx.error);
  });
}

/* ===== App state ===== */
const CACHE_KEY="archive"; // in IndexedDB
const state = {
  draws: [],            // {date:int yyyymmdd|null, numbers:number[]}
  freq: Array(71).fill(0),
  kenoType: 8,
  quotas: [0,0,0,0,0,0,0],
  results: []
};

const els = {
  bDraws: document.getElementById('bDraws'),
  bRange: document.getElementById('bRange'),
  bSaved: document.getElementById('bSaved'),
  saveHint: document.getElementById('saveHint'),
  groups: document.getElementById('groups'),
  kenoType: document.getElementById('kenoType'),
  mapWrap: document.getElementById('mapWrap'),
  resBody: document.getElementById('resBody'),
  sumBadge: document.getElementById('sumBadge'),
  fitBadge: document.getElementById('fitBadge'),
  tipInput: document.getElementById('tipInput'),
  thrA: document.getElementById('thrA'),
  thrB: document.getElementById('thrB'),
  autoThr: document.getElementById('autoThr'),
  anaBox: document.getElementById('anaBox'),
  fileInput: document.getElementById('fileInput'),
  importArc: document.getElementById('importArc'),
  btnImportArc: document.getElementById('btnImportArc'),
  btnExportArc: document.getElementById('btnExportArc'),
};

function ymd(d){
  if(!d) return null;
  const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0');
  return Number(`${y}${m}${dd}`);
}
function ymdStr(i){ if(!i) return '—'; const s=String(i); return `${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6,8)}`; }
function groupIndex(n){ return Math.ceil(n/10)-1 }
function groupRange(i){ return `${i*10+1}–${i*10+10}` }
const gClass = i => ['g1','g2','g3','g4','g5','g6','g7'][i];

/* ===== Persistenz Archiv (IndexedDB) ===== */
async function saveArchive(){
  const payload={draws: state.draws, savedAt: Date.now()};
  try{
    await idbSet(CACHE_KEY, payload);
    els.bSaved.textContent = 'gespeichert: '+new Date(payload.savedAt).toLocaleString();
    els.saveHint.textContent = 'Archiv wurde in IndexedDB gespeichert (bleibt erhalten).';
  }catch(e){
    els.bSaved.textContent='Speichern fehlgeschlagen';
    els.saveHint.textContent='IndexedDB blockiert? Prüfe Browser/Privatmodus.';
  }
}
async function loadArchive(){
  try{
    const payload = await idbGet(CACHE_KEY);
    if(!payload){ els.bSaved.textContent='kein gespeichertes Archiv'; return; }
    state.draws = Array.isArray(payload.draws) ? payload.draws : [];
    recomputeStats();
    els.bSaved.textContent = payload.savedAt ? ('gespeichert: '+new Date(payload.savedAt).toLocaleString()) : 'geladen';
    els.saveHint.textContent = 'Archiv aus IndexedDB geladen.';
  }catch(e){
    els.bSaved.textContent='Laden fehlgeschlagen';
  }
}
async function clearArchive(){
  try{ await idbDel(CACHE_KEY); }catch{}
  state.draws=[]; state.freq=Array(71).fill(0);
  els.bDraws.textContent='0 Ziehungen'; els.bRange.textContent='—'; els.bSaved.textContent='—';
  els.saveHint.textContent='';
}

/* ===== Export/Import JSON ===== */
function exportArchiveJSON(){
  const payload={draws: state.draws, exportedAt: Date.now()};
  const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='keno_archiv.json'; a.click(); URL.revokeObjectURL(a.href);
}
async function importArchiveJSON(file){
  const text = await file.text();
  try{
    const obj = JSON.parse(text);
    if(!Array.isArray(obj.draws)) throw new Error('Invalid');
    state.draws = obj.draws;
    recomputeStats();
    await saveArchive();
  }catch(e){
    alert('Import fehlgeschlagen. Ungültige Datei.');
  }
}

/* ===== Datei laden & parsen ===== */
function parseRowToNumbers(row){
  const nums=[]; for(const cell of row){ const ints=String(cell).match(/\d+/g)||[]; for(const t of ints){ const v=Number(t); if(v>=1&&v<=70) nums.push(v); } }
  const seen=new Set(); const out=[]; for(const n of nums){ if(!seen.has(n)){ seen.add(n); out.push(n); if(out.length>=20) break; } } return out;
}
function looksLikeDate(s){
  const a=s.match(/^(\d{4})[-/.](\d{1,2})[-/.](\d{1,2})$/); if(a){ const d=new Date(+a[1],+a[2]-1,+a[3]); return isFinite(d)?d:null; }
  const b=s.match(/^(\d{1,2})[.](\d{1,2})[.](\d{4})$/); if(b){ const d=new Date(+b[3],+b[2]-1,+b[1]); return isFinite(d)?d:null; }
  return null;
}
async function parseTextFile(name, text){
  if(/(?:\bplus\b|\+5)/i.test(name)) return {draws:[]};
  let parsed = Papa.parse(text.trim());
  if(!parsed.data || parsed.data.length<1) parsed={data: text.split(/\r?\n/).map(l=>l.split(/[;,\t ]+/))};
  const result=[];
  for(const row of parsed.data){
    if(!row||row.length===0) continue;
    const nums = parseRowToNumbers(row);
    if(nums.length>=10){
      const dateCell=row.find(c=>looksLikeDate(String(c))); const d = dateCell?looksLikeDate(String(dateCell)):null;
      result.push({date: d? ymd(d): null, numbers: nums});
    }
  }
  return {draws: result};
}
async function handleZipOrTextFile(file){
  const name = file.name.toLowerCase();
  if(name.endsWith('.zip')){
    const ab=await file.arrayBuffer();
    const zip=await JSZip.loadAsync(ab);
    const all=[];
    for(const path of Object.keys(zip.files)){
      const f=zip.files[path]; if(f.dir) continue;
      const lower=path.toLowerCase();
      if(!/\.(csv|txt)$/i.test(lower)) continue;
      if(/(?:\bplus\b|\+5)/i.test(lower)) continue;
      const txt = await f.async('string');
      const {draws} = await parseTextFile(path, txt);
      all.push(...draws);
    }
    applyDraws(all);
  }else{
    const txt=await file.text();
    const {draws} = await parseTextFile(name, txt);
    applyDraws(draws);
  }
}
function applyDraws(draws){
  // dedupe by date+numbers
  const key = d => (d.date||'') + '|' + d.numbers.slice().sort((a,b)=>a-b).join('-');
  const dedup=new Map(); for(const d of draws) dedup.set(key(d), d);
  state.draws = [...dedup.values()].sort((a,b)=> (a.date||0) - (b.date||0));
  recomputeStats();
  saveArchive();
}
function recomputeStats(){
  state.freq = Array(71).fill(0);
  for(const d of state.draws){ for(const n of d.numbers){ state.freq[n]++; } }
  if(state.draws.length){
    const ds = state.draws.map(d=>d.date).filter(Boolean).sort((a,b)=>a-b);
    els.bRange.textContent = `${ymdStr(ds[0])} – ${ymdStr(ds[ds.length-1])}`;
  } else { els.bRange.textContent = '—'; }
  els.bDraws.textContent = `${state.draws.length.toLocaleString('de-DE')} Ziehungen`;
  renderMap();
}

/* ===== Gruppen & Map (READ-ONLY) ===== */
function buildKenoType(){
  els.kenoType.innerHTML='';
  for(let k=2;k<=10;k++){
    const o=document.createElement('option'); o.value=k; o.textContent=k; if(k===state.kenoType) o.selected=true;
    els.kenoType.appendChild(o);
  }
  els.kenoType.addEventListener('change', e=>{
    state.kenoType = Number(e.target.value);
    if(els.autoThr.checked){
      els.thrA.value = Math.max(1, state.kenoType-1);
      els.thrB.value = state.kenoType;
    }
    updateSumBadge(); renderMap();
  });
}
function renderGroups(){
  els.groups.innerHTML='';
  for(let i=0;i<7;i++){
    const row=document.createElement('div'); row.className='groupBar';
    row.innerHTML = `
      <span class="dot" style="width:12px;height:12px;border-radius:50%;background:var(--${gClass(i)})"></span>
      <strong>${groupRange(i)}</strong>
      <span class="badge" id="st${i}">${state.quotas[i]===0?'GESCHLOSSEN':'offen'}</span>
      <div class="qtyCtl">
        <button class="qtyBtn" data-i="${i}" data-act="dec">−</button>
        <div class="qty" id="q${i}">${state.quotas[i]}</div>
        <button class="qtyBtn" data-i="${i}" data-act="inc">+</button>
      </div>
      <span class="badge" id="rem${i}">—</span>`;
    els.groups.appendChild(row);
  }
  els.groups.querySelectorAll('.qtyBtn').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const i=Number(e.currentTarget.getAttribute('data-i'));
      const act=e.currentTarget.getAttribute('data-act');
      const cur=state.quotas[i];
      const next=Math.max(0, Math.min(10, act==='inc'?cur+1:cur-1));
      if(next===cur) return;
      state.quotas[i]=next;
      document.getElementById('q'+i).textContent=next;
      document.getElementById('st'+i).textContent= next===0?'GESCHLOSSEN':'offen';
      updateSumBadge();
      renderMap();
    });
  });
  updateSumBadge();
}
function buildMap(){
  els.mapWrap.innerHTML='';
  for(let i=0;i<7;i++){
    const box=document.createElement('div'); box.className='mapGroup';
    box.innerHTML = `<div class="mapHeader" style="background:linear-gradient(90deg, var(--${gClass(i)}) 0%, transparent 60%)">
        <span>${groupRange(i)}</span>
        <span class="badge status" id="mst${i}">${state.quotas[i]===0?'GESCHLOSSEN':'offen'}</span>
      </div>
      <div class="board" id="grid${i}"></div>`;
    els.mapWrap.appendChild(box);
    const grid=box.querySelector('#grid'+i);
    for(let n=i*10+1; n<=i*10+10; n++){
      const cell=document.createElement('div');
      cell.className=`cell readonly ${gClass(i)}`;
      cell.dataset.n=n;
      cell.textContent=n;
      grid.appendChild(cell);
    }
  }
  renderMap();
}
function renderMap(){
  for(let i=0;i<7;i++){
    document.getElementById('mst'+i).textContent = state.quotas[i]===0 ? 'GESCHLOSSEN' : 'offen';
  }
  // READ-ONLY: just style closed groups dimmer
  for(const cell of document.querySelectorAll('.board .cell')){
    const n=Number(cell.dataset.n || cell.textContent);
    const gi=groupIndex(n);
    const closed = state.quotas[gi]===0;
    cell.style.opacity = closed ? .45 : 1;
  }
}
function updateSumBadge(){
  const sum=state.quotas.reduce((a,b)=>a+b,0);
  els.sumBadge.textContent=`Summe: ${sum}`;
  els.fitBadge.textContent = sum===state.kenoType ? 'passt' : `(${sum}/${state.kenoType})`;
}

/* ===== Generator ===== */
function sample(pool){ const i=Math.floor(Math.random()*pool.length); return pool.splice(i,1)[0]; }
function generateOne(){
  const nums=[];
  for(let gi=0; gi<7; gi++){
    const need=state.quotas[gi]; if(need===0) continue;
    const start=gi*10+1, end=gi*10+10;
    const pool=[]; for(let n=start;n<=end;n++) if(!nums.includes(n)) pool.push(n);
    for(let k=0;k<need;k++){ if(!pool.length) break; nums.push(sample(pool)); }
  }
  return nums.sort((a,b)=>a-b);
}
function generate(){
  const count = Math.max(1, Math.min(2000, Number(document.getElementById('genCount').value)||20));
  const sum = state.quotas.reduce((a,b)=>a+b,0);
  if(sum !== state.kenoType){ alert('Summe der Gruppen muss dem Keno-Typ entsprechen.'); return; }
  const out=[]; const seen=new Set();
  let attempts=0, maxAttempts=count*50;
  while(out.length<count && attempts<maxAttempts){
    attempts++;
    const nums=generateOne();
    const key=nums.join('-');
    if(seen.has(key)) continue;
    seen.add(key); out.push(nums);
  }
  state.results=out;
  renderResults();
}
function renderResults(){
  const tb=document.getElementById('resBody'); tb.innerHTML='';
  state.results.forEach((arr,i)=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`
      <td>${i+1}</td>
      <td><div class="combo">${arr.map(n=>`<span class="pill">${n}</span>`).join('')}</div></td>
      <td class="nowrap">
        <button class="btn small" data-act="copy" data-i="${i}">Kopieren</button>
        <button class="btn small" data-act="ana" data-i="${i}">Analysieren</button>
      </td>`;
    tb.appendChild(tr);
  });
  tb.querySelectorAll('button').forEach(b=>{
    const i=Number(b.getAttribute('data-i')); const act=b.getAttribute('data-act');
    b.addEventListener('click', ()=>{
      const arr=state.results[i]; if(!arr) return;
      if(act==='copy'){ navigator.clipboard.writeText(arr.join(' ')); b.textContent='Kopiert'; setTimeout(()=>b.textContent='Kopieren',800); }
      if(act==='ana'){ els.tipInput.value=arr.join(' '); analyzeTip(); }
    });
  });
}
function exportCSV(){
  const rows=[['#','Kombi']];
  state.results.forEach((arr,i)=> rows.push([i+1, arr.join(' ')]));
  const csv = rows.map(r=>r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(';')).join('\n');
  const blob=new Blob([csv], {type:'text/csv;charset=utf-8'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='keno_ergebnisse.csv'; a.click(); URL.revokeObjectURL(a.href);
}

/* ===== Tipp-Analyse (gegen Archiv) ===== */
function analyzeTip(){
  if(!state.draws.length){ alert('Bitte zuerst ein Archiv laden (ZIP/CSV/TXT).'); return; }
  const raw=String(els.tipInput.value||'').trim();
  const nums=(raw.match(/\d+/g)||[]).map(x=>+x).filter(n=>n>=1&&n<=70);
  const tip=[...new Set(nums)].sort((a,b)=>a-b);
  if(!tip.length){ alert('Kein gültiger Tipp'); return; }
  if(els.autoThr.checked){
    els.thrA.value = Math.max(1, state.kenoType-1);
    els.thrB.value = state.kenoType;
  }
  const thrA=Math.max(1, Math.min(20, +els.thrA.value||state.kenoType-1));
  const thrB=Math.max(1, Math.min(20, +els.thrB.value||state.kenoType));

  let maxOv=0, cA=0, cB=0, cFull=0;
  for(const d of state.draws){
    let i=0,j=0,ov=0; const arr=d.numbers;
    // two-pointer merge on sorted arrays
    const a=tip, b=arr.slice().sort((x,y)=>x-y);
    while(i<a.length && j<b.length){
      if(a[i]===b[j]){ ov++; i++; j++; }
      else if(a[i]<b[j]) i++; else j++;
    }
    if(ov>maxOv) maxOv=ov;
    if(ov>=thrA) cA++;
    if(ov>=thrB) cB++;
    if(ov===tip.length) cFull++;
  }
  els.anaBox.style.display='';
  els.anaBox.innerHTML = [
    `<strong>Tipp:</strong> ${tip.join(' ')}`,
    `S=${tip.length}`,
    `Archiv: ${state.draws.length} Ziehungen`,
    `Max. Überschneidung im Archiv: <strong>${maxOv}</strong>`,
    `Ziehungen mit ≥${thrA}: <strong>${cA}</strong>`,
    `Ziehungen mit ≥${thrB}: <strong>${cB}</strong>`,
    `Komplett enthalten: <strong>${cFull?('Ja ('+cFull+'×)'):'Nein'}</strong>`
  ].join(' &nbsp; • &nbsp; ');
}

/* ===== Events ===== */
document.getElementById('fileInput').addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  await handleZipOrTextFile(f);
});
document.getElementById('btnClear').addEventListener('click', ()=>{ if(confirm('Archiv wirklich löschen?')) clearArchive(); });
document.getElementById('btnResetQuotas').addEventListener('click', ()=>{ state.quotas=[0,0,0,0,0,0,0]; renderGroups(); buildMap(); updateSumBadge(); });
document.getElementById('btnGenerate').addEventListener('click', generate);
document.getElementById('btnExport').addEventListener('click', exportCSV);
document.getElementById('btnAnalyze').addEventListener('click', analyzeTip);

els.btnExportArc.addEventListener('click', exportArchiveJSON);
els.btnImportArc.addEventListener('click', ()=> els.importArc.click());
els.importArc.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(f) await importArchiveJSON(f); });

/* ===== Init ===== */
(async function init(){
  buildKenoType(); renderGroups(); buildMap(); updateSumBadge();
  await loadArchive();
})();
</script>
</body>
</html>
