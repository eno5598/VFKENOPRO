<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO Ultra++ ‚Äî Archiv ‚Ä¢ Range ‚Ä¢ Gruppen ‚Ä¢ Generator ‚Ä¢ Analyse</title>
<style>
  :root{
    --bg:#080717; --panel:#111327; --border:#242949; --muted:#2b2f51;
    --text:#e7e9f3; --accent:#22c55e; --accent2:#7c8ffb; --danger:#ef4444;
    --pulse1:#6b46c1; --pulse2:#8b5cf6; --pulse3:#a78bfa;
  }
  *{box-sizing:border-box}
  /* sanfter lila Pulse (statt Strobo) */
  @keyframes bgPulse {
    0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%}
  }
  @keyframes panelPulse {
    0%,100%{box-shadow:0 0 0 rgba(167,139,250,0)}
    50%{box-shadow:0 0 32px rgba(167,139,250,.15)}
  }
  body{
    margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--text);
    background:
      radial-gradient(1200px 600px at 50% -20%, rgba(124,143,251,.10), transparent 60%),
      radial-gradient(800px 400px at 80% 120%, rgba(167,139,250,.08), transparent 60%),
      linear-gradient(120deg, #0b0a18 0%, #0a0a1a 40%, #0b0a18 60%),
      linear-gradient(135deg, var(--pulse1), var(--pulse2), var(--pulse3));
    background-size:auto,auto,auto,400% 400%;
    animation:bgPulse 24s ease infinite;
  }
  body.running .panel{animation:panelPulse 1.8s ease-in-out infinite}

  .box{max-width:1260px;margin:0 auto}
  .panel{
    background:linear-gradient(180deg,#12142d,#0e1130);
    border:1px solid var(--border);border-radius:14px;padding:14px;margin:12px 0 0;
    box-shadow:0 8px 22px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);
  }
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .row{display:flex;flex-wrap:wrap;gap:12px}
  .col{flex:1 1 220px;min-width:220px}
  label{display:block;margin:4px 0 6px;font-size:14px;opacity:.9}
  input,select,button{font:inherit}
  input,select{width:100%;padding:10px;border-radius:10px;border:1px solid var(--muted);background:#0b0f2a;color:var(--text);outline:none}
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700;transition:transform .05s}
  button:active{transform:translateY(1px)}
  .primary{background:linear-gradient(135deg,#22c55e,#34d399);color:#062410}
  .secondary{background:#1b2144;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .ghost{background:transparent;border:1px dashed var(--muted);color:var(--text)}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:#0b0f2a;border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  progress{width:100%;height:14px;border-radius:8px;overflow:hidden;background:#0b0f2a;border:1px solid var(--muted)}
  progress::-webkit-progress-value{background:#22c55e}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .fc-line{border:1px solid var(--muted);border-radius:10px;padding:8px;margin-bottom:6px;background:#0b0f2a}
  .badge{display:inline-block;padding:2px 6px;border-radius:999px;background:#0b0f2a;border:1px solid var(--muted);margin-left:6px;font-size:12px}
  .pill{padding:2px 8px;border:1px solid var(--muted);border-radius:999px;font-size:12px}
  .small{font-size:12px;opacity:.9}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px}

  .mapWrap{display:flex;gap:16px;flex-wrap:wrap}
  .mapPanel{flex:1 1 520px;min-width:320px}
  canvas{width:100%;height:auto;background:#0b1226;border:1px solid var(--muted);border-radius:12px;box-shadow:inset 0 0 30px rgba(0,0,0,.5)}
</style>
</head>
<body>
<div class="box">

  <!-- 1) ARCHIV -->
  <div class="panel">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv</h2></div>
    <div class="row">
      <div class="col" style="flex:2 1 420px">
        <input type="file" id="file" accept=".csv,.txt,.zip,.json">
        <div class="small" style="margin-top:6px">
          Offizielles ZIP: <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="btnExportCSV" class="ghost" disabled>CSV exportieren</button>
          <button id="btnExportSnap" class="ghost" disabled>Snapshot (.json)</button>
          <button id="btnClearArch" class="secondary">Archiv l√∂schen</button>
        </div>
      </div>
      <div class="col">
        <label>Anzahl Zahlen (S)</label>
        <select id="pickSize">
          <option>2</option><option>3</option><option>4</option><option>5</option>
          <option selected>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
        </select>
        <label style="margin-top:10px">Rechenstufe</label>
        <select id="computeMode">
          <option value="normal">normal</option>
          <option value="medium">mittel</option>
          <option value="hard">hard</option>
          <option value="ultra" selected>Ultra++</option>
        </select>
        <label style="margin-top:10px">Laufzeit</label>
        <select id="timeCap">
          <option value="15">‚âà 15s</option>
          <option value="60" selected>‚âà 1 min</option>
          <option value="180">‚âà 3 min</option>
          <option value="0">Max (nur Iterationslimit)</option>
        </select>
      </div>
      <div class="col">
        <label>Range (min‚Äìmax)</label>
        <div class="row">
          <input id="minVal" type="number" min="1" max="70" value="1">
          <input id="maxVal" type="number" min="1" max="70" value="70">
        </div>
        <div class="small">z. B. 4‚Äì67</div>
        <div id="persistInfo" class="small" style="margin-top:8px;opacity:.85">Persistenz: ‚Ä¶</div>
      </div>
    </div>
    <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
  </div>

  <!-- 2) MAP -->
  <div class="panel">
    <div class="ph"><span class="emoji">üó∫Ô∏è</span><h2 style="margin:0">Map 1‚Äì70</h2></div>
    <div class="mapWrap">
      <div class="mapPanel">
        <canvas id="map" width="880" height="560"></canvas>
        <div class="small">10 Spalten √ó 7 Reihen. Highlights = Top-Ergebnisse/Analysen.</div>
      </div>
      <div class="col">
        <div id="legend" class="grid"></div>
      </div>
    </div>
  </div>

  <!-- 3) GRUPPEN -->
  <div class="panel">
    <div class="ph"><span class="emoji">üéØ</span><h2 style="margin:0">Gruppen & Zielverteilung</h2></div>
    <div class="row">
      <div class="col">
        <label>Gruppen-Modus</label>
        <select id="groupMode">
          <option value="7" selected>7er (1‚Äì10,11‚Äì20,...,61‚Äì70)</option>
          <option value="5">5er (1‚Äì14,15‚Äì28,29‚Äì42,43‚Äì56,57‚Äì70)</option>
          <option value="3">3er (1‚Äì23,24‚Äì47,48‚Äì70)</option>
        </select>
      </div>
      <div class="col">
        <label>Scoring-Optionen</label>
        <div class="row">
          <label class="small"><input type="checkbox" id="preferPairs" checked> Paare</label>
          <label class="small"><input type="checkbox" id="preferTriples"> Triples</label>
          <label class="small"><input type="checkbox" id="preferGaps" checked> Abst√§nde</label>
        </div>
      </div>
      <div class="col" style="flex:2 1 420px;display:flex;align-items:flex-end;gap:8px">
        <button id="autoEven" class="secondary">Gleich verteilen</button>
        <button id="autoByArchive" class="secondary">Nach Archiv</button>
        <span class="pill" id="sumInfo">Summe: 0 / S</span>
      </div>
    </div>
    <div id="groupCounts" class="grid" style="margin-top:8px"></div>
    <div id="groupStatus" class="status">Gruppen initialisiert.</div>
  </div>

  <!-- 4) GENERATOR -->
  <div class="panel">
    <div class="ph"><span class="emoji">üßÆ</span><h2 style="margin:0">Generator</h2></div>
    <div class="row" style="margin-bottom:8px">
      <div class="col">
        <label>Wie viele Kombinationen ausgeben?</label>
        <select id="outCount">
          <option>1</option><option>2</option><option>3</option><option selected>4</option>
          <option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
        </select>
      </div>
      <div class="col" style="display:flex;align-items:flex-end;gap:8px">
        <button id="start" class="primary" disabled>Start</button>
        <button id="stop" class="danger" disabled>Stopp</button>
        <button id="clearResults" class="ghost">Ergebnisse l√∂schen</button>
        <span class="pill" id="liveInfo">idle</span>
      </div>
    </div>
    <progress id="prog" value="0" max="1" style="display:none"></progress>
    <div id="status" class="status">bereit</div>
    <div id="results" class="results"></div>
  </div>

  <!-- 5) VARIANTEN-ANALYSE -->
  <div class="panel">
    <div class="ph"><span class="emoji">üîç</span><h2 style="margin:0">Variante analysieren (Vorkommen & Abst√§nde)</h2></div>
    <div class="row">
      <div class="col" style="flex:2 1 420px">
        <input type="text" id="variantInput" placeholder="z. B. 4 17 23 31 44 56">
      </div>
      <div class="col" style="display:flex;align-items:flex-end;gap:8px">
        <button id="btnAnalyzeVariant" class="secondary">Analysieren</button>
      </div>
    </div>
    <div id="variantOut" class="results"></div>
  </div>

  <!-- 6) GLOBAL: Abstands-Analyse -->
  <div class="panel">
    <div class="ph"><span class="emoji">üìä</span><h2 style="margin:0">Abstands-Analyse (Archiv)</h2></div>
    <div class="row">
      <div class="col">
        <label>Zeige Top-Abst√§nde (1‚Äì69)</label>
        <select id="topGapsN">
          <option>10</option><option selected>20</option><option>30</option><option>40</option><option>69</option>
        </select>
      </div>
      <div class="col" style="display:flex;align-items:flex-end">
        <button id="runGapAnalysis" class="secondary">Abst√§nde berechnen</button>
      </div>
    </div>
    <div id="gapOut" class="results"></div>
  </div>

</div>

<!-- ==== TEIL 2 direkt hier unten einf√ºgen ==== -->
</body>
</html>
<script>
(function(){
"use strict";

/* Helpers */
const $=s=>document.querySelector(s);
const text=(el,s)=>{ if(el) el.textContent=s; };
const html=(el,s)=>{ if(el) el.innerHTML=s; };
const fmt=n=>(n||0).toLocaleString("de-DE");
const uniqSorted=a=>Array.from(new Set(a)).sort((x,y)=>x-y);

/* Persist Keys */
const LSK_ARCH="keno_ultra_arch_db_v3";
const LSK_RESULTS="keno_ultra_results_v3";

/* State */
let g_draws=[], g_dates=[], g_drawSize=0;
let g_groups=[], g_counts=[];
let worker=null;
let lastList=[];
let globalGapHist = Array(70).fill(0); // 1..69 benutzt

/* IndexedDB persist */
let db=null, persistMode="localStorage";
function idbOpen(){return new Promise((res,rej)=>{const req=indexedDB.open("kenoUltraDB",3);req.onupgradeneeded=()=>{const d=req.result;if(!d.objectStoreNames.contains("archive")) d.createObjectStore("archive");};req.onsuccess=()=>res(req.result);req.onerror=()=>rej(req.error||new Error("IDB open failed"));});}
async function saveArchiveIDB(obj){
  try{ if(!db) db=await idbOpen(); const tx=db.transaction("archive","readwrite"); tx.objectStore("archive").put(obj,"main"); await new Promise((r,j)=>{tx.oncomplete=r;tx.onerror=()=>j(tx.error)}); persistMode="IndexedDB"; }
  catch{ localStorage.setItem(LSK_ARCH, JSON.stringify(obj)); persistMode="localStorage"; }
  text($("#persistInfo"), "Persistenz: "+persistMode);
}
async function loadArchiveIDB(){
  try{ if(!db) db=await idbOpen(); const tx=db.transaction("archive","readonly"); const req=tx.objectStore("archive").get("main");
    const val=await new Promise((r,j)=>{req.onsuccess=()=>r(req.result); req.onerror=()=>j(req.error); tx.onerror=()=>j(tx.error);}); if(val) return val;
  }catch{}
  const raw=localStorage.getItem(LSK_ARCH); return raw? JSON.parse(raw): null;
}

/* Map / Legend */
const default7=[{from:1,to:10,color:"#3b82f6"},{from:11,to:20,color:"#22c55e"},{from:21,to:30,color:"#f59e0b"},{from:31,to:40,color:"#ef4444"},{from:41,to:50,color:"#a78bfa"},{from:51,to:60,color:"#14b8a6"},{from:61,to:70,color:"#eab308"}];
const default5=[{from:1,to:14,color:"#60a5fa"},{from:15,to:28,color:"#34d399"},{from:29,to:42,color:"#fbbf24"},{from:43,to:56,color:"#f87171"},{from:57,to:70,color:"#c084fc"}];
const default3=[{from:1,to:23,color:"#93c5fd"},{from:24,to:47,color:"#86efac"},{from:48,to:70,color:"#fde68a"}];

const map=$("#map"), ctx=map.getContext("2d");
function rgba(hex,a){const h=hex.replace("#","");const r=parseInt(h.slice(0,2),16),g=parseInt(h.slice(2,4),16),b=parseInt(h.slice(4,6),16);return `rgba(${r},${g},${b},${a})`;}
function cellRect(n){const col=(n-1)%10,row=Math.floor((n-1)/10);const pad=8,cw=(map.width-pad*2)/10,ch=(map.height-pad*2)/7;return{x:pad+col*cw,y:pad+row*ch,w:cw,h:ch};}
function drawMap(highlights){
  ctx.clearRect(0,0,map.width,map.height);
  for(const g of g_groups){ctx.fillStyle=rgba(g.color,0.18);for(let v=g.from;v<=g.to;v++){const r=cellRect(v);ctx.fillRect(r.x,r.y,r.w,r.h);}}
  ctx.strokeStyle="#223046";ctx.fillStyle="#dbeafe";ctx.textAlign="center";ctx.textBaseline="middle";ctx.font="14px ui-sans-serif,system-ui";
  for(let v=1;v<=70;v++){const r=cellRect(v);ctx.strokeRect(r.x,r.y,r.w,r.h);ctx.fillText(String(v), r.x+r.w/2, r.y+r.h/2);}
  if(Array.isArray(highlights)){
    for(const {num,weight} of highlights){
      const r=cellRect(num);
      ctx.beginPath();ctx.arc(r.x+r.w/2,r.y+r.h/2,Math.min(r.w,r.h)*0.38,0,Math.PI*2);
      ctx.fillStyle=rgba("#ffffff",0.08+0.12*(weight||0));ctx.fill();
      ctx.beginPath();ctx.arc(r.x+r.w/2,r.y+r.h/2,Math.min(r.w,r.h)*0.20,0,Math.PI*2);
      ctx.fillStyle="#e5e7eb";ctx.fill();ctx.strokeStyle="#00000055";ctx.stroke();
    }
  }
}
function buildLegend(){
  const L=$("#legend");
  html(L, g_groups.map((g,i)=>`<div class="fc-line"><b>G${i+1}</b> <span class="badge" style="background:${g.color};border-color:#0003;color:#0b1220"> </span> ${g.from}-${g.to}</div>`).join(""));
}

/* Gruppen UI */
function setGroupMode(mode){
  if(mode==="7") g_groups=JSON.parse(JSON.stringify(default7));
  else if(mode==="5") g_groups=JSON.parse(JSON.stringify(default5));
  else g_groups=JSON.parse(JSON.stringify(default3));
  buildLegend(); buildCountInputs(); drawMap(); text($("#groupStatus"),"Gruppen initialisiert.");
}
function buildCountInputs(){
  const S=parseInt($("#pickSize").value,10)||6;
  if(!g_counts || g_counts.length!==g_groups.length) g_counts=Array(g_groups.length).fill(0);
  const wrap=$("#groupCounts");
  html(wrap, g_groups.map((g,i)=>`
    <div class="panel" style="padding:8px">
      <div style="font-weight:700;margin-bottom:6px">G${i+1}: ${g.from}-${g.to}</div>
      <input type="number" min="0" max="${S}" step="1" value="${g_counts[i]||0}" data-idx="${i}" class="cntInp">
      <div class="small" style="margin-top:6px">Wieviele Zahlen aus dieser Gruppe?</div>
    </div>`).join(""));
  wrap.querySelectorAll(".cntInp").forEach(inp=> inp.addEventListener("input", onCountChange));
  updateSumInfo();
}
function onCountChange(e){
  const S=parseInt($("#pickSize").value,10)||6;
  const idx=+e.target.getAttribute("data-idx");
  let v=parseInt(e.target.value,10); if(!Number.isFinite(v)||v<0) v=0; if(v>S) v=S; g_counts[idx]=v; e.target.value=v;
  updateSumInfo();
}
function updateSumInfo(){
  const S=parseInt($("#pickSize").value,10)||6;
  const sum=(g_counts||[]).reduce((a,b)=>a+(b||0),0);
  text($("#sumInfo"),`Summe: ${sum} / ${S}`);
  $("#start").disabled = !(sum===S && g_draws.length>0);
}

/* Archiv laden/export (robust + Snapshot) */
function splitSmart(l){if(/\t/.test(l))return l.split("\t");if(l.includes(";"))return l.split(";");if(l.includes("|"))return l.split("|");if(/,/.test(l)&&!/^\d+(?:-\d+)+$/.test(l.trim()))return l.split(",");return l.trim().split(/\s+/);}
function parseTable(t){return t.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}
function tryZahlHeader(rows){
  if(!rows.length)return null; const header=rows[0].map(x=>String(x).trim()); const idx=[],dateIdx=[];
  for(let i=0;i<header.length;i++){ if(/^zahl\s*\d+$/i.test(header[i])) idx.push(i); if(/datum|date|ziehung|draw|tag/i.test(header[i])) dateIdx.push(i); }
  if(idx.length>=5){
    const lists=[],dates=[];
    for(let r=1;r<rows.length;r++){
      const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
      if(nums.length) lists.push(nums);
      dates.push(dateIdx.length? String(rows[r][dateIdx[0]]??"").trim() : "");
    }
    return {lists,dates,info:`Header erkannt (${idx.length} Zahl-Spalten${dateIdx.length?"+Datum":""})`};
  }
  return null;
}
function detectDashCol(rows){
  let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
  let best=-1,score=-1;
  for(let c=0;c<maxCols;c++){
    let sc=0;
    for(const r of rows){
      if(c>=r.length) continue;
      const cell=String(r[c]??"").trim(); if(!cell) continue;
      const parts=cell.split("-");
      if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
    }
    if(sc>score){score=sc;best=c;}
  }
  return best;
}
function fallbackExtract(raw){
  const out=[],dates=[];
  for(const lnRaw of raw.split(/\r?\n/)){
    const ln=lnRaw.trim(); if(!ln) continue;
    if(/^\d+(?:-\d+)+$/.test(ln)){ out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); dates.push(""); continue; }
    const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    if(nums.length>=5){ out.push(nums); dates.push(""); }
  }
  return {lists:out,dates};
}
async function ensureJSZip(){
  if(window.JSZip) return;
  await new Promise((res,rej)=>{const s=document.createElement("script");s.src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";s.onload=res;s.onerror=()=>rej(new Error("JSZip laden fehlgeschlagen"));document.head.appendChild(s);});
}
async function handleAnyFile(file){
  if(!file){ text($("#statusTop"),"Keine Datei gew√§hlt."); return; }
  const name=(file.name||"").toLowerCase();
  text($("#statusTop"),`Lese Datei: ${file.name}`);
  try{
    if(name.endsWith(".json")){
      const obj=JSON.parse(await file.text());
      applyArchiveObject(obj,"Snapshot");
      return;
    }
    let raw="", sourceLabel="";
    if(name.endsWith(".zip")){
      await ensureJSZip();
      const ab=await file.arrayBuffer();
      const zip=await JSZip.loadAsync(ab);
      const candidates=[];
      zip.forEach((path, entry)=>{
        const p=path.toLowerCase();
        if(p.endsWith(".csv")||p.endsWith(".txt")){
          const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
          candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
        }
      });
      if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
      candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
      const target=candidates[0];
      sourceLabel=`ZIP: ${target.path}`;
      try{ raw=await target.entry.async("string"); }
      catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
      parseAndApply(raw, sourceLabel);
    }else{
      const txt=await file.text();
      parseAndApply(txt, file.name||"Upload");
    }
  }catch(e){
    text($("#statusTop"),"Fehler beim Lesen: "+(e?.message||e));
  }
}
function parseAndApply(raw, sourceLabel){
  const rows=parseTable(raw);
  let lists=[],dates=[],detected="";
  const h=tryZahlHeader(rows);
  if(h){ lists=h.lists; dates=h.dates; detected=h.info; }
  else{
    const ncol=detectDashCol(rows);
    if(ncol>=0){
      for(const r of rows){
        if(ncol>=r.length) continue;
        const cell=String(r[ncol]??"").trim(); if(!cell) continue;
        const parts=cell.split("-").map(s=>s.trim());
        if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
      }
      detected="Spalte 1-4-‚Ä¶";
    }else{
      const fb=fallbackExtract(raw); lists=fb.lists; dates=fb.dates; detected="Fallback";
    }
  }
  if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");
  const lenCount=new Map(); for(const a of lists){ if(a.length>=5 && a.length<=20) lenCount.set(a.length,(lenCount.get(a.length)||0)+1); }
  let bestLen=0,bestCnt=-1; for(const [k,v] of lenCount.entries()){ if(v>bestCnt){bestCnt=v;bestLen=k;} }
  if(!bestLen) throw new Error("Keine Listen 5‚Äì20 erkannt.");
  const draws=lists.filter(a=>a.length===bestLen).map(a=>uniqSorted(a.filter(Number.isInteger).filter(x=>x>=1&&x<=70)));
  const dts=dates && dates.length===lists.length ? dates.filter((_,i)=>lists[i].length===bestLen) : new Array(draws.length).fill("");
  applyArchiveObject({draws,dates:dts,drawSize:bestLen,savedAt:Date.now(),source:sourceLabel},"");
}
function applyArchiveObject(obj, detected=""){
  g_draws=obj.draws||[]; g_dates=(obj.dates||[]).map(x=>String(x||"")); g_drawSize=obj.drawSize||0;
  saveArchiveIDB({draws:g_draws,dates:g_dates,drawSize:g_drawSize,savedAt:Date.now(),source:obj.source||""});
  $("#btnExportCSV").disabled = g_draws.length===0;
  $("#btnExportSnap").disabled = g_draws.length===0;
  text($("#statusTop"),
    g_draws.length ? `Archiv geladen: ${fmt(g_draws.length)} Ziehungen (ZL ${g_drawSize}) ¬∑ Persistiert (${persistMode}).` : "Bereit. (Kein Archiv geladen)"
  );
  computeGlobalGaps(); updateSumInfo(); drawMap();
}
$("#file").addEventListener("change",()=> handleAnyFile($("#file").files[0]));
$("#btnExportCSV").addEventListener("click", ()=>{
  if(!g_draws.length) return;
  const header="index,"+Array.from({length:g_drawSize},(_,i)=>"zahl"+(i+1)).join(",");
  const rows=g_draws.map((d,i)=>[i,...d].join(",")).join("\n");
  const a=document.createElement("a"); a.href=URL.createObjectURL(new Blob([header+"\n"+rows],{type:"text/csv;charset=utf-8"})); a.download="keno_normalisiert.csv"; a.click();
});
$("#btnExportSnap").addEventListener("click", ()=>{
  const snap={draws:g_draws,dates:g_dates,drawSize:g_drawSize,savedAt:Date.now(),source:"Snapshot"};
  const a=document.createElement("a"); a.href=URL.createObjectURL(new Blob([JSON.stringify(snap)],{type:"application/json"})); a.download="keno_archiv_snapshot.json"; a.click();
});
$("#btnClearArch").addEventListener("click", async ()=>{
  try{ localStorage.removeItem(LSK_ARCH);}catch{} 
  if(!db) try{ db=await idbOpen(); }catch{}
  if(db){ const tx=db.transaction("archive","readwrite"); tx.objectStore("archive").delete("main"); }
  g_draws=[]; g_dates=[]; g_drawSize=0;
  text($("#statusTop"),"Archiv gel√∂scht."); $("#btnExportCSV").disabled=true; $("#btnExportSnap").disabled=true;
  updateSumInfo(); drawMap();
});

/* Ergebnisse persist */
function saveResults(list){ try{ localStorage.setItem(LSK_RESULTS, JSON.stringify(list||[])); }catch{} }
function loadResults(){ try{ const raw=localStorage.getItem(LSK_RESULTS); if(raw){ const l=JSON.parse(raw)||[]; if(l.length){ lastList=l; renderList(lastList); updateHotspots(lastList); } } }catch{} }

/* GAPs global (f√ºr Range) */
function computeGlobalGaps(){
  globalGapHist = Array(70).fill(0);
  const minV=Math.max(1, Math.min(70, parseInt($("#minVal").value,10)||1));
  const maxV=Math.max(minV, Math.min(70, parseInt($("#maxVal").value,10)||70));
  for(const d of g_draws){
    const s=d.filter(v=>v>=minV&&v<=maxV).slice().sort((a,b)=>a-b);
    for(let i=1;i<s.length;i++){ const g=s[i]-s[i-1]; if(g>=1 && g<=69) globalGapHist[g]++; }
  }
}

/* Legend & Map */
function updateHotspots(list){
  const m=new Map();
  (list||[]).forEach((it,rank)=>{const w=1-(rank/Math.max(1,(list.length-1)||1)); it.k.split("-").map(Number).forEach(n=> m.set(n,Math.max(m.get(n)||0,w)));});
  drawMap(Array.from(m.entries()).map(([num,weight])=>({num,weight})));
}

/* Worker (harte Gruppen-Constraints) */
function buildWorker(){
  if(worker) try{worker.terminate();}catch{}
  const code=`
  let CFG=null, STATE=null, STOP=false;

  const inR=(v,a,b)=>v>=a&&v<=b;
  const gIdx=(v,groups)=>{ for(let i=0;i<groups.length;i++){ const g=groups[i]; if(v>=g.from&&v<=g.to) return i; } return -1; };

  function freq(draws,a,b){const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(inR(v,a,b)) f[v]++; return f;}
  function coPairs(draws,a,b){
    const M=Array.from({length:71},()=>Array(71).fill(0));
    for(const d of draws){
      const s=d.filter(v=>inR(v,a,b));
      for(let i=0;i<s.length;i++) for(let j=i+1;j<s.length;j++){ const x=s[i],y=s[j]; M[x][y]++; M[y][x]++; }
    }
    return M;
  }
  function coTriples(draws,a,b){
    const T=new Map();
    for(const d of draws){
      const s=d.filter(v=>inR(v,a,b)).sort((x,y)=>x-y);
      for(let i=0;i<s.length;i++) for(let j=i+1;j<s.length;j++) for(let k=j+1;k<s.length;k++){
        const key=s[i]+"-"+s[j]+"-"+s[k]; T.set(key,(T.get(key)||0)+1);
      }
    }
    return T;
  }
  function gapHist(draws,a,b){
    const H=Array(70).fill(0);
    for(const d of draws){
      const s=d.filter(v=>inR(v,a,b)).sort((x,y)=>x-y);
      for(let i=1;i<s.length;i++){ const g=s[i]-s[i-1]; if(g>=1&&g<=69) H[g]++; }
    }
    return H;
  }

  function makePool(groups,a,b){
    return groups.map(g=>{ const arr=[]; for(let v=Math.max(g.from,a); v<=Math.min(g.to,b); v++) arr.push(v); return arr; });
  }

  // Kandidat als Buckets pro Gruppe (halten Counts strikt ein)
  function buildCandidate(pool, counts){
    const used=new Uint8Array(71);
    const buckets=pool.map(()=>[]);
    for(let gi=0; gi<pool.length; gi++){
      const need=counts[gi]||0; const cand=pool[gi];
      for(let t=0; t<need; t++){
        // leichte Heuristik: w√§hle zuf√§llig, aber ohne Duplikate
        let v=null, tries=0;
        while(tries++<30){
          const pick=cand[Math.floor(Math.random()*cand.length)];
          if(!used[pick]){ v=pick; break; }
        }
        if(v==null){
          for(const pick of cand){ if(!used[pick]){ v=pick; break; } }
        }
        if(v==null){ // Pool ersch√∂pft -> fr√ºh abbrechen (invalid)
          return null;
        }
        used[v]=1; buckets[gi].push(v);
      }
    }
    return buckets;
  }
  function bucketsToArray(buckets){
    return Array.from(buckets.flat()).sort((a,b)=>a-b);
  }

  // Mutationen, die Counts/Gruppe ERHALTEN
  function mutate(buckets, pool){
    // deep copy
    const B = buckets.map(arr=>arr.slice());
    const gi = Math.floor(Math.random()*B.length);
    if(B[gi].length===0){ return B; }
    const used=new Uint8Array(71);
    for(const a of B) for(const v of a) used[v]=1;

    const r=Math.random();
    if(r<0.5){
      // Ersetze eine Zahl innerhalb derselben Gruppe
      const idx=Math.floor(Math.random()*B[gi].length);
      let pick=null, tries=0;
      while(tries++<40){
        const p=pool[gi][Math.floor(Math.random()*pool[gi].length)];
        if(!used[p]){ pick=p; break; }
      }
      if(pick!=null){
        used[B[gi][idx]]=0; B[gi][idx]=pick; used[pick]=1;
      }
    }else{
      // Tausche zwei Zahlen innerhalb derselben Gruppe (no-op auf Score, aber Durchmischen)
      if(B[gi].length>=2){
        const i=Math.floor(Math.random()*B[gi].length), j=Math.floor(Math.random()*B[gi].length);
        const tmp=B[gi][i]; B[gi][i]=B[gi][j]; B[gi][j]=tmp;
      }
    }
    return B;
  }

  function score(arr, ctx){
    const {baseF, pairM, triM, gapH, W} = ctx;
    let s=0;
    for(const v of arr) s += Math.log((baseF[v]||0.5)+1e-9)*W.base;
    for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++){
      const c=pairM[arr[i]][arr[j]]||0; s += Math.log(c+1e-6)*W.pair;
    }
    if(W.tri>0 && arr.length>=3){
      const a=arr.slice().sort((x,y)=>x-y);
      for(let i=0;i<a.length;i++) for(let j=i+1;j<a.length;j++) for(let k=j+1;k<a.length;k++){
        const c=triM.get(a[i]+"-"+a[j]+"-"+a[k])||0; s += Math.log(c+1e-6)*W.tri;
      }
    }
    if(W.gap>0 && arr.length>=2){
      const srt=arr.slice().sort((x,y)=>x-y);
      let gsum=0; for(let i=1;i<srt.length;i++){ const g=srt[i]-srt[i-1]; if(g>=1&&g<=69) gsum += Math.log((gapH[g]||0)+1e-6); }
      s += W.gap * (gsum/Math.max(1,srt.length-1));
    }
    return s;
  }

  function start(cfg){
    CFG=cfg; STOP=false;
    const {drawsAll, rangeMin, rangeMax, groups, counts, preferPairs, preferTriples, preferGaps, outCount, mode, timeCapSec} = CFG;
    const baseF=freq(drawsAll,rangeMin,rangeMax);
    const pairM=coPairs(drawsAll,rangeMin,rangeMax);
    const triM= preferTriples ? coTriples(drawsAll,rangeMin,rangeMax) : new Map();
    const gapH= preferGaps ? gapHist(drawsAll,rangeMin,rangeMax) : Array(70).fill(0);

    const MODES={
      normal:{iters:25_000,batches:1,W:{base:1.00,pair:preferPairs?0.45:0.15,tri:preferTriples?0.30:0,gap:preferGaps?0.35:0}},
      medium:{iters:95_000,batches:2,W:{base:1.05,pair:preferPairs?0.55:0.20,tri:preferTriples?0.40:0,gap:preferGaps?0.45:0}},
      hard:{iters:280_000,batches:3,W:{base:1.10,pair:preferPairs?0.65:0.25,tri:preferTriples?0.50:0,gap:preferGaps?0.55:0}},
      ultra:{iters:900_000,batches:6,W:{base:1.18,pair:preferPairs?0.78:0.32,tri:preferTriples?0.65:0,gap:preferGaps?0.70:0}}
    };
    const M=MODES[mode]||MODES.normal;

    const pool=makePool(groups,rangeMin,rangeMax);
    // Falls irgendein Gruppen-Pool kleiner als ben√∂tigte Count ist -> unm√∂glich
    for(let gi=0;gi<pool.length;gi++){ if((counts[gi]||0)>pool[gi].length){ postMessage({type:"done", list:[]}); return; } }

    let buckets = buildCandidate(pool, counts);
    if(!buckets){ postMessage({type:"done", list:[]}); return; }

    STATE={
      start:performance.now(), iter:0, best:new Map(),
      ctx:{baseF,pairM,triM,gapH,W:M.W},
      pool, counts, outCount, M, cap:timeCapSec||0
    };

    loop(buckets);
  }

  function loop(buckets){
    if(STOP) return finish();
    const {M, ctx, outCount, cap} = STATE;
    const chunk=5000;

    function step(b){
      for(let batch=0; batch<M.batches; batch++){
        for(let i=0;i<M.iters;i++){
          let candBuckets = mutate(b, STATE.pool);
          let a=bucketsToArray(candBuckets);
          let ca=bucketsToArray(b);
          if(score(a,ctx) > score(ca,ctx)) b=candBuckets; // hill climb
          const arr=bucketsToArray(b), k=arr.join("-");
          if(!STATE.best.has(k)) STATE.best.set(k, score(arr,ctx));
          STATE.iter++;
          if(STATE.iter%chunk===0){
            postMessage({type:"progress", iter:STATE.iter, elapsed:(performance.now()-STATE.start)/1000, list:topList(STATE, Math.max(outCount*4,20))});
            if(STOP) return finish();
            if(cap>0 && (performance.now()-STATE.start)/1000 >= cap) return finish();
            return setTimeout(()=>step(b),0);
          }
        }
        if(STOP) return finish();
        if(cap>0 && (performance.now()-STATE.start)/1000 >= cap) return finish();
      }
      finish();
    }
    step(buckets);
  }

  function finish(){
    postMessage({type:"done", list: topList(STATE, STATE.outCount)}); STATE=null;
  }
  function topList(STATE,n){
    return Array.from(STATE.best.entries()).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0])).slice(0,n)
      .map(([k,score],i,arr)=>({k,idx:+((score/((arr[0]?.[1]||1)))*100).toFixed(1),raw:+score.toFixed(3)}));
  }

  onmessage=e=>{ const m=e.data; if(m.cmd==="start") start(m.cfg); else if(m.cmd==="stop"){ STOP=true; postMessage({type:"stopped"});} };
  `;
  worker=new Worker(URL.createObjectURL(new Blob([code],{type:"application/javascript"})));
  worker.onmessage=onWorkerMsg;
  worker.onerror=e=>{ text($("#status"),"Worker-Fehler: "+(e.message||"unbekannt")); hardStop(); };
}

/* Worker Events */
function onWorkerMsg(ev){
  const m=ev.data;
  if(m.type==="progress"){
    $("#prog").style.display="";
    text($("#status"), `Iterationen: ${fmt(m.iter)} ¬∑ Zeit: ${m.elapsed.toFixed(1)}s ¬∑ Kandidaten: ${fmt(m.list.length)}`);
    lastList=m.list||[]; renderList(lastList); updateHotspots(lastList); saveResults(lastList);
  }else if(m.type==="done"){
    $("#prog").style.display="none";
    text($("#status"), `Fertig ¬∑ Kandidaten: ${fmt((m.list||[]).length)}`);
    lastList=m.list||[]; renderList(lastList); updateHotspots(lastList); saveResults(lastList); hardStop(false);
  }else if(m.type==="stopped"){
    hardStop();
  }
}

/* Generator UI */
function startSearch(){
  if(!g_draws.length) return alert("Bitte zuerst ein Archiv laden.");
  const S=parseInt($("#pickSize").value,10)||6;
  const counts=g_counts.slice();
  const sum=counts.reduce((a,b)=>a+(b||0),0);
  if(sum!==S) return alert("Summe der Gruppen-Counts muss S ergeben.");
  const minV=Math.max(1, Math.min(70, parseInt($("#minVal").value,10)||1));
  const maxV=Math.max(minV, Math.min(70, parseInt($("#maxVal").value,10)||70));

  buildWorker(); startUI();
  worker.postMessage({cmd:"start", cfg:{
    drawsAll:g_draws, rangeMin:minV, rangeMax:maxV,
    groups:g_groups, counts,
    preferPairs:$("#preferPairs").checked,
    preferTriples:$("#preferTriples").checked,
    preferGaps:$("#preferGaps").checked,
    outCount:parseInt($("#outCount").value,10)||4,
    mode: $("#computeMode").value,
    timeCapSec: parseInt($("#timeCap").value,10)||0
  }});
}
function stopSearch(){ if(worker){ worker.postMessage({cmd:"stop"}); hardStop(); } }
function startUI(){ $("#start").disabled=true; $("#stop").disabled=false; $("#prog").style.display=""; document.body.classList.add("running"); text($("#liveInfo"),"running"); }
function hardStop(){ try{ worker&&worker.terminate(); }catch{} worker=null; $("#start").disabled=false; $("#stop").disabled=true; $("#prog").style.display="none"; document.body.classList.remove("running"); text($("#liveInfo"),"idle"); }

/* Ergebnisse anzeigen (nur Index in Historie) */
function renderList(list){
  const out=(list||[]).map((it,i)=>{
    const arr=it.k.split("-").map(Number);
    const hits = variantOccurrences(arr);
    const last = hits.at(-1);
    const lbl = hits.length ? `${hits.length}√ó (letzte #${hits.at(-1).idx})` : "‚Äì";
    const gaps = arr.slice().sort((a,b)=>a-b).map((v,idx,a)=> idx? v-a[idx-1] : null).filter(x=>x!==null);
    const gapInfo = gaps.map(g=> `${g} (global ${globalGapHist[g]||0})`).join(", ");
    return `<div class="fc-line">
      <b>${i+1}. ${arr.join(" ")}</b>
      <span class="badge">Score: ${it.idx}</span>
      <span class="badge">Historie: ${lbl}</span>
      <div class="small" style="margin-top:4px">Abst√§nde in der Variante (S‚àí1): ${gapInfo||"‚Äî"}</div>
      <button class="secondary" data-analyze="${it.k}" style="margin-top:6px">Variante analysieren</button>
    </div>`;
  }).join("");
  html($("#results"), out || "<div class='fc-line'>(keine Kandidaten)</div>");
}

/* Varianten-Analyse (nur Indizes) */
function variantOccurrences(nums){
  const set=new Set(nums);
  const hits=[];
  for(let i=0;i<g_draws.length;i++){
    const d=g_draws[i]; let ok=true; for(const v of set){ if(!d.includes(v)){ ok=false; break; } }
    if(ok) hits.push({idx:i});
  }
  return hits;
}
function analyzeVariant(nums){
  if(!g_draws.length){ html($("#variantOut"), "<div class='fc-line'>Bitte Archiv laden.</div>"); return; }
  nums=uniqSorted((nums||[]).filter(n=>n>=1&&n<=70));
  if(!nums.length){ html($("#variantOut"), "<div class='fc-line'>Keine Zahlen erkannt.</div>"); return; }
  const hits=variantOccurrences(nums);
  const first=hits[0], last=hits.at(-1);
  const gapsIdx=[]; for(let i=1;i<hits.length;i++) gapsIdx.push(hits[i].idx - hits[i-1].idx);
  const srt=nums.slice().sort((a,b)=>a-b); const gapsNum=[]; for(let i=1;i<srt.length;i++) gapsNum.push(srt[i]-srt[i-1]);

  const lastN=hits.slice(-20);
  const table = lastN.length
    ? `<table style="width:100%;border-collapse:collapse">
         <thead><tr><th style="text-align:left;padding:6px;border-bottom:1px solid #334155">Index</th></tr></thead>
         <tbody>${ lastN.map(h=>`<tr><td style="padding:6px;border-bottom:1px solid #223046">#${h.idx}</td></tr>`).join("") }</tbody>
       </table>`
    : "<div class='small'>Keine Treffer im Archiv.</div>";

  const gapsNumTxt = gapsNum.length ? gapsNum.map(g=>`${g} (global ${globalGapHist[g]||0})`).join(", ") : "‚Äî";
  const gapsIdxTxt = gapsIdx.length ? gapsIdx.join(", ") : "‚Äî";

  html($("#variantOut"),
    `<div class="fc-line"><b>Variante:</b> ${nums.join(" ")}</div>
     <div class="fc-line">
       <b>Treffer gesamt:</b> ${fmt(hits.length)} ¬∑
       <b>Erster:</b> ${first?("#"+first.idx):"‚Äî"} ¬∑
       <b>Letzter:</b> ${last?("#"+last.idx):"‚Äî"}
     </div>
     <div class="fc-line"><b>Abst√§nde in der Variante (S‚àí1):</b> ${gapsNumTxt}</div>
     <div class="fc-line"><b>Abst√§nde zwischen Treffern (Index-Folge):</b> ${gapsIdxTxt}</div>
     <div class="fc-line"><b>Letzte ${lastN.length} Treffer</b>${table}</div>`
  );
  drawMap(nums.map(n=>({num:n,weight:1})));
}

/* Globale Abstands-Analyse */
function runGapAnalysis(){
  if(!g_draws.length){ html($("#gapOut"), "<div class='fc-line'>Bitte Archiv laden.</div>"); return; }
  computeGlobalGaps();
  const N=parseInt($("#topGapsN").value,10)||20;
  const arr=[]; for(let g=1;g<=69;g++) arr.push({g, c:globalGapHist[g]||0});
  arr.sort((a,b)=> b.c-a.c || a.g-b.g);
  const top=arr.slice(0,N).map(x=>`<div class="fc-line"><b>Gap ${x.g}</b><span class="badge">H√§ufigkeit: ${fmt(x.c)}</span></div>`).join("");
  const all=arr.map(x=>`${x.g}:${x.c}`).join("  ");
  html($("#gapOut"),
    (top || "<div class='fc-line'>(keine Daten)</div>") +
    `<div class="fc-line" style="margin-top:8px"><b>Alle 1‚Äì69 (kompakt):</b><br><span class="small">${all}</span></div>`
  );
}

/* Events */
$("#start").addEventListener("click", startSearch);
$("#stop").addEventListener("click", stopSearch);
$("#groupMode").addEventListener("change", ()=> setGroupMode($("#groupMode").value));
$("#pickSize").addEventListener("change", ()=> buildCountInputs());
$("#autoEven").addEventListener("click", ()=>{ const S=parseInt($("#pickSize").value,10)||6; g_counts=evenSplit(S,g_groups.length); buildCountInputs(); });
$("#autoByArchive").addEventListener("click", ()=>{
  if(!g_draws.length){ alert("Archiv zuerst laden."); return; }
  const S=parseInt($("#pickSize").value,10)||6;
  const shares = groupSharesFromArchive();
  g_counts = proportionalSplit(S, shares); buildCountInputs();
});
$("#results").addEventListener("click",(e)=>{
  const btn=e.target.closest("button[data-analyze]"); if(!btn) return;
  const arr=btn.getAttribute("data-analyze").split("-").map(Number);
  $("#variantInput").value=arr.join(" ");
  analyzeVariant(arr);
});
$("#btnAnalyzeVariant").addEventListener("click", ()=>{
  const raw=String($("#variantInput").value||"").trim();
  const arr=(raw.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(n=>Number.isInteger(n)&&n>=1&&n<=70);
  analyzeVariant(arr);
});
$("#runGapAnalysis").addEventListener("click", runGapAnalysis);

/* Helpers */
function evenSplit(S,G){ const arr=Array(G).fill(0); for(let i=0;i<S;i++) arr[i%G]++; return arr; }
function proportionalSplit(S, shares){ const raw=shares.map(x=>x*S), base=raw.map(Math.floor); let rest=S-base.reduce((a,b)=>a+b,0); const frac=raw.map((x,i)=>({i,f:x-base[i]})).sort((a,b)=> b.f-a.f); for(let i=0;i<rest;i++) base[frac[i%frac.length].i]++; return base; }
function groupSharesFromArchive(){ const counts=Array(g_groups.length).fill(0); for(const d of g_draws){ for(const v of d){ for(let i=0;i<g_groups.length;i++){ const g=g_groups[i]; if(v>=g.from && v<=g.to){ counts[i]++; break; } } } } const N=g_draws.length||1; return counts.map(x=> x/(N*g_drawSize||1)); }

/* Init */
(async function init(){
  const obj=await loadArchiveIDB();
  if(obj){ applyArchiveObject(obj,"Persistiert"); } else { text($("#persistInfo"),"Persistenz: (wird nach Laden aktiviert)"); }
  setGroupMode($("#groupMode").value);
  loadResults();
})();
})();
</script>