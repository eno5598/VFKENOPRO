<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>KENO Tool • Group – v12.4 Offline</title>
<style>
  :root{
    --bg:#070a0f; --panel:#0f1421; --muted:#a2adbd; --text:#eef2f7;
    --accent:#22c55e; --warn:#f59e0b; --bad:#ef4444; --info:#60a5fa;
    --hit:#22c55e; --miss:#6b7280;
    --g1:#4f83ff; --g2:#22C55E; --g3:#A855F7; --g4:#F59E0B; --g5:#EF4444; --g6:#06B6D4; --g7:#C084FC;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(64,128,255,.12), transparent 50%),
      radial-gradient(800px 400px at 110% 10%, rgba(192,132,252,.12), transparent 50%),
      linear-gradient(180deg, #06080c 0%, #0b0f18 100%);
    padding-bottom:90px;
  }
  header{position:sticky; top:0; z-index:7; backdrop-filter: blur(8px);
    background:linear-gradient(180deg, rgba(15,20,33,.85), rgba(15,20,33,.55));
    border-bottom:1px solid rgba(255,255,255,.06); padding:14px 16px; display:flex; align-items:center; gap:12px}
  .brand{display:flex; align-items:center; gap:10px; font-weight:900; letter-spacing:.3px; font-size:1.05rem;}
  .brand .dot{width:10px;height:10px;border-radius:50%;
    background:conic-gradient(from 180deg, #4f83ff, #22C55E, #A855F7, #F59E0B, #EF4444, #06B6D4, #C084FC, #4f83ff)}
  main{max-width:1180px; margin:0 auto; padding:18px; display:grid; grid-template-columns: 1.05fr 1fr; gap:14px}
  @media (max-width:1080px){ main{grid-template-columns:1fr} }
  .card{background:linear-gradient(180deg, rgba(21,28,44,.92), rgba(15,20,33,.95)); border:1px solid rgba(255,255,255,.06); border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.4), inset 0 1px 0 rgba(255,255,255,.04)}
  .col-span-2{grid-column:1 / -1}
  .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
  .btn{border:1px solid rgba(255,255,255,.08); background:#0f1524; color:#eef2f7; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600}
  .btn:hover{transform:translateY(-1px)}
  .btn.ok{background:linear-gradient(180deg,#28c76f,#19995a); border:none}
  .btn.warn{background:linear-gradient(180deg,#f59e0b,#d97706); border:none}
  input[type="file"], input[type="number"], select, input[type="text"]{
    background:#0f1524; color:#eef2f7; border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius:10px; outline:none;
  }
  a.link{color:#93c5fd; text-decoration:none; border-bottom:1px dotted #93c5fd}
  .small{font-size:.85rem} .muted{color:var(--muted)}
  .badge{padding:4px 8px; border-radius:999px; background:#0f172a; border:1px solid rgba(255,255,255,.1); font-size:.8rem}
  .hide{display:none!important}

  /* Gruppen */
  .groupBar{display:grid; grid-template-columns: auto 1fr auto auto auto; align-items:center; gap:10px;
    padding:8px 10px; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06); margin-bottom:8px}
  .qtyCtl{display:flex; gap:6px; align-items:center}
  .qtyBtn{width:32px; height:32px; display:grid; place-items:center; font-weight:900; border-radius:8px; cursor:pointer;
    border:1px solid rgba(255,255,255,.12); background:#0e1528}
  .qty{min-width:48px; text-align:center; font-weight:800; padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:#0e1528}

  /* MAP */
  .mapWrap{display:grid; gap:12px; position:relative}
  .mapGroup{border:1px solid rgba(255,255,255,.08); border-radius:14px; overflow:hidden; background:rgba(255,255,255,.02)}
  .mapHeader{display:flex; align-items:center; gap:10px; padding:10px 12px; font-weight:800}
  .mapHeader .status{margin-left:auto}
  .board{display:grid; grid-template-columns: repeat(10, 1fr); gap:10px; padding:12px; user-select:none}
  .cell{aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; border-radius:14px;
    background:#0f1930; position:relative; overflow:hidden; font-weight:900; border:1px solid rgba(255,255,255,.10);
    font-size:1.15rem; letter-spacing:.3px; cursor:default; transition:transform .2s ease}
  .cell.hit{box-shadow: inset 0 0 0 3px var(--hit), 0 0 18px rgba(34,197,94,.35)}
  .cell.miss{opacity:.45; filter:grayscale(.2)}
  .pulse{animation:pulse .38s ease}
  @keyframes pulse{ 0%{transform:scale(1)} 50%{transform:scale(1.08)} 100%{transform:scale(1)} }
  .g1{background:linear-gradient(180deg, rgba(79,131,255,.24), transparent 55%), #0f1930}
  .g2{background:linear-gradient(180deg, rgba(34,197,94,.24), transparent 55%), #0f1930}
  .g3{background:linear-gradient(180deg, rgba(168,85,247,.26), transparent 55%), #0f1930}
  .g4{background:linear-gradient(180deg, rgba(245,158,11,.26), transparent 55%), #0f1930}
  .g5{background:linear-gradient(180deg, rgba(239,68,68,.26), transparent 55%), #0f1930}
  .g6{background:linear-gradient(180deg, rgba(6,182,212,.26), transparent 55%), #0f1930}
  .g7{background:linear-gradient(180deg, rgba(192,132,252,.26), transparent 55%), #0f1930}
  .stepBadge{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    font-weight:900; font-size:86px; letter-spacing:2px; padding:22px 32px;
    border-radius:20px; background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.28);
    box-shadow:0 12px 48px rgba(0,0,0,.6); backdrop-filter: blur(6px);
    opacity:0; transition:.25s; color:#fff; text-shadow:0 2px 8px rgba(0,0,0,.6); z-index:20; pointer-events:none;
  }
  .stepBadge.show{opacity:1}
  @media (max-width:600px){ .stepBadge{font-size:58px} }

  /* Results */
  .resTable{width:100%; border-collapse:collapse; font-size:.95rem}
  .resTable th, .resTable td{border-bottom:1px solid rgba(255,255,255,.08); padding:10px 6px; text-align:left; vertical-align:middle}
  .combo{display:flex; gap:6px; flex-wrap:nowrap; overflow-x:auto; padding:2px 0}
  .pill{padding:3px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:#101a2f; font-family:ui-monospace,Consolas,Menlo,monospace; font-weight:800}
  .nowrap{white-space:nowrap}

  /* Sticky action bar (mobile) */
  .stickyBar{position:fixed; bottom:10px; left:50%; transform:translateX(-50%); z-index:50;
    background:linear-gradient(180deg, rgba(21,28,44,.95), rgba(15,20,33,.95)); border:1px solid rgba(255,255,255,.12);
    border-radius:14px; padding:8px; display:flex; gap:8px; box-shadow:0 12px 40px rgba(0,0,0,.5)}
  @media (min-width:901px){ .stickyBar{display:none} }

  /* Import progress & log */
  .progressWrap{display:flex; align-items:center; gap:10px}
  progress{width:220px; height:16px}
  .log{max-height:150px; overflow:auto; padding:8px; background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08); border-radius:8px; font-size:.9rem}
  .log .ok{color:#86efac}
  .log .skip{color:#fde68a}
  .log .bad{color:#fca5a5}
</style>
</head>
<body>
<header>
  <div class="brand"><span class="dot"></span> KENO Tool • Group</div>
</header>

<main>
  <!-- Archiv -->
  <section class="card col-span-2">
    <h2>1) Archiv</h2>
    <div class="controls" style="margin-bottom:6px">
      <input id="fileInput" type="file" accept=".zip,.csv,.txt" />
      <a class="btn" href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">Archiv herunterladen</a>
      <button class="btn" id="btnClear">Archiv löschen</button>
      <button class="btn" id="btnExportArc">Archiv exportieren</button>
      <input id="importArc" type="file" accept=".json" style="display:none">
      <button class="btn" id="btnImportArc">Archiv importieren</button>
      <span class="badge" id="bDraws">0 Ziehungen</span>
      <span class="badge" id="bRange">—</span>
      <span class="badge" id="bSaved">—</span>
    </div>
    <div class="progressWrap" style="margin-bottom:6px">
      <progress id="prog" max="100" value="0"></progress>
      <span class="small muted" id="progText">Bereit</span>
    </div>
    <div class="log" id="log"></div>
  </section>

  <!-- Gruppen -->
  <section class="card">
    <h2>2) Gruppen & Keno-Typ</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Keno-Typ&nbsp;<select id="kenoType"></select></label>
      <label class="small"><input type="checkbox" id="autoOverlap" checked> Maximale Überschneidung automatisch (Keno-Typ − 1)</label>
      <label>Max. Überschneidung&nbsp;<input id="overlapMax" type="number" min="0" max="20" value="7" style="width:90px" disabled></label>
      <span class="badge" id="sumBadge">Summe: 0</span>
      <span class="badge" id="fitBadge">—</span>
      <button class="btn" id="btnResetQuotas">Quoten zurücksetzen</button>
      <label class="small"><input type="checkbox" id="toggleStatus"> Gruppenstatus anzeigen</label>
    </div>
    <div id="groups"></div>
  </section>

  <!-- Feinfilter -->
  <section class="card">
    <h2>3) Feinfilter</h2>
    <div class="controls" style="margin-bottom:10px">
      <label>Fixe Zahlen (z. B. 5 12 44)&nbsp;<input id="fInclude" type="text" placeholder="Leerzeichen getrennt" style="width:220px"></label>
      <label>Gesperrte Zahlen&nbsp;<input id="fExclude" type="text" placeholder="Leerzeichen getrennt" style="width:220px"></label>
      <label>Max. Folge-Länge&nbsp;<input id="fConsec" type="number" min="1" max="70" value="3" style="width:80px"></label>
    </div>
    <div class="controls">
      <label>Summe min&nbsp;<input id="fSumMin" type="number" min="0" style="width:90px"></label>
      <label>Summe max&nbsp;<input id="fSumMax" type="number" min="0" style="width:90px"></label>
      <label>Ungerade min&nbsp;<input id="fOddMin" type="number" min="0" max="20" style="width:90px"></label>
      <label>Ungerade max&nbsp;<input id="fOddMax" type="number" min="0" max="20" style="width:90px"></label>
      <label>High (36–70) min&nbsp;<input id="fHighMin" type="number" min="0" max="20" style="width:90px"></label>
      <label>High (36–70) max&nbsp;<input id="fHighMax" type="number" min="0" max="20" style="width:90px"></label>
    </div>
    <div class="controls">
      <label>Letzte N Ziehungen&nbsp;<input id="fLastN" type="number" min="0" value="0" style="width:80px"></label>
      <label>Max. Überschneidung (Letzte N)&nbsp;<input id="fLastNOv" type="number" min="0" max="20" value="2" style="width:90px"></label>
    </div>
  </section>

  <!-- Map (read-only + live overlay) -->
  <section class="card" id="mapCard">
    <h2>4) Map (1–70)</h2>
    <div id="mapWrap" class="mapWrap">
      <div id="stepBadge" class="stepBadge">1</div>
    </div>
  </section>

  <!-- Generator -->
  <section class="card col-span-2">
    <h2>5) Generator</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Anzahl Ergebnisse&nbsp;<input id="genCount" type="number" min="1" max="20" value="5" style="width:100px"></label>
      <label>Anim. Tempo (ms/Zahl)&nbsp;<input id="animMs" type="number" min="80" max="2000" value="240" style="width:100px"></label>
      <label>Badge Größe&nbsp;<input id="badgeScale" type="number" min="0.6" max="1.6" step="0.1" value="1.1" style="width:90px"></label>
      <button class="btn ok" id="btnGenerate">Generieren</button>
      <button class="btn" id="btnClearRes">Alle Ergebnisse löschen</button>
      <button class="btn" id="btnExport">CSV Export</button>
    </div>
    <table class="resTable" id="resTable">
      <thead><tr><th>#</th><th>Kombi</th><th class="nowrap">Aktion</th></tr></thead>
      <tbody id="resBody"></tbody>
    </table>
  </section>

  <!-- Batch-Analyse -->
  <section class="card col-span-2" id="analysisCard">
    <h2>6) Batch-Analyse (Top-N Ergebnisse ↔ Archiv)</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Top-N&nbsp;<input id="batchN" type="number" min="1" value="5" style="width:80px"></label>
      <label>Schwelle A (≥)&nbsp;<input id="batchThrA" type="number" min="1" max="20" value="7" style="width:80px"></label>
      <label>Schwelle B (≥)&nbsp;<input id="batchThrB" type="number" min="1" max="20" value="8" style="width:80px"></label>
      <button class="btn ok" id="btnBatch">Batch analysieren</button>
      <button class="btn" id="btnBatchCSV">CSV Export</button>
    </div>
    <table class="resTable" id="batchTable">
      <thead><tr><th>#</th><th>Kombi</th><th>Max Überlappung</th><th id="colA">Überlappung ≥A</th><th id="colB">Überlappung ≥B</th><th>Volltreffer</th><th>Map</th></tr></thead>
      <tbody id="batchBody"></tbody>
    </table>
  </section>
</main>

<!-- Sticky action bar (mobile) -->
<div class="stickyBar">
  <button class="btn ok" id="sbGen">Generieren</button>
  <button class="btn" id="sbExp">CSV Export</button>
  <button class="btn" id="sbAna">Analyse</button>
</div>

<script>
/* ======= ZIP Reader (stored/deflate) ======= */
async function unzipCSVTXT(arrayBuffer, onProgress, onFile){
  const dv = new DataView(arrayBuffer); const u8 = new Uint8Array(arrayBuffer);
  const sigEOCD=0x06054b50, sigCDH=0x02014b50, sigLFH=0x04034b50;
  const U32=i=>dv.getUint32(i,true), U16=i=>dv.getUint16(i,true);
  function findEOCD(){ const max=Math.min(u8.length,0xFFFF+22); for(let i=u8.length-22;i>=u8.length-max;i--){ if(U32(i)===sigEOCD) return i; } return -1; }
  const e=findEOCD(); if(e<0) throw new Error('EOCD nicht gefunden');
  const cdSize=U32(e+12), cdOffset=U32(e+16);
  let p=cdOffset; const ents=[];
  while(p<cdOffset+cdSize){
    if(U32(p)!==sigCDH) throw new Error('CD Header erwartet');
    const method=U16(p+10), csize=U32(p+20), nlen=U16(p+28), xlen=U16(p+30), clen=U16(p+32), lfh=U32(p+42);
    const name=new TextDecoder().decode(u8.slice(p+46, p+46+nlen));
    ents.push({name, method, csize, lfh});
    p+=46+nlen+xlen+clen;
  }
  for(let i=0;i<ents.length;i++){
    const ent=ents[i]; onProgress && onProgress(Math.round((i/ents.length)*100),'Entpacke: '+ent.name);
    const lower=ent.name.toLowerCase();
    if(!/\.(csv|txt)$/.test(lower) || /(?:\bplus\b|\+5)/.test(lower)) continue;
    const p2=ent.lfh; if(U32(p2)!==sigLFH) continue;
    const nlen=U16(p2+26), xlen=U16(p2+28); const dataStart=p2+30+nlen+xlen; const slice=u8.slice(dataStart, dataStart+ent.csize);
    let text='';
    if(ent.method===0){ text=new TextDecoder().decode(slice); }
    else if(ent.method===8){
      if(typeof DecompressionStream==='undefined'){ onFile && onFile(ent.name,null,'deflate_nicht_unterstützt'); continue; }
      const stream=new Blob([slice]).stream().pipeThrough(new DecompressionStream('deflate-raw'));
      const ab=await new Response(stream).arrayBuffer(); text=new TextDecoder().decode(new Uint8Array(ab));
    }else{ onFile && onFile(ent.name,null,'methode_'+ent.method); continue; }
    onFile && onFile(ent.name, text, null);
  }
  onProgress && onProgress(100,'Fertig');
}

/* ===== IndexedDB ===== */
const DB_NAME='keno_db_offline_v12_4', STORE='kv';
const idbOpen=()=>new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>{ const db=r.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE); }; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); });
async function idbSet(k,v){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(v,k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
async function idbGet(k){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const rq=tx.objectStore(STORE).get(k); rq.onsuccess=()=>res(rq.result); rq.onerror=()=>rej(rq.error); }); }
async function idbDel(k){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).delete(k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }

/* ===== State & els ===== */
const CACHE_KEY="archive";
const state={ draws:[], freq:Array(71).fill(0), kenoType:8, quotas:[0,0,0,0,0,0,0], results:[], liveTip:new Set(), animating:false };
const els={
  fileInput:byId('fileInput'), prog:byId('prog'), progText:byId('progText'), log:byId('log'),
  bDraws:byId('bDraws'), bRange:byId('bRange'), bSaved:byId('bSaved'),
  groups:byId('groups'), kenoType:byId('kenoType'), overlapMax:byId('overlapMax'), autoOverlap:byId('autoOverlap'),
  mapWrap:byId('mapWrap'), mapCard:byId('mapCard'), stepBadge:byId('stepBadge'),
  resBody:byId('resBody'), sumBadge:byId('sumBadge'), fitBadge:byId('fitBadge'), toggleStatus:byId('toggleStatus'),
  batchN:byId('batchN'), batchThrA:byId('batchThrA'), batchThrB:byId('batchThrB'), batchBody:byId('batchBody'), colA:byId('colA'), colB:byId('colB'),
  importArc:byId('importArc'),
  // filters
  fInclude:byId('fInclude'), fExclude:byId('fExclude'), fConsec:byId('fConsec'),
  fSumMin:byId('fSumMin'), fSumMax:byId('fSumMax'), fOddMin:byId('fOddMin'), fOddMax:byId('fOddMax'),
  fHighMin:byId('fHighMin'), fHighMax:byId('fHighMax'),
  fLastN:byId('fLastN'), fLastNOv:byId('fLastNOv'),
  animMs:byId('animMs'), badgeScale:byId('badgeScale')
};

/* ===== Helpers ===== */
function byId(id){ return document.getElementById(id); }
function ymd(d){ if(!d) return null; const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0'); return Number(`${y}${m}${dd}`); }
function ymdStr(i){ if(!i) return '—'; const s=String(i); return `${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6,8)}`; }
function groupRange(i){ return `${i*10+1}–${i*10+10}` }
const gClass=i=>['g1','g2','g3','g4','g5','g6','g7'][i];
function parseNumList(text){ return (String(text||'').match(/\d+/g)||[]).map(n=>+n).filter(n=>n>=1&&n<=70); }

/* ===== Persistenz Archiv ===== */
async function saveArchive(){ try{ await idbSet(CACHE_KEY,{draws:state.draws,savedAt:Date.now()}); els.bSaved.textContent='gespeichert: '+new Date().toLocaleString(); }catch{ els.bSaved.textContent='Speichern fehlgeschlagen'; } }
async function loadArchive(){ try{ const p=await idbGet(CACHE_KEY); if(!p){ els.bSaved.textContent='kein gespeichertes Archiv'; return;} state.draws=Array.isArray(p.draws)?p.draws:[]; recomputeStats(); els.bSaved.textContent=p.savedAt?('gespeichert: '+new Date(p.savedAt).toLocaleString()):'geladen'; }catch{ els.bSaved.textContent='Laden fehlgeschlagen'; } }
async function clearArchive(){ try{ await idbDel(CACHE_KEY);}catch{} state.draws=[]; state.freq=Array(71).fill(0); els.bDraws.textContent='0 Ziehungen'; els.bRange.textContent='—'; els.bSaved.textContent='—'; renderMap(); }

/* ===== Import progress & log ===== */
function logLine(type,msg){ const div=document.createElement('div'); div.className=type; div.textContent=msg; els.log.appendChild(div); els.log.scrollTop=els.log.scrollHeight; }
function setProgress(v, txt){ els.prog.value=v; els.progText.textContent=txt||''; }

/* ===== Datei laden & parsen ===== */
function parseRowToNumbers(row){
  const nums=[]; for(const cell of row){ const ints=String(cell).match(/\d+/g)||[]; for(const t of ints){ const v=Number(t); if(v>=1&&v<=70) nums.push(v); } }
  const seen=new Set(); const out=[]; for(const n of nums){ if(!seen.has(n)){ seen.add(n); out.push(n); if(out.length>=20) break; } } return out;
}
function looksLikeDate(s){
  const a=s.match(/^(\d{4})[-/.](\d{1,2})[-/.](\d{1,2})$/); if(a){ const d=new Date(+a[1],+a[2]-1,+a[3]); return isFinite(d)?d:null; }
  const b=s.match(/^(\d{1,2})[.](\d{1,2})[.](\d{4})$/); if(b){ const d=new Date(+b[3],+b[2]-1,+b[1]); return isFinite(d)?d:null; }
  return null;
}
function parseCSVText(text){
  const lines = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n');
  return lines.map(l => l.trim()).filter(Boolean).map(l => l.split(/[;,\t ]+/));
}
async function parseTextFile(name, text){
  if(/(?:\bplus\b|\+5)/i.test(name)){ logLine('skip', 'ignoriert (Plus): '+name); return {draws:[]}; }
  const rows = parseCSVText(text);
  const result=[];
  for(const row of rows){
    const nums = parseRowToNumbers(row);
    if(nums.length>=10){
      const dateCell=row.find(c=>looksLikeDate(String(c))); const d = dateCell?looksLikeDate(String(dateCell)):null;
      result.push({date: d? ymd(d): null, numbers: nums});
    }
  }
  logLine('ok', `übernommen: ${name} (${result.length} Ziehungen)`);
  return {draws: result};
}
async function handleZipOrTextFile(file){
  els.log.textContent=''; setProgress(1,'Lese Datei…');
  const name = file.name.toLowerCase();
  if(name.endsWith('.zip')){
    const ab=await file.arrayBuffer();
    setProgress(5,'ZIP wird geöffnet…');
    const all=[];
    await unzipCSVTXT(ab,
      (v,txt)=> setProgress(v, txt),
      async (path, text, err)=>{
        if(err){
          if(err==='deflate_nicht_unterstützt'){ logLine('bad','Deflate nicht unterstützt – bitte CSV/TXT direkt laden: '+path); }
          else{ logLine('skip','übersprungen: '+path+' ('+err+')'); }
          return;
        }
        const {draws} = await parseTextFile(path, text);
        all.push(...draws);
      }
    );
    applyDraws(all);
  }else{
    const txt=await file.text();
    const {draws} = await parseTextFile(name, txt);
    applyDraws(draws);
    setProgress(100,'Fertig');
  }
}
function applyDraws(draws){
  const key = d => (d.date||'') + '|' + d.numbers.slice().sort((a,b)=>a-b).join('-');
  const dedup=new Map(); for(const d of draws) dedup.set(key(d), d);
  state.draws = [...dedup.values()].sort((a,b)=> (a.date||0) - (b.date||0));
  recomputeStats();
  saveArchive();
}
function recomputeStats(){
  state.freq = Array(71).fill(0);
  for(const d of state.draws){ for(const n of d.numbers){ state.freq[n]++; } }
  if(state.draws.length){
    const ds = state.draws.map(d=>d.date).filter(Boolean).sort((a,b)=>a-b);
    els.bRange.textContent = `${ymdStr(ds[0])} – ${ymdStr(ds[ds.length-1])}`;
  } else { els.bRange.textContent = '—'; }
  els.bDraws.textContent = `${state.draws.length.toLocaleString('de-DE')} Ziehungen`;
  renderMap();
}

/* ===== Gruppen & Map (READ-ONLY + Live overlay) ===== */
function buildKenoType(){
  els.kenoType.innerHTML='';
  for(let k=2;k<=10;k++){
    const o=document.createElement('option'); o.value=k; o.textContent=k; if(k===state.kenoType) o.selected=true;
    els.kenoType.appendChild(o);
  }
  const applyAutoOverlap = ()=>{
    if(els.autoOverlap.checked){
      els.overlapMax.value = Math.max(0, state.kenoType - 1);
      els.overlapMax.disabled = true;
    }else{
      els.overlapMax.disabled = false;
    }
  };
  els.kenoType.addEventListener('change', e=>{
    state.kenoType = Number(e.target.value);
    if(els.autoOverlap.checked){ els.overlapMax.value = Math.max(0, state.kenoType-1); }
    updateSumBadge(); renderMap();
  });
  els.autoOverlap.addEventListener('change', applyAutoOverlap);
  // initial
  els.autoOverlap.checked = true; els.overlapMax.value = Math.max(0, state.kenoType-1); els.overlapMax.disabled = true;
}
function renderGroups(){
  els.groups.innerHTML='';
  for(let i=0;i<7;i++){
    const row=document.createElement('div'); row.className='groupBar';
    row.innerHTML = `
      <span class="dot" style="width:12px;height:12px;border-radius:50%;background:var(--${gClass(i)})"></span>
      <strong>${groupRange(i)}</strong>
      <span class="badge status" id="st${i}">${state.quotas[i]===0?'GESCHLOSSEN':'offen'}</span>
      <div class="qtyCtl">
        <button class="qtyBtn" data-i="${i}" data-act="dec">−</button>
        <div class="qty" id="q${i}">${state.quotas[i]}</div>
        <button class="qtyBtn" data-i="${i}" data-act="inc">+</button>
      </div>`;
    els.groups.appendChild(row);
  }
  els.groups.querySelectorAll('.qtyBtn').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const i=Number(e.currentTarget.getAttribute('data-i'));
      const act=e.currentTarget.getAttribute('data-act');
      const cur=state.quotas[i];
      const next=Math.max(0, Math.min(10, act==='inc'?cur+1:cur-1));
      if(next===cur) return;
      state.quotas[i]=next;
      byId('q'+i).textContent=next;
      byId('st'+i).textContent= next===0?'GESCHLOSSEN':'offen';
      updateSumBadge();
      renderMap();
    });
  });
  updateSumBadge();
  updateStatusVisibility();
}
function buildMap(){
  const badge = els.stepBadge, wrap = els.mapWrap;
  wrap.innerHTML='';
  for(let i=0;i<7;i++){
    const box=document.createElement('div'); box.className='mapGroup';
    box.innerHTML = `<div class="mapHeader" style="background:linear-gradient(90deg, var(--${gClass(i)}) 0%, transparent 60%)">
        <span>${groupRange(i)}</span>
        <span class="badge status" id="mst${i}">${state.quotas[i]===0?'GESCHLOSSEN':'offen'}</span>
      </div>
      <div class="board" id="grid${i}"></div>`;
    wrap.appendChild(box);
    const grid=box.querySelector('#grid'+i);
    for(let n=i*10+1; n<=i*10+10; n++){
      const cell=document.createElement('div');
      cell.className=`cell ${gClass(i)}`;
      cell.dataset.n=n;
      cell.textContent=n;
      grid.appendChild(cell);
    }
  }
  wrap.appendChild(badge);
  renderMap();
}
function updateStatusVisibility(){
  const show = els.toggleStatus.checked;
  document.querySelectorAll('.status').forEach(el=> el.classList.toggle('hide', !show));
}
function getCellEl(n){ return document.querySelector('.cell[data-n="'+n+'"]'); }
function renderMap(){
  for(let i=0;i<7;i++){
    const badge=document.getElementById('mst'+i);
    if(badge) badge.textContent = state.quotas[i]===0 ? 'GESCHLOSSEN' : 'offen';
  }
  const hits=state.liveTip;
  document.querySelectorAll('.board .cell').forEach(cell=>{
    const n=Number(cell.dataset.n || cell.textContent);
    cell.classList.remove('hit','miss');
    if(hits.size>0){
      if(hits.has(n)) cell.classList.add('hit'); else cell.classList.add('miss');
    }
  });
}

/* ===== Utilities ===== */
function sample(pool){ const i=Math.floor(Math.random()*pool.length); return pool.splice(i,1)[0]; }
function overlapCount(a,b){ let i=0,j=0,c=0; const x=a.slice().sort((m,n)=>m-n), y=b.slice().sort((m,n)=>m-n);
  while(i<x.length&&j<y.length){ if(x[i]===y[j]){c++;i++;j++;} else if(x[i]<y[j]) i++; else j++; } return c; }
function sum(arr){ return arr.reduce((a,b)=>a+b,0); }
function oddCount(arr){ let c=0; for(const n of arr) if(n%2===1) c++; return c; }
function highCount(arr){ let c=0; for(const n of arr) if(n>=36) c++; return c; }
function maxConsecutiveRun(arr){ let m=1, cur=1; for(let i=1;i<arr.length;i++){ if(arr[i]===arr[i-1]+1){ cur++; m=Math.max(m,cur); } else cur=1; } return m; }

/* ===== Generator with constraints + animation ===== */
function generateOne(include, quotas){
  const nums=[...include];
  for(let gi=0; gi<7; gi++){
    let need=quotas[gi]; const start=gi*10+1, end=gi*10+10;
    const present=nums.filter(n=>n>=start&&n<=end).length;
    need = Math.max(0, need - present);
    if(need===0) continue;
    const pool=[]; for(let n=start;n<=end;n++) if(!nums.includes(n)) pool.push(n);
    for(let k=0;k<need;k++){ if(!pool.length) break; nums.push(sample(pool)); }
  }
  return nums.sort((a,b)=>a-b);
}
function passesArchiveOverlap(arr, limit){
  if(!state.draws.length) return true;
  for(const d of state.draws){ if(overlapCount(arr, d.numbers) > limit) return false; }
  return true;
}
function passesLastN(arr, N, limit){
  if(!state.draws.length || N<=0) return true;
  const last = state.draws.slice(-N);
  for(const d of last){ if(overlapCount(arr, d.numbers) > limit) return false; }
  return true;
}
function passesFilters(arr, cfg){
  if(cfg.exclude.size){ for(const x of arr){ if(cfg.exclude.has(x)) return false; } }
  if(cfg.include.size){ for(const x of cfg.include){ if(!arr.includes(x)) return false; } }
  if(cfg.sumMin!=null && sum(arr)<cfg.sumMin) return false;
  if(cfg.sumMax!=null && sum(arr)>cfg.sumMax) return false;
  const oc=oddCount(arr); if(cfg.oddMin!=null && oc<cfg.oddMin) return false; if(cfg.oddMax!=null && oc>cfg.oddMax) return false;
  const hc=highCount(arr); if(cfg.highMin!=null && hc<cfg.highMin) return false; if(cfg.highMax!=null && hc>cfg.highMax) return false;
  if(cfg.maxConsec && maxConsecutiveRun(arr)>cfg.maxConsec) return false;
  if(!passesArchiveOverlap(arr, cfg.overlapMax)) return false;
  if(!passesLastN(arr, cfg.lastN, cfg.lastNOv)) return false;
  return true;
}
function readFilters(){
  const include=new Set(parseNumList(els.fInclude.value));
  const exclude=new Set(parseNumList(els.fExclude.value));
  include.forEach(n=>exclude.delete(n));
  const v=(el)=>{ const t=el.value.trim(); return t===''?null:Number(t); };
  const cfg={
    include, exclude,
    maxConsec: Number(els.fConsec.value)||0,
    sumMin: v(els.fSumMin), sumMax: v(els.fSumMax),
    oddMin: v(els.fOddMin), oddMax: v(els.fOddMax),
    highMin: v(els.fHighMin), highMax: v(els.fHighMax),
    overlapMax: Math.max(0, Math.min(20, Number(els.overlapMax.value)|| (state.kenoType-1))),
    lastN: Math.max(0, Number(els.fLastN.value)||0),
    lastNOv: Math.max(0, Number(els.fLastNOv.value)||0),
  };
  return cfg;
}
function generate(){
  if(state.animating) return;
  const count = Math.max(1, Math.min(20, Number(byId('genCount').value)||5));
  const sumQuota = state.quotas.reduce((a,b)=>a+b,0);
  if(sumQuota !== state.kenoType){ alert('Summe der Gruppen muss dem Keno-Typ entsprechen.'); return; }

  const cfg = readFilters();
  for(let gi=0;gi<7;gi++){
    const start=gi*10+1, end=gi*10+10;
    const need=state.quotas[gi];
    const incInGroup = [...cfg.include].filter(n=>n>=start&&n<=end).length;
    if(incInGroup>need){ alert('Fixe Zahlen passen nicht in die gesetzten Gruppen-Quoten.'); return; }
  }

  const out=[]; const seen=new Set();
  let attempts=0, maxAttempts=Math.max(2000, count*4000);
  while(out.length<count && attempts<maxAttempts){
    attempts++;
    const arr=generateOne(cfg.include, state.quotas);
    const key=arr.join('-');
    if(seen.has(key)) continue;
    if(!passesFilters(arr, cfg)) continue;
    seen.add(key); out.push(arr);
  }
  if(out.length<count){
    alert(`Nur ${out.length}/${count} Kombinationen gefunden (Filter streng). Passe Quoten/Filter an.`);
  }
  state.results=out;
  renderResults();
  animateCombos(out, Number(els.animMs.value)||240, Number(els.badgeScale.value)||1.0);
}
function animateCombos(combos, msPer=240, scale=1.0){
  if(!combos.length) return;
  state.animating=true;
  const badge=els.stepBadge;
  badge.style.transform='translate(-50%,-50%) scale('+scale+')';
  window.scrollTo({top:els.mapCard.offsetTop-70, behavior:'smooth'});
  let idx=0;
  const playNext=()=>{
    if(idx>=combos.length){ state.animating=false; state.liveTip=new Set(); renderMap(); badge.classList.remove('show'); return; }
    const combo=combos[idx];
    badge.textContent = (idx+1).toString();
    badge.classList.add('show');
    let i=0;
    const step = ()=>{
      if(i>combo.length){
        setTimeout(()=>{ badge.classList.remove('show'); idx++; setTimeout(playNext, Math.min(500, msPer+120)); }, Math.min(500, msPer+160));
        return;
      }
      state.liveTip = new Set(combo.slice(0,i));
      renderMap();
      if(i>0){
        const el=getCellEl(combo[i-1]); if(el){ el.classList.add('pulse'); setTimeout(()=>el.classList.remove('pulse'), Math.max(280, msPer)); }
      }
      i++;
      setTimeout(step, msPer);
    };
    step();
  };
  playNext();
}

/* ===== Results & Batch ===== */
function renderResults(){
  const tb=els.resBody; tb.innerHTML='';
  state.results.forEach((arr,i)=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${i+1}</td>
      <td><div class="combo">${arr.map(n=>`<span class="pill">${n}</span>`).join('')}</div></td>
      <td class="nowrap">
        <button class="btn small" data-act="copy" data-i="${i}">Kopieren</button>
        <button class="btn small" data-act="map" data-i="${i}">Map anzeigen</button>
      </td>`;
    tb.appendChild(tr);
  });
  tb.querySelectorAll('button').forEach(b=>{
    const i=Number(b.getAttribute('data-i')); const act=b.getAttribute('data-act');
    b.addEventListener('click', ()=>{
      const arr=state.results[i]; if(!arr) return;
      if(act==='copy'){ navigator.clipboard.writeText(arr.join(' ')); b.textContent='Kopiert'; setTimeout(()=>b.textContent='Kopieren',800); }
      if(act==='map'){ state.liveTip = new Set(arr); renderMap(); window.scrollTo({top:els.mapCard.offsetTop-70, behavior:'smooth'}); }
    });
  });
}
function clearResults(){ state.results=[]; els.resBody.innerHTML=''; state.liveTip=new Set(); renderMap(); }
function exportCSV(){
  const rows=[['#','Kombi']];
  state.results.forEach((arr,i)=> rows.push([i+1, arr.join(' ')]));
  const csv = rows.map(r=>r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(';')).join('\n');
  const blob=new Blob([csv], {type:'text/csv;charset=utf-8'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='keno_ergebnisse.csv'; a.click(); URL.revokeObjectURL(a.href);
}
function batchOverlapCount(a,b){ return overlapCount(a,b); }
function analyzeOneAgainstArchive(tip, thrA, thrB){
  let maxOv=0, cA=0, cB=0, cFull=0;
  for(const d of state.draws){
    const ov = batchOverlapCount(tip, d.numbers);
    if(ov>maxOv) maxOv=ov;
    if(ov>=thrA) cA++;
    if(ov>=thrB) cB++;
    if(ov===tip.length) cFull++;
  }
  return {maxOv, cA, cB, cFull};
}
function updateBatchHeaders(){
  const a = Number(els.batchThrA.value)||7;
  const b = Number(els.batchThrB.value)||8;
  els.colA.textContent = `Überlappung ≥${a}`;
  els.colB.textContent = `Überlappung ≥${b}`;
}
function batchAnalyze(){
  if(!state.results.length){ alert('Bitte zuerst Ergebnisse generieren.'); return; }
  if(!state.draws.length){ alert('Bitte zuerst ein Archiv laden.'); return; }
  const N = Math.max(1, Math.min(state.results.length, Number(els.batchN.value)||5));
  els.batchN.value = N;
  const thrA = Math.max(1, Number(els.batchThrA.value)||7);
  const thrB = Math.max(1, Number(els.batchThrB.value)||8);
  updateBatchHeaders();
  const top = state.results.slice(0,N);
  const rows=[];
  els.batchBody.innerHTML='';
  top.forEach((arr,idx)=>{
    const {maxOv,cA,cB,cFull} = analyzeOneAgainstArchive(arr, thrA, thrB);
    const tr=document.createElement('tr');
    tr.innerHTML = `<td>${idx+1}</td>
      <td><div class="combo">${arr.map(n=>`<span class="pill">${n}</span>`).join('')}</div></td>
      <td>${maxOv}</td><td>${cA}</td><td>${cB}</td><td>${cFull}</td>
      <td><button class="btn small" data-i="${idx}" data-act="map">Map</button></td>`;
    els.batchBody.appendChild(tr);
    rows.push({rank:idx+1, kombi:arr.join(' '), max_overlap:maxOv, geA:cA, geB:cB, voll:cFull});
  });
  els.batchBody.querySelectorAll('button').forEach(b=>{
    b.addEventListener('click', ()=>{
      const i=Number(b.getAttribute('data-i'));
      const arr=top[i];
      state.liveTip = new Set(arr);
      renderMap();
      window.scrollTo({top:els.mapCard.offsetTop-70, behavior:'smooth'});
    });
  });
  batchAnalyze._csv = rows;
}
function batchCSV(){
  const rows = batchAnalyze._csv || [];
  if(!rows.length){ alert('Bitte zuerst Batch analysieren.'); return; }
  const a = Number(els.batchThrA.value)||7, b=Number(els.batchThrB.value)||8;
  const header = ['#','Kombi','Max Überlappung',`Überlappung ≥${a}`,`Überlappung ≥${b}`,'Volltreffer'];
  const data = [header, ...rows.map(r=>[r.rank, r.kombi, r.max_overlap, r.geA, r.geB, r.voll])];
  const csv = data.map(r=>r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(';')).join('\n');
  const blob=new Blob([csv], {type:'text/csv;charset=utf-8'});
  const aEl=document.createElement('a'); aEl.href=URL.createObjectURL(blob); aEl.download='keno_batch_analyse.csv'; aEl.click(); URL.revokeObjectURL(aEl.href);
}

/* ===== Events ===== */
els.fileInput.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; await handleZipOrTextFile(f); });
byId('btnClear').addEventListener('click', ()=>{ if(confirm('Archiv wirklich löschen?')) clearArchive(); });
byId('btnResetQuotas').addEventListener('click', ()=>{ state.quotas=[0,0,0,0,0,0,0]; renderGroups(); buildMap(); updateSumBadge(); });
byId('btnGenerate').addEventListener('click', generate);
byId('btnClearRes').addEventListener('click', clearResults);
byId('btnExport').addEventListener('click', exportCSV);
byId('btnBatch').addEventListener('click', batchAnalyze);
byId('btnBatchCSV').addEventListener('click', batchCSV);
els.batchThrA.addEventListener('input', updateBatchHeaders);
els.batchThrB.addEventListener('input', updateBatchHeaders);
byId('btnExportArc').addEventListener('click', ()=>{
  const payload={draws: state.draws, exportedAt: Date.now()};
  const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='keno_archiv.json'; a.click(); URL.revokeObjectURL(a.href);
});
byId('btnImportArc').addEventListener('click', ()=> els.importArc.click());
els.importArc.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const obj = JSON.parse(await f.text());
    if(!Array.isArray(obj.draws)) throw new Error('Invalid');
    state.draws = obj.draws;
    recomputeStats();
    await saveArchive();
  }catch{ alert('Import fehlgeschlagen.'); }
});
byId('sbGen').addEventListener('click', ()=>byId('btnGenerate').click());
byId('sbExp').addEventListener('click', ()=>byId('btnExport').click());
byId('sbAna').addEventListener('click', ()=>{ byId('analysisCard').scrollIntoView({behavior:'smooth', block:'start'}); });
els.toggleStatus.addEventListener('change', ()=> updateStatusVisibility());

/* ===== Sum badge ===== */
function updateSumBadge(){
  const sum=state.quotas.reduce((a,b)=>a+b,0);
  els.sumBadge.textContent=`Summe: ${sum}`;
  els.fitBadge.textContent = sum===state.kenoType ? 'passt' : `(${sum}/${state.kenoType})`;
}

/* ===== Init ===== */
(function init(){
  buildKenoType(); renderGroups(); buildMap(); updateSumBadge(); updateBatchHeaders();
  loadArchive();
})();
</script>
</body>
</html>
