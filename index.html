<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO ‚Äì Kombinationen, Muster, Hot-Gruppen & Live-Map</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#111827;
    --border:#223046;
    --muted:#263041;
    --text:#e5e7eb;
    --accent:#22c55e;
    --accent2:#60a5fa;
    --warm:#fb923c;
    --danger:#ef4444;

    /* feste 10er-Farben f√ºr 1‚Äì10, 11‚Äì20, ... 61‚Äì70 (nicht √§nderbar) */
    --g10-0:#1d4ed8; /* 1‚Äì10  (blau) */
    --g10-1:#059669; /* 11‚Äì20 (gr√ºn) */
    --g10-2:#b45309; /* 21‚Äì30 (braun/amber) */
    --g10-3:#7c3aed; /* 31‚Äì40 (violett) */
    --g10-4:#dc2626; /* 41‚Äì50 (rot) */
    --g10-5:#0ea5e9; /* 51‚Äì60 (hellblau) */
    --g10-6:#f59e0b; /* 61‚Äì70 (orange) */

    --cell-bg:#0f172a;        /* Zellen-Grundton */
    --cell-border:#1f2937;    /* Zellen-Rand */
    --cell-text:#e5e7eb;      /* Zellen-Text */
    --cell-selected:#f8fafc;  /* Text wenn ausgew√§hlt */
    --outline:#cbd5e1;
    --outline-muted:#475569;
  }

  html,body{height:100%}
  body{
    margin:0;padding:16px;
    font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:var(--bg);color:var(--text)
  }
  a{color:#93c5fd;text-decoration:none}
  .box{max-width:1180px;margin:0 auto}

  input[type="file"],input[type="number"],input[type="text"],select,textarea{
    width:100%;box-sizing:border-box;padding:10px;border-radius:10px;
    border:1px solid var(--muted);background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .ghost{background:transparent;border:1px dashed var(--muted);color:var(--text)}

  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 220px}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px}

  .panel{
    background:var(--panel);border:1px solid var(--border);
    border-radius:12px;padding:14px;margin:12px 0 0
  }
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .pill{display:inline-block;padding:4px 10px;border-radius:999px;border:1px solid var(--muted);background:var(--bg);margin-left:8px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:8px}
  .badge.hot{background:#1f2937;border-color:var(--warm);color:#ffd7a1}
  .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
  .hint{color:#9ca3af;font-size:14px;margin-top:4px}
  .status{
    margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);
    border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap
  }
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .resItem{
    display:flex;align-items:center;gap:10px;flex-wrap:wrap;background:var(--bg);
    border:1px solid var(--muted);border-radius:10px;padding:8px;margin-bottom:6px
  }
  .resNums{white-space:pre}
  .hotnum{color:var(--danger);font-weight:700}
  progress{width:100%;height:12px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-bar{background:var(--bg)}
  progress::-webkit-progress-value{background:var(--accent)}

  /* Favoriten */
  .favCard{background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:8px}
  .favHead{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .favNums{font-weight:700}
  .favBtns{display:flex;gap:6px}
  .favNote{color:#9ca3af;font-size:13px;margin-top:6px;white-space:pre-wrap}

  /* Muster-Chips */
  .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .chip{display:inline-flex;align-items:center;gap:6px;background:var(--bg);border:1px solid var(--muted);border-radius:999px;padding:4px 6px}
  .chip .val{min-width:18px;text-align:center}
  .chip button{padding:4px 8px;border-radius:999px;font-weight:800;line-height:1}

  /* === Live-Map === */
  .mapWrap{display:flex;gap:14px;flex-wrap:wrap}
  .mapLeft{flex:2 1 420px}
  .mapRight{flex:1 1 220px}
  .board{
    display:grid;
    grid-template-columns:repeat(10, minmax(30px,1fr));
    gap:6px;
    user-select:none;
  }
  .cell{
    position:relative;
    background:var(--cell-bg);
    border:1px solid var(--cell-border);
    border-radius:10px;
    color:var(--cell-text);
    font-weight:700;
    padding:8px 0;
    text-align:center;
    line-height:1;
    transition:transform .06s ease, box-shadow .06s ease, background .15s ease, color .15s ease, border-color .15s ease;
  }
  .cell small{
    display:block;font-weight:600;opacity:.9;margin-top:4px;font-size:12px
  }
  .cell.selected{transform:translateY(-1px);color:var(--cell-selected);box-shadow:0 0 0 2px rgba(255,255,255,.08) inset}
  .cell.hotDot::after{
    content:"";position:absolute;top:6px;right:6px;width:8px;height:8px;border-radius:999px;background:#ef4444;
    box-shadow:0 0 0 2px rgba(0,0,0,.5)
  }

  /* feste 10er-Farben per Klasse (nur Hintergrund-Tint, Text bleibt gut lesbar) */
  .cell.g10-0{background:color-mix(in oklab, var(--g10-0) 28%, var(--cell-bg))}
  .cell.g10-1{background:color-mix(in oklab, var(--g10-1) 28%, var(--cell-bg))}
  .cell.g10-2{background:color-mix(in oklab, var(--g10-2) 28%, var(--cell-bg))}
  .cell.g10-3{background:color-mix(in oklab, var(--g10-3) 28%, var(--cell-bg))}
  .cell.g10-4{background:color-mix(in oklab, var(--g10-4) 28%, var(--cell-bg))}
  .cell.g10-5{background:color-mix(in oklab, var(--g10-5) 28%, var(--cell-bg))}
  .cell.g10-6{background:color-mix(in oklab, var(--g10-6) 28%, var(--cell-bg))}

  /* Segment-Outline (Gruppen-Einteilung 10/7/5/3 oder Custom). 0-Quoten bekommen bewusst KEINE Outline. */
  .segmentOutline{
    outline:2px solid var(--outline);
    outline-offset:-3px;
    border-radius:12px;
  }
  .segmentOutlineMuted{
    outline:2px dashed var(--outline-muted);
    outline-offset:-3px;
    border-radius:12px;
  }

  /* Quoten-Tabelle */
  .quotaGrid{
    display:grid;gap:8px;
    grid-template-columns:repeat(auto-fill,minmax(180px,1fr));
    margin-top:8px
  }
  .quotaItem{
    background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:8px
  }
  .quotaItem label{display:block;font-size:13px;color:#cbd5e1;margin-bottom:6px}
  .quotaItem .qrow{display:flex;gap:8px;align-items:center}
  .quotaItem input{width:100px}
</style>
</head>
<body>
<div class="box">

  <!-- üóÇÔ∏è Archiv -->
  <div class="panel" id="p-archiv" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2><span class="pill">ZIP wird lokal entpackt</span></div>
    <p class="hint">
      Offizielles Archiv (manuell laden & hier ausw√§hlen):
      <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
    </p>
    <div class="row">
      <div>
        <label>CSV/TXT oder ZIP ausw√§hlen</label>
        <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">
        <div class="hint">Erkannt: ‚ÄûZahl1..Zahl20‚Äú, Spalte ‚Äû1-4-‚Ä¶‚Äú oder freie Zahlzeilen. Robuster Fallback inkludiert.</div>
      </div>
      <div>
        <label>Archiv-Status</label>
        <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
        <div class="row" style="margin-top:6px"><button id="clearCache" class="danger">Archiv l√∂schen</button></div>
      </div>
    </div>
  </div>

  <!-- üéõÔ∏è Einstellungen -->
  <div class="panel" id="p-settings" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">üéõÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div>
        <label>Kombi-Gr√∂√üe (KENO-Typ)</label>
        <select id="kenoType">
          <option value="2">Typ 2</option><option value="3">Typ 3</option><option value="4">Typ 4</option>
          <option value="5">Typ 5</option><option value="6" selected>Typ 6</option><option value="7">Typ 7</option>
          <option value="8">Typ 8</option><option value="9">Typ 9</option><option value="10">Typ 10</option>
        </select>
      </div>
      <div><label>Max. erlaubte √úberschneidung</label><input type="number" id="maxOv" value="5" min="0" max="20"></div>
      <div><label>Zahlenbereich ‚Äì Von</label><input type="number" id="rangeFrom" value="1" min="1" max="200"></div>
      <div><label>Zahlenbereich ‚Äì Bis</label><input type="number" id="rangeTo" value="70" min="1" max="200"></div>
    </div>
  </div>

  <!-- üó∫Ô∏è Live-Map & Gruppen-Einteilung -->
  <div class="panel" id="p-map" style="border-left:6px solid #38bdf8">
    <div class="ph">
      <span class="emoji">üó∫Ô∏è</span><h2 style="margin:0">Live-Map & Gruppen-Einteilung</h2>
      <span class="pill">Farben fix: 1‚Äì10, 11‚Äì20, ‚Ä¶</span>
    </div>

    <div class="row">
      <div>
        <label><input type="checkbox" id="mapEnabled" checked> Map aktivieren (bei Generieren live anzeigen)</label>
        <div class="hint">‚Äû0‚Äú bei einer Gruppe bedeutet: Aus dieser Gruppe darf <b>nichts</b> genommen werden. Leeres Feld = keine Vorgabe.</div>
      </div>
      <div>
        <label>Map-Geschwindigkeit</label>
        <select id="mapSpeed">
          <option value="fast">schnell</option>
          <option value="normal" selected>normal</option>
          <option value="slow">langsam</option>
        </select>
      </div>
      <div>
        <label>Gruppen-Einteilung (Anzeige & Quoten)</label>
        <select id="mapGroupSize">
          <option value="10" selected>10er-Gruppen (1‚Äì10, 11‚Äì20, ‚Ä¶) ‚Äì Empfohlen</option>
          <option value="7">7er-Gruppen (1‚Äì7, 8‚Äì14, ‚Ä¶)</option>
          <option value="5">5er-Gruppen</option>
          <option value="3">3er-Gruppen</option>
          <option value="custom">Benutzerdefiniert‚Ä¶</option>
        </select>
      </div>
      <div id="mapCustomWrap" style="display:none">
        <label>Custom-Gr√∂√üe</label>
        <input type="number" id="mapCustomSize" value="10" min="2" max="35" step="1">
        <div class="hint">Teilt 1‚Äì70 in Schritte dieser Gr√∂√üe ein. Farben bleiben weiterhin nach 10er-Bl√∂cken fix.</div>
      </div>
    </div>

    <div class="mapWrap" style="margin-top:8px">
      <div class="mapLeft">
        <div id="board" class="board" aria-label="KENO-Board 1‚Äì70"></div>
        <div class="row" style="margin-top:8px">
          <div style="flex:1 1 220px">
            <label>Live-Status</label>
            <div id="mapStatus" class="status">Map bereit.</div>
          </div>
          <div style="flex:1 1 160px">
            <label>Schon eingeteilt</label>
            <div class="status" id="mapAssigned">0 / S</div>
          </div>
        </div>
      </div>
      <div class="mapRight">
        <label>Gruppen-Quoten (je Segment der Einteilung)</label>
        <div id="quotaBox" class="quotaGrid"></div>
        <div class="row" style="margin-top:8px">
          <button id="quotaClear" class="ghost">Quoten leeren</button>
          <button id="quotaZeroAll" class="danger">Alle 0 (alles verbieten)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- üß© Muster -->
  <div class="panel" id="p-pattern" style="border-left:6px solid var(--warm)">
    <div class="ph"><span class="emoji">üß©</span><h2 style="margin:0">Muster-Abst√§nde</h2><span class="pill">S = Abst√§nde + 1</span></div>
    <label><input type="checkbox" id="usePattern"> Muster verwenden</label>
    <div id="patternBox" style="display:none">
      <label>Aktuelles Muster (read-only)</label>
      <div id="gapLine" class="mono" style="margin:4px 0 8px;opacity:.9">[ ]</div>
      <div class="chips" id="chips"></div>
      <div class="hint">Ergebnis: <span id="sOut" class="badge">S = 1 Zahl</span></div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0">
        <button id="gapAdd" class="secondary">Ôºã Abstand</button>
        <button id="gapRemove" class="danger">Ôºç Abstand</button>
        <button id="gapClear" class="danger">‚úñÔ∏è Alles l√∂schen</button>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0">
        <button id="gapRand" class="secondary">üé≤ Zuf√§llig f√ºllen</button>
        <button id="gapAllPlus" class="secondary">‚§¥Ô∏é Alle +1</button>
        <button id="gapAllMinus" class="secondary">‚§µÔ∏é Alle ‚àí1</button>
        <button id="gapShuffle" class="ghost">üîÄ Mischen</button>
        <button id="gapReverse" class="ghost">‚ÜîÔ∏é Spiegeln</button>
      </div>
      <div class="panel" style="margin:10px 0 0">
        <div class="ph"><span class="emoji">üß™</span><h3 style="margin:0">√Ñhnliche Varianten</h3><span class="pill">3 Vorschl√§ge</span></div>
        <div class="row">
          <div><label>Vorschl√§ge</label><input type="number" id="varCount" value="3" min="1" max="50"></div>
          <div><label>√Ñhnlichkeit</label>
            <select id="simLevel"><option value="high">Hoch</option><option value="med" selected>Mittel</option><option value="low">Niedrig</option></select>
          </div>
        </div>
        <div class="row" style="margin-top:6px">
          <button id="makeVariants" class="secondary">Vorschl√§ge erzeugen</button>
          <button id="clearVariants" class="danger">Vorschl√§ge l√∂schen</button>
        </div>
        <div id="variantList" class="grid"></div>
      </div>
    </div>
  </div>

  <!-- üî• H√§ufige Gruppen -->
  <div class="panel" id="p-hot" style="border-left:6px solid #f472b6">
    <div class="ph"><span class="emoji">üî•</span><h2 style="margin:0">H√§ufige Gruppen</h2><span class="pill">Paare / 3er / 4er / 5er</span></div>
    <label style="display:flex;align-items:center;gap:8px">
      <input type="checkbox" id="useHotGroups"> <span>aktivieren</span>
    </label>
    <div id="hotBox" style="display:none">
      <div class="row">
        <div><label>R√ºckblick Ziehungen</label><input type="number" id="hotWindow" value="500" min="50" max="50000"></div>
        <div><label>Gruppengr√∂√üe</label>
          <select id="hotK">
            <option value="2" selected>2 (Paare)</option>
            <option value="3">3 (Trips)</option>
            <option value="4">4 (Quads)</option>
            <option value="5">5 (Quints)</option>
          </select>
        </div>
        <div><label>Top N</label><input type="number" id="hotTopN" value="30" min="5" max="1000"></div>
        <div><label>Modus</label>
          <select id="hotMode"><option value="require" selected>M√ºssen enthalten</option><option value="prefer">Bevorzugen</option></select>
        </div>
        <div>
          <label>Suche-Stufe</label>
          <select id="searchLevel">
            <option value="normal" selected>Normal</option>
            <option value="medium">Mittel</option>
            <option value="hard">Hard</option>
          </select>
          <div id="hotHardWrap" class="hint" style="display:none;margin-top:6px">
            Hard-Zeit:
            <select id="hotHardBudget">
              <option value="5" selected>‚âà 5 min</option>
              <option value="10">‚âà 10 min</option>
              <option value="max">Maximum (ganze Historie)</option>
            </select>
          </div>
        </div>
      </div>
      <div class="row">
        <div style="flex:2 1 180px"><label>Info</label><div id="hotInfo" class="status">inaktiv</div></div>
        <div style="flex:1 1 180px"><label>Fortschritt</label><progress id="hotProg" value="0" max="1" style="display:none"></progress></div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="hotStart" class="secondary">Neu berechnen</button>
        <button id="hotCancel" class="danger" disabled>Abbrechen</button>
      </div>
    </div>
  </div>

  <!-- üßÆ Generieren -->
  <div class="panel" id="p-gen" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üßÆ</span><h2 style="margin:0">Kombinationen generieren</h2></div>
    <div class="row">
      <div><label>Wieviele Ergebnisse</label><input type="number" id="want" value="10" min="1" max="2000"></div>
      <div><label>Max. Versuche (Basis, Normal)</label><input type="number" id="tries" value="60000" min="1000" step="1000"></div>
      <div><label>Seed</label><input type="number" id="seed" value="1" min="0"></div>
      <div>
        <label>Suche-Stufe</label>
        <select id="genLevel">
          <option value="normal" selected>Normal</option>
          <option value="medium">Mittel</option>
          <option value="hard">Hard</option>
        </select>
        <div id="genHardWrap" class="hint" style="display:none;margin-top:6px">
          Hard-Zeit:
          <select id="genHardBudget">
            <option value="5" selected>‚âà 5 min</option>
            <option value="10">‚âà 10 min</option>
            <option value="max">Maximum</option>
          </select>
        </div>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="go" class="primary">Generieren</button>
      <button id="save" class="secondary">Als CSV speichern</button>
    </div>
    <div class="row" style="margin-top:8px">
      <div style="flex:2 1 180px"><label>Generieren-Status</label><div id="genInfo" class="status">bereit</div></div>
      <div style="flex:1 1 180px"><label>Fortschritt</label><progress id="genProg" value="0" max="1" style="display:none"></progress></div>
    </div>
    <div class="row" style="margin-top:6px"><button id="genCancel" class="danger" disabled>Generieren abbrechen</button></div>
  </div>

  <!-- üß† Tipp pr√ºfen -->
  <div class="panel" id="p-analyse" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">üß†</span><h2 style="margin:0">Tipp analysieren</h2><span class="pill">Auto-Scroll hierher</span></div>
    <div style="margin:4px 0">
      <input type="checkbox" id="autoThr" checked>
      <label for="autoThr">Schwellen automatisch an KENO-Typ koppeln</label>
    </div>
    <label>Dein Tipp (Zahlen mit Leerzeichen/Komma)</label>
    <input type="text" id="tipInput" placeholder="z. B. 10 11 16 22 24 44 48 49 50 52">
    <div class="row" style="margin-top:6px">
      <div><label>√úberschneidung z√§hlen ab (‚â•)</label><input type="number" id="thrA" value="5" min="1" max="20"></div>
      <div><label>2. Schwelle (optional, ‚â•)</label><input type="number" id="thrB" value="6" min="1" max="20"></div>
    </div>
    <div style="margin-top:6px" class="row">
      <button id="checkTip" class="secondary">Tipp analysieren</button>
      <button id="saveTipFav" class="ghost">‚≠êÔ∏é Tipp speichern (mit Notiz)</button>
    </div>
    <div id="tipStatus" class="status" style="display:none"></div>
  </div>

  <!-- ‚≠ê Favoriten -->
  <div class="panel" id="p-favs" style="border-left:6px solid var(--warm)">
    <div class="ph"><span class="emoji">‚≠ê</span><h2 style="margin:0">Favoriten & Notizen</h2>
      <button id="favToggle" class="ghost" style="margin-left:auto">üëÅÔ∏è Favoriten ein-/ausblenden</button>
    </div>
    <div class="row">
      <div>
        <label>Aktionen</label>
        <div class="row">
          <button id="favExport" class="secondary">Exportieren (JSON)</button>
          <input type="file" id="favImportFile" accept="application/json">
          <button id="favClear" class="danger">Alle Favoriten l√∂schen</button>
        </div>
      </div>
    </div>
    <div id="favList" class="grid" style="margin-top:8px"></div>
  </div>

  <!-- üìã Ergebnisse -->
  <div class="panel" id="p-results">
    <div class="ph"><span class="emoji">üìã</span><h2 style="margin:0">Ergebnisse</h2></div>
    <div id="results" class="results"></div>
    <div id="resultStatus" class="status" style="display:none;margin-top:10px"></div>
  </div>

</div>

<!-- JSZip (ZIP-Entpacken im Browser) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(function(){
  "use strict";

  /* === kleine Hilfen === */
  const $ = sel => document.querySelector(sel);
  const text = (el, s) => { if(el) el.textContent = s; };
  const html = (el, s) => { if(el) el.innerHTML = s; };
  const uniqSorted = a => Array.from(new Set(a)).sort((x,y)=>x-y);
  const sum = a => a.reduce((s,x)=>s+x,0);
  const scrollToNode = n => { if(!n) return; n.scrollIntoView({behavior:"smooth", block:"start"}); };

  /* === Keys f√ºr LocalStorage === */
  const CACHE_KEY="keno_archive_v4";
  const PATTERN_KEY="keno_pattern_v1";
  const USEPAT_KEY="keno_usepat_v1";
  const FAV_KEY="keno_favorites_v1";
  const FAV_VISIBLE_KEY="keno_fav_visible_v1";

  /* === Globale Zust√§nde === */
  let g_draws = [];           // Archiv-Ziehungen (Arrays mit Zahlen)
  let g_drawSize = 0;         // dominierende Ziehungsgr√∂√üe
  let g_pattern = [];         // Muster-Abst√§nde
  let g_hotGroups = [];       // Liste der Hot-Gruppen (Arrays)
  let g_hotMeta = {k:2,window:500,topN:30,mode:"require",level:"normal"};
  let hotWorker = null, genWorker = null;

  /* === Live-Map Zustand === */
  let g_segments = [];        // [{from,to, idx}] anhand mapGroupSize
  let g_quotas = [];          // Vorgaben je Segment (null = frei, 0 = verbieten, >0 = exakt)
  let g_liveAnimating = false;
  let g_lastLive = null;

  /* ===================== Archiv laden (CSV/TXT/ZIP) ‚Äì robust ===================== */

  function splitSmart(line){
    // getrennt nach TAB / ; / | / , (aber nur, wenn es nicht "1-2-3" ist), sonst whitespace
    if(/\t/.test(line)) return line.split("\t");
    if(line.includes(";")) return line.split(";");
    if(line.includes("|")) return line.split("|");
    if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
    return line.trim().split(/\s+/);
  }

  function parseTable(textRaw){
    // Entferne BOM, normalisiere \r\n
    let t=textRaw;
    if(t.charCodeAt(0)===0xFEFF) t=t.slice(1);
    t=t.replace(/\r\n/g,"\n").replace(/\r/g,"\n");
    return t.split(/\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);
  }

  function tryZahlHeader(rows){
    if(!rows.length) return null;
    const header = rows[0].map(x=>String(x||"").trim());
    const idx=[];
    for(let i=0;i<header.length;i++){
      const h = header[i].toLowerCase().replace(/\s+/g,"");
      // ‚ÄûZahl1‚Äú, ‚ÄûZahl 1‚Äú, ‚Äûzahl_1‚Äú etc.
      if(/^zahl[_\s]*\d+$/.test(h)) idx.push(i);
    }
    if(idx.length>=5){
      const lists=[];
      for(let r=1;r<rows.length;r++){
        const row=rows[r];
        const nums=idx.map(i=>parseInt(String(row[i]||"").trim(),10)).filter(n=>Number.isFinite(n));
        if(nums.length) lists.push(nums);
      }
      return {lists, info:`Header erkannt (${idx.length} Zahl-Spalten)`};
    }
    return null;
  }

  function detectDashCol(rows){
    let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
    let best=-1,score=-1;
    for(let c=0;c<maxCols;c++){
      let sc=0;
      for(const r of rows){
        if(c>=r.length) continue;
        const cell=String(r[c]||"").trim(); if(!cell) continue;
        const parts=cell.split("-");
        if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }

  function fallbackExtract(raw){
    // greift sehr gro√üz√ºgig: ‚Äû1-2-3‚Ä¶‚Äú, lose Zahlen je Zeile, auch mit Kommas/Semikolon gemischt
    const out=[];
    const lines = raw.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
    for(const lnRaw of lines){
      const ln = lnRaw.trim(); if(!ln) continue;

      // 1-2-3-... erkannt
      if(/^\d+(?:-\d+)+$/.test(ln)){
        out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isFinite));
        continue;
      }

      // Semikolon/Komma-getrennt oder sonst frei: sammle alle Zahlen
      const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isFinite);
      if(nums.length>=5) out.push(nums);
    }
    return out;
  }

  function loadArchiveFromRawText(raw, sourceLabel){
    const rows = parseTable(raw);
    let lists=[], detected="", z, ncol;

    // 1) ‚ÄûZahl1..Zahl20‚Äú-Header
    z=tryZahlHeader(rows);
    if(z){ lists=z.lists; detected=z.info; }
    else{
      // 2) Spalte wie ‚Äû1-4-11-...‚Äú
      ncol=detectDashCol(rows);
      if(ncol>=0){
        for(const r of rows){
          if(ncol>=r.length) continue;
          const cell=String(r[ncol]||"").trim(); if(!cell) continue;
          const parts=cell.split("-");
          if(parts.length && parts.every(p=>/^\d+$/.test(p.trim())))
            lists.push(parts.map(x=>parseInt(x,10)));
        }
        detected="Spalte 1-4-‚Ä¶";
      }else{
        // 3) gro√üz√ºgiger Fallback (auch gemischte Trennzeichen)
        lists=fallbackExtract(raw);
        detected="Fallback: freie Zahlzeilen";
      }
    }

    if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");

    // Dominierende L√§nge 5..20 ermitteln (z. B. 20 f√ºr KENO-Archiv)
    const freq=new Map();
    for(const a of lists){
      if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1);
    }
    let bestLen=0,bestCnt=-1;
    for(const [k,v] of freq.entries()){ if(v>bestCnt){bestCnt=v;bestLen=k;} }
    if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");

    g_drawSize=bestLen;
    g_draws = lists
      .filter(a=>a.length===g_drawSize)
      .map(arr => uniqSorted(arr.filter(n=>Number.isInteger(n) && n>=1 && n<=200))); // Safety

    if(!g_draws.length) throw new Error("Nach Filter auf dominierende L√§nge keine Ziehungen √ºbrig.");

    try{
      localStorage.setItem(CACHE_KEY, JSON.stringify({
        draws:g_draws, drawSize:g_drawSize, savedAt:Date.now(), source:sourceLabel||""
      }));
    }catch{}

    text($("#statusTop"), `Archiv geladen: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}${sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:""}`);
  }

  async function handleAnyFile(file){
    if(!file) return;
    text($("#statusTop"), `Lese Datei: ${file.name}`);
    const name=file.name.toLowerCase();
    try{
      if(name.endsWith(".zip")){
        if(!window.JSZip){ alert("JSZip fehlt (CDN)"); return; }
        const ab = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(ab);

        // beste CSV/TXT im ZIP finden
        const candidates=[];
        zip.forEach((path, entry)=>{
          const p=path.toLowerCase();
          if(p.endsWith(".csv") || p.endsWith(".txt")){
            const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
            candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
          }
        });
        if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden");

        candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
        const target=candidates[0];
        text($("#statusTop"), `Entpacke & lese: ${target.path}`);

        let raw="";
        try{ raw = await target.entry.async("string"); }
        catch(_){
          const u8=new Uint8Array(await target.entry.async("uint8array"));
          raw=new TextDecoder("utf-8",{fatal:false}).decode(u8);
        }
        loadArchiveFromRawText(raw, `ZIP: ${target.path}`);
      }else{
        const txt = await file.text();
        loadArchiveFromRawText(txt, file.name||"Upload");
      }

      if($("#useHotGroups").checked) recomputeHotGroups();
    }catch(e){
      text($("#statusTop"), "Fehler beim Lesen: "+(e?.message||e));
      g_draws=[]; g_drawSize=0;
    }
  }

  $("#file").addEventListener("change", ()=> handleAnyFile($("#file").files[0]));
  $("#clearCache").addEventListener("click",()=>{
    try{ localStorage.removeItem(CACHE_KEY); }catch{}
    g_draws=[]; g_drawSize=0;
    text($("#statusTop"), "Archiv gel√∂scht. Bitte Datei erneut laden.");
    $("#results").innerHTML=""; $("#resultStatus").style.display="none";
  });

  /* ===================== Init ===================== */
  (function init(){
    // Cache einlesen
    try{
      const raw=localStorage.getItem(CACHE_KEY);
      if(raw){
        const obj=JSON.parse(raw)||{};
        g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
        if(g_draws.length){
          const ts=obj.savedAt?new Date(obj.savedAt):new Date();
          const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
          text($("#statusTop"), `Archiv aus Browser geladen: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ gespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}${src}`);
        }
      }
    }catch{}

    // Muster aus Storage
    try{ const p=localStorage.getItem(PATTERN_KEY); g_pattern=p?JSON.parse(p):[]; }catch{ g_pattern=[]; }
    renderPattern();

    // Muster-Toggle
    const usePat=(localStorage.getItem(USEPAT_KEY)==="1");
    $("#usePattern").checked=!!usePat;
    togglePatternBox();

    // Typ/Schwellen synchronisieren
    syncToKenoType(true);

    // Favoriten
    renderFavorites();
    const favVis = localStorage.getItem(FAV_VISIBLE_KEY);
    if(favVis==="0") $("#favList").style.display="none";

    // Live-Map initialisieren
    buildBoard();
    buildSegmentsAndQuotas(); // Standard 10er
    renderQuotaControls();
    applySegmentOutlines();

    toggleHardUIs();
  })();

  /* ===================== KENO-Typ & Muster ===================== */

  function getS(){
    let s=parseInt($("#kenoType").value,10);
    if(isNaN(s)||s<2||s>10) s=6;
    return s;
  }

  function syncToKenoType(onInit){
    const Sval=getS();
    $("#maxOv").value = Math.max(0,Sval-1);
    if($("#autoThr").checked){
      $("#thrA").value = Math.max(1,Sval-1);
      $("#thrB").value = Sval;
    }
    if(g_pattern.length!==Sval-1){
      if(g_pattern.length<Sval-1) g_pattern = g_pattern.concat(Array(Sval-1-g_pattern.length).fill(1));
      else g_pattern = g_pattern.slice(0,Sval-1);
      savePattern(); renderPattern();
    }
    if(!onInit) text($("#statusTop"), `KENO-Typ ${Sval} aktiv ¬∑ maxOv=${Sval-1} ¬∑ Schwellen ${Sval-1}/${Sval}`);
    // Live-Status S anpassen
    text($("#mapAssigned"), `0 / ${Sval}`);
  }

  $("#kenoType").addEventListener("change", ()=>syncToKenoType(false));
  $("#autoThr").addEventListener("change", ()=>syncToKenoType(false));

  function renderPattern(){
    const chips=$("#chips"); chips.innerHTML="";
    g_pattern.forEach((v,i)=>{
      const el=document.createElement("span");
      el.className="chip";
      el.innerHTML = `<button class="secondary" data-act="dec" data-idx="${i}">‚àí</button>
                      <span class="val">${v}</span>
                      <button class="secondary" data-act="inc" data-idx="${i}">Ôºã</button>`;
      chips.appendChild(el);
    });
    $("#gapLine").textContent = g_pattern.length ? "[ "+g_pattern.join(", ")+" ]" : "[ ]";
    $("#sOut").textContent = "S = "+(g_pattern.length+1)+" Zahlen";
  }

  function savePattern(){ try{ localStorage.setItem(PATTERN_KEY, JSON.stringify(g_pattern)); }catch{} }
  function togglePatternBox(){
    const on=$("#usePattern").checked;
    $("#patternBox").style.display=on?"":"none";
    try{ localStorage.setItem(USEPAT_KEY, on?"1":"0"); }catch{}
  }
  $("#usePattern").addEventListener("change", togglePatternBox);

  $("#chips").addEventListener("click", e=>{
    const btn=e.target.closest("button[data-act]"); if(!btn) return;
    const i=+btn.dataset.idx, act=btn.dataset.act;
    if(!(i>=0) || i>=g_pattern.length) return;
    if(act==="inc") g_pattern[i]+=1;
    else if(act==="dec") g_pattern[i]=Math.max(1,g_pattern[i]-1);
    savePattern(); renderPattern();
    text($("#statusTop"), `Muster: [${g_pattern.join(", ")}] ‚Üí S=${g_pattern.length+1}`);
  });

  $("#gapAdd").addEventListener("click", ()=>{
    g_pattern.push(1); savePattern(); renderPattern();
    text($("#statusTop"), "Abstand +1. S="+(g_pattern.length+1));
  });
  $("#gapRemove").addEventListener("click", ()=>{
    if(g_pattern.length){
      g_pattern.pop(); savePattern(); renderPattern();
      text($("#statusTop"), "Abstand entfernt. S="+(g_pattern.length+1));
    }
  });
  $("#gapClear").addEventListener("click", ()=>{ g_pattern=[]; savePattern(); renderPattern(); });

  const shuffle=a=>a.map(v=>[v,Math.random()]).sort((x,y)=>x[1]-y[1]).map(x=>x[0]);
  const reverseArr=a=>a.slice().reverse();
  const maxGapGuess=k=>{
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const span=Math.max(1,B-A);
    return Math.max(1, Math.floor(span/k));
  };
  function setPattern(arr){
    g_pattern=arr.map(x=>Math.max(1,x|0)); savePattern(); renderPattern();
    $("#usePattern").checked=true; togglePatternBox();
  }
  function randomFill(){
    const Sval=getS(),k=Sval-1,mg=Math.max(1,maxGapGuess(k));
    setPattern(Array.from({length:k},()=>1+Math.floor(Math.random()*mg)));
  }
  function incAll(d){
    if(!g_pattern.length){ alert("Kein Muster ‚Äì zuerst anlegen."); return; }
    setPattern(g_pattern.map(x=>Math.max(1,x+d)));
  }
  $("#gapRand").addEventListener("click", randomFill);
  $("#gapAllPlus").addEventListener("click", ()=>incAll(+1));
  $("#gapAllMinus").addEventListener("click", ()=>incAll(-1));
  $("#gapShuffle").addEventListener("click", ()=>{
    if(!g_pattern.length){ alert("Kein Muster ‚Äì zuerst anlegen."); return; }
    setPattern(shuffle(g_pattern));
  });
  $("#gapReverse").addEventListener("click", ()=>{
    if(!g_pattern.length){ alert("Kein Muster ‚Äì zuerst anlegen."); return; }
    setPattern(reverseArr(g_pattern));
  });

  /* ===================== Varianten (aus Muster) ===================== */

  function computeStats(A,B){
    const n=B-A+1, freq=Array(n).fill(0), last=Array(n).fill(-1);
    for(let d=0; d<g_draws.length; d++){
      for(const v of g_draws[d]){
        if(v<A||v>B) continue;
        const idx=v-A; freq[idx]++; last[idx]=d;
      }
    }
    const rec=last.map(x=> x<0 ? 9999 : (g_draws.length-1-x));
    return {freq,rec};
  }

  function scorePattern(gaps,A,B,stats){
    const price=Array.from({length:B-A+1},(_,i)=>{
      (stats.freq[i]||0)*0.6 + (1/((stats.rec[i]||9999)+1))*0.8
    });
    const inc=sum(gaps),startMax=B-inc; if(startMax<A) return {score:Infinity,start:A};
    let best=Infinity,bestStart=A;
    for(let s=A;s<=startMax;s++){
      let cost=0,cur=s; cost+=price[cur-A];
      for(const g of gaps){ cur+=g; cost+=price[cur-A]; }
      if(cost<best){best=cost;bestStart=s;}
    }
    return {score:+best.toFixed(3),start:bestStart};
  }

  const similarity=(a,b)=>{
    const k=a.length; let same=0;
    for(let i=0;i<k;i++) if(Math.abs(a[i]-b[i])<=1) same++;
    return same/k;
  };

  function mutateNear(base,level){
    const g=base.slice(),k=g.length;
    const ops = level==='high'? 1 : level==='med'? 2 : 3+Math.floor(Math.random()*2);
    for(let t=0;t<ops;t++){
      const r=Math.random(), i=Math.floor(Math.random()*k), j=Math.floor(Math.random()*k);
      if(r<0.33 && k>1 && i!==j){ const tmp=g[i]; g[i]=g[j]; g[j]=tmp; }
      else if(r<0.66 && i!==j && g[i]>1){ g[i]-=1; g[j]+=1; }
      else { if(Math.random()<0.5) g[i]+=1; else if(g[i]>1) g[i]-=1; }
    }
    for(let i=0;i<k;i++) if(g[i]<1) g[i]=1;
    return g;
  }

  function generateVariants(baseGaps,{A,B,count,simLevel}){
    const stats=computeStats(A,B), out=[], seen=new Set();
    const tol = simLevel==='high'? 0.9 : simLevel==='med'? 0.75 : 0.55;
    const divTol = 0.9; let tries=0, budget=count*25;
    while(out.length<count && tries<budget){
      tries++;
      const g=mutateNear(baseGaps,simLevel);
      const key=g.join(","); if(seen.has(key)) continue; seen.add(key);
      if(A+g.reduce((a,b)=>a+b,0)>B) continue;
      if(similarity(baseGaps,g) < tol) continue;
      if(out.some(v=> similarity(v.gaps,g)>divTol)) continue;
      const {score,start}=scorePattern(g,A,B,stats);
      out.push({gaps:g,score,start});
    }
    out.sort((x,y)=>x.score-y.score);
    return out.slice(0,count);
  }

  function renderVariantList(items){
    const box=$("#variantList"); box.innerHTML="";
    if(!items.length){
      box.innerHTML='<div class="hint">(keine Vorschl√§ge ‚Äì √Ñhnlichkeit/Bereich anpassen)</div>';
      return;
    }
    box._data = items.slice();
    for(const [idx,it] of items.entries()){
      const s=it.gaps.length+1;
      const div=document.createElement("div");
      div.className="favCard";
      div.innerHTML=`
        <span class="badge">#${idx+1}</span>
        <span class="mono">[ ${it.gaps.join(", ")} ]</span>
        <span class="badge">S=${s}</span>
        <span class="badge">Score=${it.score}</span>
        <span class="badge">Start=${it.start}</span>
        <div style="margin-top:6px;display:flex;gap:6px">
          <button class="secondary" data-act="use" data-idx="${idx}">√úbernehmen</button>
          <button class="danger" data-act="del" data-idx="${idx}">L√∂schen</button>
        </div>
      `;
      box.appendChild(div);
    }
  }

  $("#makeVariants").addEventListener("click", ()=>{
    if(!g_draws.length){ alert("Bitte zuerst Archiv laden."); return; }
    if(!g_pattern.length){ alert("Bitte zuerst Abst√§nde mit +/‚àí festlegen."); return; }
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const count=+$("#varCount").value, simLevel=$("#simLevel").value;
    const items=generateVariants(g_pattern.slice(),{A,B,count,simLevel});
    renderVariantList(items);
    text($("#statusTop"), items.length
      ? `√Ñhnliche Vorschl√§ge: ${items.length} (√§hnlich=${simLevel}).`
      : "Keine passenden Vorschl√§ge ‚Äì √Ñhnlichkeit erh√∂hen oder Bereich anpassen."
    );
  });

  $("#clearVariants").addEventListener("click",()=>{
    $("#variantList").innerHTML=""; $("#variantList")._data=[];
  });

  $("#variantList").addEventListener("click",(e)=>{
    const btn=e.target.closest("button[data-act]"); if(!btn) return;
    const i=+btn.dataset.idx, act=btn.dataset.act, list=$("#variantList")._data||[];
    const it=list[i]; if(!it) return;
    if(act==="use"){
      setPattern(it.gaps.slice());
      text($("#statusTop"), `Muster √ºbernommen: [${g_pattern.join(", ")}] (S=${g_pattern.length+1})`);
    }else if(act==="del"){
      list.splice(i,1); renderVariantList(list);
    }
  });

  /* ===================== Live-Map: Board, Segmente, Quoten ===================== */

  function buildBoard(){
    const board=$("#board");
    board.innerHTML="";
    for(let n=1;n<=70;n++){
      const d=document.createElement("div");
      const g10 = Math.floor((n-1)/10); // 0..6
      d.className=`cell g10-${g10}`;
      d.setAttribute("data-n", String(n));
      d.innerHTML = `${n}<small>&nbsp;</small>`;
      board.appendChild(d);
    }
  }

  function currentGroupSize(){
    const sel=$("#mapGroupSize").value;
    if(sel==="custom"){
      const c=parseInt($("#mapCustomSize").value,10);
      return Math.max(2, Math.min(35, isNaN(c)?10:c));
    }
    return parseInt(sel,10);
  }

  function buildSegmentsAndQuotas(){
    const sz=currentGroupSize();
    g_segments=[]; g_quotas=[];
    let start=1, idx=0;
    while(start<=70){
      const end = Math.min(70, start+sz-1);
      g_segments.push({from:start, to:end, idx});
      g_quotas.push(null); // leer = keine Vorgabe
      start=end+1; idx++;
    }
  }

  function renderQuotaControls(){
    const box=$("#quotaBox"); box.innerHTML="";
    g_segments.forEach((seg,i)=>{
      const div=document.createElement("div");
      div.className="quotaItem";
      const label=`Gruppe ${i+1}: ${seg.from}‚Äì${seg.to}`;
      const value = g_quotas[i];
      const valStr = (value===null || value===undefined) ? "" : String(value);
      div.innerHTML = `
        <label>${label}</label>
        <div class="qrow">
          <input type="number" class="quotaInput" data-idx="${i}" placeholder="frei" min="0" step="1" value="${valStr}">
          <span class="hint">0 = keine nehmen</span>
        </div>
      `;
      box.appendChild(div);
    });
  }

  function applySegmentOutlines(){
    // Alle Zellen zuerst ‚Äûmuted‚Äú rausnehmen
    const cells=[...document.querySelectorAll(".cell")];
    cells.forEach(c=>{
      c.classList.remove("segmentOutline");
      c.classList.remove("segmentOutlineMuted");
    });

    // F√ºr jede Gruppe Outline (nur wenn Quote > 0 oder frei) ‚Äì bei 0 KEINE Outline
    g_segments.forEach((seg,idx)=>{
      const quota = g_quotas[idx];
      const hasOutline = (quota===null || quota===undefined) ? true : (quota>0);
      const cls = hasOutline ? "segmentOutline" : null;
      if(!cls) return; // 0 ‚Üí keine Outline

      for(let n=seg.from;n<=seg.to;n++){
        const el = document.querySelector(`.cell[data-n="${n}"]`);
        if(el) el.classList.add(cls);
      }
    });
  }

  // Quoten-Events
  $("#quotaBox").addEventListener("input", (e)=>{
    const inp=e.target.closest("input.quotaInput"); if(!inp) return;
    const i=+inp.dataset.idx;
    let v=inp.value.trim();
    if(v===""){ g_quotas[i]=null; } // frei
    else{
      const n=parseInt(v,10);
      g_quotas[i]= isNaN(n) ? null : Math.max(0,n);
    }
    applySegmentOutlines();
  });

  $("#quotaClear").addEventListener("click", ()=>{
    g_quotas = g_quotas.map(()=>null);
    renderQuotaControls();
    applySegmentOutlines();
  });
  $("#quotaZeroAll").addEventListener("click", ()=>{
    g_quotas = g_quotas.map(()=>0);
    renderQuotaControls();
    applySegmentOutlines();
  });

  // Einteilung-UI
  $("#mapGroupSize").addEventListener("change", ()=>{
    const v=$("#mapGroupSize").value;
    $("#mapCustomWrap").style.display = (v==="custom") ? "" : "none";
    buildSegmentsAndQuotas();
    renderQuotaControls();
    applySegmentOutlines();
  });
  $("#mapCustomSize").addEventListener("change", ()=>{
    buildSegmentsAndQuotas();
    renderQuotaControls();
    applySegmentOutlines();
  });

  /* ===================== Hard-UIs sichtbar/unsichtbar ===================== */
  function toggleHardUIs(){
    $("#hotHardWrap").style.display = ($("#searchLevel").value==="hard") ? "" : "none";
    $("#genHardWrap").style.display = ($("#genLevel").value==="hard") ? "" : "none";
  }
  $("#searchLevel").addEventListener("change", ()=>{
    toggleHardUIs();
    if($("#useHotGroups").checked) recomputeHotGroups();
  });
  $("#hotHardBudget").addEventListener("change", ()=>{
    if($("#useHotGroups").checked) recomputeHotGroups();
  });
  $("#genLevel").addEventListener("change", toggleHardUIs);

  /* ===================== Hot-Gruppen (Paare/3/4/5) ===================== */

  function toggleHotBox(){
    const on=$("#useHotGroups").checked;
    $("#hotBox").style.display=on?"":"none";
    text($("#hotInfo"), on?"bereit":"inaktiv");
  }
  $("#useHotGroups").addEventListener("change", ()=>{
    toggleHotBox();
    if($("#useHotGroups").checked) recomputeHotGroups();
  });
  ["hotWindow","hotK","hotTopN","hotMode"].forEach(id=>{
    const el=document.getElementById(id);
    if(el) el.addEventListener("change", ()=>{
      if($("#useHotGroups").checked) recomputeHotGroups();
    });
  });
  $("#hotStart").addEventListener("click", ()=>{
    if($("#useHotGroups").checked) recomputeHotGroups();
  });

  function hardBudgetSeconds(sel){ return sel==="5"? 300 : sel==="10"? 600 : Infinity; }

  function recomputeHotGroups(){
    if(!g_draws.length){
      g_hotGroups=[];
      text($("#hotInfo"),"aktiv: kein Archiv");
      return;
    }
    const k=+($("#hotK").value||2);
    let topN=Math.max(5,Math.min(1000,+($("#hotTopN").value||30)));
    const level=$("#searchLevel").value||"normal";
    let win=Math.max(50,+($("#hotWindow").value||500));
    if(win>g_draws.length) win=g_draws.length;

    const LEVELS={
      normal:{winMul:1.2, topMul:1.2},
      medium:{winMul:1.6, topMul:1.8},
      hard:{winMul:2.2, topMul:2.5}
    };
    const L=LEVELS[level]||LEVELS.normal;
    win=Math.min(g_draws.length, Math.max(1, Math.floor(win*L.winMul)));
    topN=Math.floor(topN*L.topMul);

    const hardSel = ($("#searchLevel").value==="hard");
    const budgetSec = (!hardSel) ? 0 : hardBudgetSeconds($("#hotHardBudget").value);

    const fromIdx=Math.max(0,g_draws.length-win);
    const slice=g_draws.slice(fromIdx);

    if(hotWorker){ try{ hotWorker.terminate(); }catch{} hotWorker=null; }

    // Worker-Code f√ºr Top-N-Gruppen (inkl. k=5)
    const workerCode = `
      let STOP=false;
      function combIter(arr,k,cb){
        const n=arr.length; if(k>n) return;
        const idx=Array.from({length:k},(_,i)=>i);
        while(true){
          cb(idx.map(i=>arr[i]));
          let i=k-1;
          while(i>=0 && idx[i]===i+n-k) i--;
          if(i<0) break;
          idx[i]++;
          for(let j=i+1;j<k;j++) idx[j]=idx[j-1]+1;
        }
      }
      function spaceSavingUpdate(store, cap, key){
        if(store.has(key)){ store.set(key, store.get(key)+1); return; }
        if(store.size < cap){ store.set(key, 1); return; }
        const toDel=[];
        for(const [kk,v] of store){
          const nv=v-1; if(nv<=0) toDel.push(kk); else store.set(kk,nv);
        }
        for(const kk of toDel) store.delete(kk);
      }
      self.onmessage = ev=>{
        const {draws,k,topN,budgetSec,mode} = ev.data;
        const nDraws = draws.length;
        const t0=performance.now();
        let processed=0, lastPing=0;

        function ping(total){
          self.postMessage({type:'progress', done:processed, total, elapsed:(performance.now()-t0)/1000});
        }

        if(k<=4 || !Number.isFinite(budgetSec) || budgetSec===0 || mode!=='max'){
          const counts = new Map();
          const warmMax=Math.min(30,nDraws); let warmT0=performance.now();
          for(let d=0; d<warmMax; d++){
            combIter(draws[d],k,(combo)=>{
              const key=combo.join('-'); counts.set(key,(counts.get(key)||0)+1);
            });
          }
          const rate = warmMax / ((performance.now()-warmT0)/1000 || 0.001);
          let targetDraws = nDraws;
          if(Number.isFinite(budgetSec) && budgetSec>0){
            targetDraws = Math.max(warmMax, Math.min(nDraws, Math.floor(rate*budgetSec)));
          }
          for(let d=warmMax; d<targetDraws; d++){
            combIter(draws[d],k,(combo)=>{
              const key=combo.join('-'); counts.set(key,(counts.get(key)||0)+1);
            });
            processed=d+1;
            if(processed-lastPing>=10){ lastPing=processed; ping(targetDraws); }
            if(STOP) break;
          }
          const items=Array.from(counts.entries()).sort((a,b)=> b[1]-a[1] || (a[0]<b[0]?-1:1));
          const top = items.slice(0, topN).map(([key,count])=>({key,count}));
          self.postMessage({type:'done', top, total:processed});
          return;
        }

        // k=5 + Maximum ‚Üí 2-Pass
        const cap = Math.max(5*topN, 5000);
        const store = new Map();
        for(let d=0; d<nDraws; d++){
          combIter(draws[d],5,(combo)=>{ spaceSavingUpdate(store, cap, combo.join('-')); });
          processed=d+1;
          if(processed-lastPing>=10){ lastPing=processed; ping(nDraws); }
          if(STOP) break;
        }
        const candidates = Array.from(store.keys());
        const candSet = new Set(candidates);
        const exact = new Map();
        processed=0; lastPing=0;
        const total2 = nDraws;
        for(let d=0; d<nDraws; d++){
          combIter(draws[d],5,(combo)=>{
            const key=combo.join('-');
            if(candSet.has(key)) exact.set(key,(exact.get(key)||0)+1);
          });
          processed=d+1;
          if(processed-lastPing>=10){
            lastPing=processed; self.postMessage({type:'progress2', pass:2, done:processed, total:total2, elapsed:(performance.now()-t0)/1000});
          }
          if(STOP) break;
        }
        const items=Array.from(exact.entries()).sort((a,b)=> b[1]-a[1] || (a[0]<b[0]?-1:1));
        const top = items.slice(0, topN).map(([key,count])=>({key,count}));
        self.postMessage({type:'done', top, total:nDraws});
      };
      self.onmessagecancel = ()=>{ STOP=true; };
    `;

    const blob=new Blob([workerCode],{type:'application/javascript'});
    const url=URL.createObjectURL(blob);
    hotWorker=new Worker(url);

    $("#hotProg").style.display="";
    $("#hotProg").value=0; $("#hotProg").max=1;
    $("#hotCancel").disabled=false;

    const t0=performance.now();
    hotWorker.onmessage=ev=>{
      const msg=ev.data;
      if(msg.type==='progress' || msg.type==='progress2'){
        const p=msg.done/Math.max(1,msg.total);
        $("#hotProg").value=p;
        const secs=((performance.now()-t0)/1000).toFixed(1);
        const passTxt = msg.type==='progress2' ? ' (Pass 2/2)' : '';
        text($("#hotInfo"),`Berechne${passTxt}‚Ä¶ ${Math.round(p*100)}% (${msg.done}/${msg.total}) ¬∑ ${secs}s`);
      }else if(msg.type==='done'){
        $("#hotProg").style.display="none"; $("#hotCancel").disabled=true;
        const list=msg.top||[];
        g_hotGroups=list.map(it=> it.key.split("-").map(x=>parseInt(x,10)) );
        const modeSel = ($("#hotHardBudget").value==="max" && $("#searchLevel").value==="hard") ? "max" : "budget";
        g_hotMeta={k,window:win,topN,mode:($("#hotMode").value||"require"), level, modeSel};
        if(!list.length){
          text($("#hotInfo"),"Keine Gruppen gefunden.");
        }else{
          const head=list[0].count;
          const lines=list.slice(0,10).map(it=>`${it.key} √ó${it.count}`).join(" | ");
          $("#hotInfo").innerHTML =
            `Top ${list.length} (k=${k}, Stufe=${level}${(modeSel==='max')?', Maximum':''}): h√§ufigste = ${head}<br>`+
            `<span class='mono'>${lines}${list.length>10?" | ‚Ä¶":""}</span>`;
        }
        try{ hotWorker.terminate(); }catch{} hotWorker=null; URL.revokeObjectURL(url);
      }
    };
    hotWorker.onerror=e=>{
      $("#hotProg").style.display="none";
      $("#hotCancel").disabled=true;
      text($("#hotInfo"),"Fehler im Worker: "+e.message);
      try{ hotWorker.terminate(); }catch{} hotWorker=null; URL.revokeObjectURL(url);
    };
    $("#hotCancel").onclick=()=>{
      if(hotWorker){ try{ hotWorker.terminate(); }catch{} hotWorker=null; }
      $("#hotProg").style.display="none"; $("#hotCancel").disabled=true;
      text($("#hotInfo"),"abgebrochen");
      URL.revokeObjectURL(url);
    };

    const mode = ($("#searchLevel").value==="hard" && $("#hotHardBudget").value==="max") ? "max" : "budget";
    hotWorker.postMessage({draws:slice,k,topN,budgetSec,mode});
  }

  function matchedHotGroups(arr){
    const hits=[]; if(!g_hotGroups.length) return hits;
    const set=new Set(arr);
    for(const g of g_hotGroups) if(g.every(v=>set.has(v))) hits.push(g);
    return hits;
  }

  /* ===================== Generieren: Bits vorbereiten ===================== */
  function buildDrawBits(A,B){
    const toBits=arr=>{
      let bits=0n;
      for(const v of arr){ if(v>=A&&v<=B) bits|=(1n<<BigInt(v-1)); }
      return bits;
    };
    return g_draws.map(d=> toBits(d).toString());
  }

  function triesBaseForNormal(base){ return { tries: Math.max(base*2, base+40_000), seeds: 3 }; }
  function hardBudgetSecondsGen(sel){ return sel==="5"? 300 : sel==="10"? 600 : Infinity; }

  /* ======= Teil 1/3 Ende ‚Äì weiter in Teil 2/3 mit Generator-Worker & Live-Map ======= */
    /* ===================== Generator-Worker mit Live-Map-Hooks ===================== */

  function startGenerateInWorker(params){
    if(genWorker){ try{ genWorker.terminate(); }catch{} genWorker=null; }

    // Wir schicken neben den Standard-Parametern auch die Segment-Quoten (g_quotas) + Einteilung (g_segments)
    const quotas = (g_quotas||[]).map(v => (v===null||v===undefined)? -1 : v); // -1 = frei, 0 = verbieten, >0 = exakt
    const segs = g_segments.map(s=>({from:s.from, to:s.to}));

    // Worker-Code: unterst√ºtzt Random & Pattern, Quoten-Check, Hot-Gruppen, Live-Events
    const code = `
      // ===== Worker-Scope =====
      function rng(seed){ let t=seed>>>0; return ()=>{ t=(t+0x6D2B79F5)>>>0; let r=((t^(t>>>15))|1); r=Math.imul(r^(r>>>7),61|r); r=(r^(r>>>14))>>>0; return r/4294967296; }; }
      function sampleRange(A,B,S,rand){ const n=B-A+1; if(S>n) return null; const a=Array(n); for(let i=0;i<n;i++) a[i]=A+i; for(let i=0;i<S;i++){ const j=i+Math.floor(rand()*(n-i)); const t=a[i]; a[i]=a[j]; a[j]=t; } a.length=S; a.sort((x,y)=>x-y); return a; }
      function toBits(arr){ let bits=0n; for(const v of arr){ if(v>0) bits |= (1n<<BigInt(v-1)); } return bits; }
      function popcountUpTo(x,limit){ let c=0; while(x){ x&=(x-1n); c++; if(c>limit) break; } return c; }
      function validAgainst(drawsBits,cb,maxOv){
        for(const db of drawsBits){ if(popcountUpTo(cb & db, maxOv) > maxOv) return false; }
        return true;
      }
      function hasHotGroup(arr, HOT){
        if(!HOT || !HOT.length) return false;
        const set=new Set(arr);
        outer: for(const g of HOT){ for(const v of g){ if(!set.has(v)) continue outer; } return true; }
        return false;
      }
      function inSegIdx(n, segs){ // finde Segment-Index f√ºr n (1..70)
        for(let i=0;i<segs.length;i++){ const s=segs[i]; if(n>=s.from && n<=s.to) return i; }
        return -1;
      }
      function quotasSatisfied(arr, quotas, segs){
        // quotas: -1 = frei, 0 = verbieten, >0 = exakt
        if(!quotas || !quotas.length) return true;
        const cnt = Array(quotas.length).fill(0);
        for(const v of arr){
          const si=inSegIdx(v, segs);
          if(si>=0) cnt[si]++;
        }
        for(let i=0;i<quotas.length;i++){
          const q=quotas[i];
          if(q===-1) continue;        // frei
          if(q===0 && cnt[i]>0) return false; // verboten
          if(q>0 && cnt[i]!==q) return false; // exakt
        }
        return true;
      }

      self.onmessage = (ev)=>{
        const p = ev.data;
        const drawsBits = p.drawsBits.map(s=>BigInt(s));
        const want=p.want|0, maxOv=p.maxOv|0, A=p.A|0, B=p.B|0, S=p.S|0;
        const mode=p.mode; const HOT = p.hotGroups || []; const hotMode = p.hotMode || 'require'; const hotOn = !!p.hotOn;
        const deepLevel = p.level || 'normal';
        const budgetSec = p.budgetSec || 0;
        const baseSeed = (p.seed>>>0) || 1;

        const quotas = p.quotas || []; // -1 = frei, 0 = verbieten, >0 = exakt
        const segs    = p.segs || [];

        const outPrefer=[], outOther=[]; let tested=0, lastPing=0;
        const t0=performance.now();

        function pushLive(arr, assigned){
          // leichte Drosselung: nur alle X ms (abh√§ngig von mapSpeed aus Mainthread)
          if(performance.now() - (self._lastLive||0) < (p.liveEveryMs||50)) return;
          self._lastLive = performance.now();
          self.postMessage({type:'live', arr, assigned});
        }

        // ===== Zufallsmodus =====
        if(mode==='random'){
          // Warm-up: 20k Versuche (Messung)
          let warmTries=20000;
          let triesDone=0;
          let warmStart=performance.now();
          let seen=new Set();
          const randWarm=rng(baseSeed);
          while(triesDone < warmTries){
            const cand = sampleRange(A,B,S,randWarm); if(!cand) break;
            const key=cand.join('-'); if(seen.has(key)) continue; seen.add(key);
            const cb=toBits(cand);
            validAgainst(drawsBits,cb,maxOv);
            triesDone++;
          }
          const rate = triesDone / ((performance.now()-warmStart)/1000 || 0.001);
          let triesTarget = p.triesTarget || 0;
          if(Number.isFinite(budgetSec) && budgetSec>0){
            triesTarget = Math.max(triesDone, Math.floor(rate * budgetSec));
            if(hotOn && hotMode==='require') triesTarget = Math.floor(triesTarget*1.2);
          }else{
            triesTarget = p.triesTarget || triesDone*5;
          }
          const seedSweep = Math.max(1, p.seedSweep|0);
          for(let sIdx=0; sIdx<seedSweep && (outPrefer.length+outOther.length)<want; sIdx++){
            const rand=rng((baseSeed + sIdx*101)>>>0), seenS=new Set();
            let localBudget = Math.floor(triesTarget / seedSweep);
            for(let t=0; t<localBudget && (outPrefer.length+outOther.length)<want; t++){
              const cand = sampleRange(A,B,S,rand); if(!cand) break;
              const key=cand.join('-'); if(seenS.has(key)) continue; seenS.add(key);
              // Quoten vorab checken (schnell)
              if(quotas.length && !quotasSatisfied(cand, quotas, segs)){ tested++; continue; }

              const cb = toBits(cand);
              if(validAgainst(drawsBits,cb,maxOv)){
                const hit = hotOn ? hasHotGroup(cand,HOT) : false;
                if(hotOn && hotMode==='require'){ if(hit){ outPrefer.push(cand); pushLive(cand, cand.length); } }
                else if(hotOn && hotMode==='prefer'){ (hit?outPrefer:outOther).push(cand); pushLive(cand, cand.length); }
                else { outOther.push(cand); pushLive(cand, cand.length); }
              }else{
                // selbst wenn invalid, Live mit ‚Äûbisher selektiert‚Äú (cosmetic)
                pushLive(cand, 0);
              }
              tested++;
              if(tested - lastPing >= 2000){
                lastPing=tested; self.postMessage({type:'progress', tested, found: outPrefer.length+outOther.length, want, total: triesTarget});
              }
            }
          }
        }else{
          // ===== Muster-Modus (pattern / gaps) =====
          const gaps=p.gaps||[];
          const inc=gaps.reduce((a,b)=>a+b,0);
          let start=A, end=B-inc;
          if(end<start){ self.postMessage({type:'done', out:[]}); return; }

          // Warm-up: 400 Startpunkte
          let warmN = Math.min(400, (end-start+1));
          let tWarm0=performance.now(), testedWarm=0;
          for(let s=start; s<start+warmN; s++){
            const seq=[s]; let cur=s; for(const g of gaps){ cur+=g; seq.push(cur); }
            if(seq[0]>=A && seq[seq.length-1]<=B){
              const cb=toBits(seq); validAgainst(drawsBits,cb,maxOv);
            }
            testedWarm++;
          }
          const rate = testedWarm / ((performance.now()-tWarm0)/1000 || 0.001);
          let totalStarts = end-start+1;
          if(Number.isFinite(budgetSec) && budgetSec>0){
            totalStarts = Math.min(totalStarts, Math.max(testedWarm, Math.floor(rate * budgetSec)));
          }else{
            if(deepLevel==='normal' && (end-start)>15000) totalStarts = Math.floor((end-start+1)/4);
            else if(deepLevel==='medium' && (end-start)>20000) totalStarts = Math.floor((end-start+1)/2);
          }

          let processed=0;
          for(let s=start; s<=end && (outPrefer.length+outOther.length)<want && processed<totalStarts; s++){
            const seq=[s]; let cur=s; for(const g of gaps){ cur+=g; seq.push(cur); }
            if(seq[0]<A || seq[seq.length-1]>B) { processed++; continue; }

            // Quoten vorab
            if(quotas.length && !quotasSatisfied(seq, quotas, segs)){
              processed++; tested++; pushLive(seq, 0);
              if(processed - lastPing >= 500){
                lastPing=processed; self.postMessage({type:'progress', tested: processed, found: outPrefer.length+outOther.length, want, total: totalStarts});
              }
              continue;
            }

            const cb = toBits(seq);
            if(validAgainst(drawsBits,cb,maxOv)){
              const hit = hotOn ? hasHotGroup(seq,HOT) : false;
              if(hotOn && hotMode==='require'){ if(hit){ outPrefer.push(seq); pushLive(seq, seq.length); } }
              else if(hotOn && hotMode==='prefer'){ (hit?outPrefer:outOther).push(seq); pushLive(seq, seq.length); }
              else { outOther.push(seq); pushLive(seq, seq.length); }
            }else{
              pushLive(seq, 0);
            }
            processed++; tested++;
            if(processed - lastPing >= 500){
              lastPing=processed; self.postMessage({type:'progress', tested: processed, found: outPrefer.length+outOther.length, want, total: totalStarts});
            }
          }
        }

        const out = outPrefer.concat(outOther).slice(0, want);
        self.postMessage({type:'done', out});
      };
    `;

    const blob=new Blob([code],{type:'application/javascript'});
    const url=URL.createObjectURL(blob);
    genWorker=new Worker(url);

    // Fortschritt & Live
    $("#genProg").style.display="";
    $("#genProg").value=0; $("#genProg").max=1;
    $("#genCancel").disabled=false;

    const t0=performance.now();
    genWorker.onmessage = ev=>{
      const m=ev.data;

      if(m.type==='live' && $("#mapEnabled").checked){
        g_lastLive = m.arr || [];
        const sNow = (m.assigned|0) || g_lastLive.length;
        paintLiveOnMap(g_lastLive, sNow);
        return;
      }

      if(m.type==='progress'){
        const elapsed=(performance.now()-t0)/1000;
        const tested=m.tested||0;
        const total=m.total||0;
        const rate = tested>0 ? (tested/Math.max(0.1,elapsed)) : 0;
        let etaText = "";
        if(total>0 && rate>0){
          const rem = Math.max(0, total - tested);
          const eta = rem / rate;
          etaText = ` ¬∑ ETA ~${eta.toFixed(1)}s`;
          $("#genProg").value = Math.min(1, tested/total);
        }else{
          $("#genProg").value = Math.min(1, (m.found||0) / Math.max(1, (parseInt($("#want").value)||1)));
        }
        $("#genInfo").textContent = `Suche‚Ä¶ getestet=${tested.toLocaleString()} ¬∑ gefunden=${m.found}/${m.want} ¬∑ ${elapsed.toFixed(1)}s${etaText}`;
      }else if(m.type==='done'){
        $("#genProg").style.display="none";
        $("#genCancel").disabled=true;

        const out=m.out||[];
        if(!out.length){
          $("#results").innerHTML = '<div class="hint">(keine Treffer ‚Äì Bereich/√úberschneidung/Quoten/Hot-Optionen lockern)</div>';
          $("#resultStatus").style.display="none";
        }else{
          const hotOn = $("#useHotGroups").checked, hotGroups=g_hotGroups;
          const isHot=(arr)=>{ if(!hotOn||!hotGroups?.length) return false; const set=new Set(arr); for(const g of hotGroups){ if(g.every(v=>set.has(v))) return true; } return false; };
          const frag=document.createDocumentFragment();
          out.forEach((arr,i)=>{
            const div=document.createElement("div");
            div.className="resItem";
            const tag=isHot(arr)? ' <span class="badge hot">HOT</span>' : '';
            div.innerHTML = \`<span class="resNums">Kombi \${i+1} ‚Üí \${arr.join(" ")}\${tag}</span>
                             <button class="secondary" data-nums="\${arr.join(",")}">Tipp analysieren</button>
                             <button class="ghost" data-fav="\${arr.join(",")}">‚≠êÔ∏é Speichern</button>\`;
            frag.appendChild(div);
          });
          $("#results").innerHTML=""; $("#results").appendChild(frag);

          const elapsed=(performance.now()-t0)/1000;
          const mode = ($("#usePattern").checked ? "Muster" : "Zufall");
          const lvl = ($("#genLevel").value||"normal");
          const hardNote = (lvl==="hard") ? \` ¬∑ Ziel: \${($("#genHardBudget").value==="5"?"~5min":$("#genHardBudget").value==="10"?"~10min":"Maximum")}\` : "";
          $("#resultStatus").style.display="";
          $("#resultStatus").textContent =
            \`Ergebnisse: \${out.length}/\${$("#want").value} ¬∑ Modus: \${mode} ¬∑ Stufe: \${lvl}\${hardNote}\\n\`+
            \`Dauer: \${elapsed.toFixed(2)}s ¬∑ Archiv: \${g_draws.length} Ziehungen (Ziehungsgr√∂√üe \${g_drawSize})\`;

          // Auto-Scroll zu Ergebnisse
          scrollToNode(document.getElementById("p-results"));
        }
        $("#genInfo").textContent = "fertig";
        try{ genWorker.terminate(); }catch{} genWorker=null; URL.revokeObjectURL(url);

        // Map final updaten (falls ausgeschaltet -> kein repaint n√∂tig)
        if($("#mapEnabled").checked){
          paintLiveOnMap([], 0); // danach ‚Äûleer‚Äú (keine laufende Animation)
        }
      }
    };

    genWorker.onerror = e=>{
      $("#genProg").style.display="none";
      $("#genCancel").disabled=true;
      $("#genInfo").textContent = "Fehler: "+(e && e.message ? e.message : 'unbekannt');
      try{ genWorker.terminate(); }catch{} genWorker=null; URL.revokeObjectURL(url);
    };

    $("#genCancel").onclick=()=>{
      if(genWorker){ genWorker.terminate(); genWorker=null; }
      $("#genProg").style.display="none";
      $("#genCancel").disabled=true;
      $("#genInfo").textContent="abgebrochen";
      URL.revokeObjectURL(url);
      if($("#mapEnabled").checked) paintLiveOnMap([], 0);
    };

    // Live-Frequenz abh√§ngig von UI-Speed
    const speedSel = $("#mapSpeed").value;
    const liveEveryMs = speedSel==="fast" ? 12 : speedSel==="slow" ? 120 : 45;

    genWorker.postMessage({
      ...params,
      quotas,
      segs,
      liveEveryMs
    });
  }

  /* ===================== Live-Map Rendering ===================== */

  function paintLiveOnMap(arr, assignedCount){
    if(!$("#mapEnabled").checked) return;
    const Sval=getS();
    const cells=[...document.querySelectorAll(".cell")];

    // Reset Auswahl
    cells.forEach(c=>{
      c.classList.remove("selected");
      c.classList.remove("hotDot");
      const sm=c.querySelector("small");
      if(sm) sm.textContent=" ";
    });

    // HOT-Dots: markiere Zahlen, die in (aktuellen) Hot-Gruppen vorkommen (nur wenn aktiv)
    if($("#useHotGroups").checked && g_hotGroups.length){
      const hotSet=new Set(g_hotGroups.flat());
      hotSet.forEach(n=>{
        const el=document.querySelector(\`.cell[data-n="\${n}"]\`);
        if(el) el.classList.add("hotDot");
      });
    }

    // Aktuelle Kandidaten farblich ‚Äûselected‚Äú + Mini-Z√§hler pro 10er-Gruppe
    const g10Counts=[0,0,0,0,0,0,0];
    for(const n of arr||[]){
      const el=document.querySelector(\`.cell[data-n="\${n}"]\`);
      if(!el) continue;
      el.classList.add("selected");
      const g10=Math.floor((n-1)/10);
      g10Counts[g10]++;
    }

    // Kleinz√§hler anzeigen
    for(let g10=0; g10<7; g10++){
      const start=g10*10+1, end=Math.min(70,start+9);
      const count=g10Counts[g10]||0;
      for(let n=start;n<=end;n++){
        const el=document.querySelector(\`.cell[data-n="\${n}"] small\`);
        if(el) el.textContent = count>0 ? \`\${count}√ó\` : " ";
      }
    }

    text($("#mapAssigned"), \`\${assignedCount|0} / \${Sval}\`);
  }

  /* ===================== GO-Button ===================== */

  $("#go").addEventListener("click", ()=>{
    if(!g_draws.length){alert("Bitte Archiv laden");return;}
    const A=+$("#rangeFrom").value,B=+$("#rangeTo").value,maxOv=+$("#maxOv").value;
    if(A>B){alert("Bereich ‚ÄöVon‚Äò darf nicht gr√∂√üer als ‚ÄöBis‚Äò sein.");return;}
    const Ssize=parseInt($("#kenoType").value,10), usePat=$("#usePattern").checked;
    const hotOn=$("#useHotGroups").checked, hotMode=($("#hotMode")?$("#hotMode").value:"require");
    const hotGroups = (hotOn ? g_hotGroups : []);
    const level = $("#genLevel").value||"normal";
    const hardBudget = (level==="hard") ? hardBudgetSecondsGen($("#genHardBudget").value) : 0;

    const params = {
      A,B,S:Ssize,maxOv,
      drawsBits: buildDrawBits(A,B),
      hotOn, hotMode, hotGroups,
      want:+$("#want").value,
      level,
      budgetSec: hardBudget,
      seed:(+$("#seed").value)>>>0
    };
    if(!usePat){
      params.mode='random';
      if(level==="normal"){
        const {tries,seeds}=triesBaseForNormal(+$("#tries").value);
        params.triesTarget=tries;
        params.seedSweep=seeds;
      }else if(level==="medium"){
        params.triesTarget = Math.max(+$("#tries").value*6, +$("#tries").value+100_000);
        params.seedSweep=2;
      }else{ // hard ‚Üí budgetSec nutzt Warmup-Rate
        params.triesTarget = 0;
        params.seedSweep=1;
      }
    }else{
      params.mode='pattern';
      params.gaps = g_pattern.slice();
    }

    // Status & Ergebnisse zur√ºcksetzen
    $("#genInfo").textContent = \`Starte‚Ä¶ (Modus: \${params.mode==='pattern'?'Muster':'Zufall'}, S=\${Ssize}, Bereich \${A}‚Äì\${B}, maxOv ‚â§ \${maxOv}, Stufe=\${level}\${level==='hard'?(params.budgetSec===Infinity?' ¬∑ Maximum':' ¬∑ Zielzeit ~'+(params.budgetSec/60)+'min'):''})\`;
    $("#results").innerHTML=""; $("#resultStatus").style.display="none";

    // Map im Start leeren
    if($("#mapEnabled").checked) paintLiveOnMap([], 0);

    startGenerateInWorker(params);
  });

  /* ===================== Tipp-Analyse ===================== */

  function analyzeTipArray(arr){
    if(!g_draws.length){alert("Bitte Archiv laden");return;}
    const A=+$("#rangeFrom").value,B=+$("#rangeTo").value;
    const thrA=Math.max(1,Math.min(20, +($("#thrA").value||7)));
    const thrBVal=String($("#thrB").value||"").trim();
    const thrB=thrBVal? Math.max(1,Math.min(20, +thrBVal)) : null;

    const tip=arr.filter(v=>v>=A&&v<=B).sort((x,y)=>x-y);
    let maxOvSeen=0,cA=0,cB=0,cFull=0;
    for(const dr of g_draws){
      let i=0,j=0,ov=0;
      while(i<tip.length && j<dr.length){
        if(tip[i]===dr[j]){ov++;i++;j++;}
        else if(tip[i]<dr[j]) i++; else j++;
      }
      if(ov>maxOvSeen) maxOvSeen=ov;
      if(ov>=thrA) cA++;
      if(thrB!==null && ov>=thrB) cB++;
      if(ov===tip.length) cFull++;
    }

    // Markiere HOT Treffer
    const hits=matchedHotGroups(tip);
    const hotSet=new Set(hits.flat());
    const tipHTML = tip.map(n=> hotSet.has(n) ? \`<span class="hotnum">\${n}</span>\` : String(n)).join(" ");

    const out=[];
    out.push('Tipp: '+tipHTML);
    out.push('S='+tip.length);
    out.push(\`Max √úberschneidung im Archiv = \${maxOvSeen} (Einstellung maxOv = \${$("#maxOv").value})\`);
    out.push('Ziehungen mit ‚â•'+thrA+': '+cA);
    if(thrB!==null) out.push('Ziehungen mit ‚â•'+thrB+': '+cB);
    out.push('Komplett enthalten: '+(cFull?('Ja ('+cFull+'x)'):'Nein'));
    out.push('Archiv: '+g_draws.length+' Ziehungen (Ziehungsgr√∂√üe '+g_drawSize+')');
    if($("#useHotGroups").checked && g_hotGroups.length){
      const kNow=g_hotMeta.k;
      out.push('Hot-Treffer (k='+kNow+'): '+hits.length+(hits.length? ' ‚Äì '+hits.slice(0,30).map(g=>'('+g.join('-')+')').join(', ')+(hits.length>30?' ‚Ä¶':'') : ''));
    }
    $("#tipStatus").style.display=""; $("#tipStatus").innerHTML=out.join("<br>");
    scrollToNode(document.getElementById("p-analyse")||document.body);
    $("#tipInput").value=tip.join(" ");

    // Live-Map zeigt den Tipp auch (wenn aktiv)
    if($("#mapEnabled").checked) paintLiveOnMap(tip, tip.length);
  }

  $("#checkTip").addEventListener("click",()=>{
    if(!g_draws.length){alert("Bitte Archiv laden");return;}
    const raw=String($("#tipInput").value||"").trim();
    let nums=(raw.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    nums=uniqSorted(nums);
    if(!nums.length){alert("Kein g√ºltiger Tipp");return;}
    analyzeTipArray(nums);
  });

  // Analyse & Favoriten-Buttons aus Ergebnissen
  $("#results").addEventListener("click",(e)=>{
    const btn=e.target.closest("button[data-nums],button[data-fav]");
    if(!btn) return;
    if(btn.hasAttribute("data-nums")){
      const nums=btn.getAttribute("data-nums").split(",").map(x=>parseInt(x,10)).filter(Number.isInteger);
      scrollToNode(document.getElementById("p-analyse")||document.body);
      setTimeout(()=>analyzeTipArray(nums), 150);
    }else if(btn.hasAttribute("data-fav")){
      const nums=btn.getAttribute("data-fav").split(",").map(x=>parseInt(x,10)).filter(Number.isInteger);
      const usePat=$("#usePattern").checked;
      const patNote = usePat && g_pattern.length ? \` (Muster: [\${g_pattern.join(", ")}])\` : "";
      const ask=prompt("Notiz (optional):","") || "";
      addFavorite(nums, (ask||"")+patNote);
    }
  });

  /* ===================== Favoriten ===================== */

  function nowTS(){ return new Date().toISOString(); }
  function loadFavs(){ try{ const raw=localStorage.getItem(FAV_KEY); return raw? JSON.parse(raw):[]; }catch{ return []; } }
  function saveFavs(arr){ try{ localStorage.setItem(FAV_KEY, JSON.stringify(arr)); }catch{} }
  function addFavorite(numbers, note){
    numbers = uniqSorted(numbers||[]);
    const favs=loadFavs();
    favs.push({numbers, note: (note||"").trim(), ts: nowTS()});
    saveFavs(favs);
    renderFavorites();
  }
  function renderFavorites(){
    const favs=loadFavs().slice().reverse();
    const box=$("#favList"); box.innerHTML="";
    if($("#favList").style.display==="none") return;
    if(!favs.length){ box.innerHTML='<div class="hint">(keine Favoriten)</div>'; return; }
    for(const f of favs){
      const div=document.createElement("div");
      div.className="favCard";
      div.innerHTML=\`
        <div class="favHead">
          <div class="favNums mono">\${f.numbers.join(" ")}</div>
          <div class="favBtns">
            <button class="secondary" data-act="analyze" data-nums="\${f.numbers.join(",")}">Analysieren</button>
            <button class="danger" data-act="del" data-ts="\${f.ts}">L√∂schen</button>
          </div>
        </div>
        <div class="favNote">\${(f.note||"")?f.note:"(ohne Notiz)"}</div>
      \`;
      box.appendChild(div);
    }
  }
  $("#favExport").addEventListener("click", ()=>{
    const data = JSON.stringify(loadFavs(), null, 2);
    const blob = new Blob([data],{type:"application/json"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download="keno_favoriten.json"; a.click();
    setTimeout(()=>URL.revokeObjectURL(url),500);
  });
  $("#favImportFile").addEventListener("change", async ()=>{
    const f=$("#favImportFile").files[0]; if(!f) return;
    try{
      const txt=await f.text(); const arr=JSON.parse(txt); if(!Array.isArray(arr)) throw 0;
      saveFavs(arr); renderFavorites();
    }catch{ alert("Ung√ºltige JSON-Datei"); }
  });
  $("#favClear").addEventListener("click", ()=>{ if(confirm("Wirklich alle Favoriten l√∂schen?")){ saveFavs([]); renderFavorites(); }});
  $("#favList").addEventListener("click", (e)=>{
    const btn=e.target.closest("button[data-act]"); if(!btn) return;
    const act=btn.dataset.act;
    if(act==="analyze"){
      const nums=btn.getAttribute("data-nums").split(",").map(x=>parseInt(x,10)).filter(Number.isInteger);
      scrollToNode(document.getElementById("p-analyse"));
      setTimeout(()=>analyzeTipArray(nums),150);
    }else if(act==="del"){
      const ts=btn.getAttribute("data-ts");
      const favs=loadFavs().filter(f=>f.ts!==ts);
      saveFavs(favs); renderFavorites();
    }
  });
  $("#favToggle").addEventListener("click", ()=>{
    const box=$("#favList");
    const vis = box.style.display!=="none";
    box.style.display = vis? "none":"";
    localStorage.setItem(FAV_VISIBLE_KEY, vis? "0":"1");
    if(!vis) renderFavorites();
  });
  $("#saveTipFav").addEventListener("click", ()=>{
    const raw=String($("#tipInput").value||"").trim();
    const nums=(raw.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    if(!nums.length){ alert("Kein Tipp im Feld."); return; }
    const usePat=$("#usePattern").checked;
    const patNote = usePat && g_pattern.length ? \` (Muster: [\${g_pattern.join(", ")}])\` : "";
    const note=prompt("Notiz (optional):","") || "";
    addFavorite(nums, note + patNote);

    // Map zeigt den gespeicherten Tipp (falls aktiv)
    if($("#mapEnabled").checked) paintLiveOnMap(uniqSorted(nums), uniqSorted(nums).length);
  });

  /* ===================== CSV speichern ===================== */
  $("#save").addEventListener("click",()=>{
    let items=[...document.querySelectorAll("#results .resItem .resNums")].map(el=>{
      const m=(el.textContent||"").match(/^Kombi\\s+\\d+\\s+‚Üí\\s+(.*)$/);
      return m? m[1].trim().replace(/\\s+/g,",") : null;
    }).filter(Boolean);
    if(!items.length){
      const textAll=$("#results").textContent||"";
      items=textAll.split("\\n").map(line=>{
        const m=line.match(/^Kombi\\s+(\\d+)\\s+‚Üí\\s+(.*)$/); if(!m) return null;
        return m[2].trim().replace(/\\s+/g,",");
      }).filter(Boolean);
    }
    if(!items.length){alert("Keine Ergebnisse.");return;}
    const cols=items[0].split(",").length;
    const header="nr,"+Array.from({length:cols},(_,i)=>"feld"+(i+1)).join(",");
    const lines=items.map((row,i)=> (i+1)+","+row);
    const blob=new Blob([header+"\\n"+lines.join("\\n")],{type:"text/csv;charset=utf-8"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download="kombinationen.csv"; a.click();
    setTimeout(()=>URL.revokeObjectURL(url),500);
  });
    /* ===================== Hot-Gruppen UI-Refresh ===================== */
  function toggleHotBox(){
    const on=$("#useHotGroups").checked;
    $("#hotBox").style.display=on?"":"none";
    text($("#hotInfo"), on?"bereit":"inaktiv");
  }

  $("#useHotGroups").addEventListener("change", ()=>{
    toggleHotBox();
    if($("#useHotGroups").checked) recomputeHotGroups();
    // Map sofort mit HOT-Dots neu malen (falls aktiv)
    if($("#mapEnabled").checked) paintLiveOnMap(g_lastLive||[], (g_lastLive||[]).length);
  });

  // √Ñnderungen an Hot-Parametern triggern Neuberechnung
  ["hotWindow","hotK","hotTopN","hotMode","searchLevel","hotHardBudget"].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    el.addEventListener("change", ()=>{
      if($("#useHotGroups").checked) recomputeHotGroups();
      if($("#mapEnabled").checked) paintLiveOnMap(g_lastLive||[], (g_lastLive||[]).length);
    });
  });

  $("#hotStart").addEventListener("click", ()=>{
    if($("#useHotGroups").checked) recomputeHotGroups();
  });

  $("#hotCancel").addEventListener("click", ()=>{
    // Handler wird schon im recomputeHotGroups gesetzt ‚Äì hier nur Fallback
    text($("#hotInfo"),"abgebrochen");
  });

  /* ===================== Map sofort bei Init syncen ===================== */
  if($("#mapEnabled").checked){
    paintLiveOnMap([], 0);
  }

})(); // Ende IIFE
</script>
</body>
</html>