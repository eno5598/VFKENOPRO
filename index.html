<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Keno Explorer</title>
<style>
  :root{
    --bg:#0f1115;--bg2:#141822;--panel:#1a2030;--muted:#93a1b3;
    --text:#e7ebf3;--accent:#6aa7ff;--accent2:#4bd4c6;--danger:#ff6a6a;--ok:#7dffa8;
    --warn:#ffd764;--border:#273047;--chip:#20283a;--chipOn:#2a3a55;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0d1016 0%, #0f1115 100%);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  h1,h2,h3{margin:0 0 .5rem 0;font-weight:600}
  h1{font-size:1.35rem}
  h2{font-size:1.05rem;color:#dfe7ff}
  h3{font-size:.95rem;color:#cbd6f5}
  a{color:var(--accent)}
  .app{max-width:1100px;margin:0 auto;padding:18px}
  .grid{display:grid;gap:12px}
  .cols-2{grid-template-columns: 1.1fr .9fr}
  .cols-3{grid-template-columns: 1fr 1fr 1fr}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .grow{flex:1}
  .muted{color:var(--muted)}
  .kbd{padding:2px 6px;border:1px solid var(--border);border-radius:6px;background:var(--bg2);color:#cfe1ff}
  input,select,button,textarea{
    background:#121826;border:1px solid var(--border);color:var(--text);
    border-radius:10px;padding:10px 12px;font:inherit;outline:none;transition:border .15s ease, background .2s ease;
  }
  input:focus,select:focus,textarea:focus{border-color:#3a5ba9;background:#0f1522}
  button{background:#1b2944;border:1px solid #2e3e63;cursor:pointer}
  button:hover{filter:brightness(1.07)}
  button:disabled{opacity:.55;cursor:not-allowed}
  .btn-ok{background:linear-gradient(180deg,#1c3a4f,#1a2a45);border-color:#2e4f7a}
  .btn-danger{background:#3a1c26;border-color:#7d3147}
  .chip{padding:6px 10px;border-radius:999px;background:var(--chip);border:1px solid var(--border);font-size:.9rem}
  .chip.on{background:var(--chipOn);border-color:#3a4b75}
  .tag{display:inline-block;padding:3px 8px;border-radius:7px;background:#1e2636;border:1px solid #2e3a55;color:#cfe1ff;font-size:.85rem}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  .small{font-size:.9rem}
  .section-title{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .divider{height:1px;background:linear-gradient(90deg,transparent,#29324a,transparent);margin:10px 0}
  .canvas-wrap{position:relative;border-radius:12px;overflow:hidden;border:1px solid var(--border)}
  canvas{display:block;width:100%;height:auto;background:#0c0f16}
  .status{white-space:pre-wrap;background:#0e1320;border:1px dashed #2a3555;border-radius:10px;padding:10px;color:#c9d5ff}
  .pill{padding:4px 8px;border:1px solid var(--border);border-radius:999px;background:#161c2b}
  .list{display:grid;gap:10px}
  .card{background:#121826;border:1px solid #223050;border-radius:10px;padding:10px}
  .nums{display:flex;flex-wrap:wrap;gap:6px}
  .ball{min-width:28px;padding:4px 8px;border-radius:999px;background:#1b2030;border:1px solid #2b3657;text-align:center}
  .ball.best{background:#1e2c4a;border-color:#3a5ba9}
  .ball.hl{background:#16333a;border-color:#2c6b6f}
  .x{color:var(--danger);filter:drop-shadow(0 0 5px rgba(255,60,60,.15))}
  .sticky-footer{position:sticky;bottom:0;margin-top:14px;background:linear-gradient(180deg, rgba(15,17,21,.0), rgba(15,17,21,1) 35%);padding-top:10px}
  .note{color:#9db2d7}
</style>
</head>
<body>
<div class="app">
  <div class="section-title">
    <h1>Keno Explorer <span class="muted small">— Single-File Web-App (Dark)</span></h1>
    <div class="row">
      <span id="stateBadge" class="chip">idle</span>
      <button id="btnClear" class="btn-danger">Archiv löschen</button>
    </div>
  </div>

  <div class="grid cols-2">
    <!-- Archiv -->
    <section class="panel">
      <div class="section-title">
        <h2>Archiv laden & speichern</h2>
        <span class="muted small">CSV/TXT/ZIP/JSON • IndexedDB • Export</span>
      </div>
      <div class="row">
        <input id="fileInput" type="file" accept=".csv,.txt,.zip,.json" />
        <button id="btnExportCsv">CSV exportieren</button>
        <button id="btnExportJson">Snapshot (.json)</button>
      </div>
      <div class="divider"></div>
      <div class="row">
        <div class="pill">Zeichnungen: <span id="metaDraws">—</span></div>
        <div class="pill">Datum: <span id="metaDateRange">—</span></div>
        <div class="pill">Pick-Size: <span id="metaPick">—</span></div>
        <div class="pill">Persistenz: <span id="metaStore">—</span></div>
      </div>
      <div style="margin-top:10px" class="status small" id="statusBox">Bereit.</div>
    </section>

    <!-- Live-Map -->
    <section class="panel">
      <div class="section-title">
        <h2>Live-Map (1–70)</h2>
        <div class="row">
          <label class="small muted">Gruppen</label>
          <select id="groupMode">
            <option value="7">7er (1–10, …, 61–70)</option>
            <option value="5">5er</option>
            <option value="3">3er</option>
          </select>
          <label class="small muted">Range</label>
          <input id="rangeMin" type="number" min="1" max="70" value="1" style="width:80px" />
          <span class="muted small">–</span>
          <input id="rangeMax" type="number" min="1" max="70" value="70" style="width:80px" />
        </div>
      </div>
      <div class="canvas-wrap"><canvas id="map" width="1000" height="700"></canvas></div>
      <div class="row" style="margin-top:8px">
        <input id="analyzeInput" class="grow mono" placeholder="Variante analysieren (z.B. 2 7 14 28 …)" />
        <button id="btnAnalyzeInput">Analysieren</button>
      </div>
      <div class="small note" style="margin-top:6px">
        Live: Tippen → blaue Markierung • Generator → grün • Range außerhalb → <span class="x">❌</span>
      </div>
    </section>
  </div>

  <div class="grid cols-2" style="margin-top:12px">
    <!-- Gruppen & Zielverteilung -->
    <section class="panel">
      <div class="section-title">
        <h2>Gruppen & Zielverteilung</h2>
        <span class="muted small">Summe muss = S (Pick-Size)</span>
      </div>
      <div id="groupTargets" class="row"></div>
      <div class="row" style="margin-top:8px">
        <button id="btnEven">Gleich verteilen</button>
        <button id="btnFromArchive">Nach Archiv</button>
        <div class="pill">Summe: <span id="targetSum">0</span> / S=<span id="targetS">—</span></div>
      </div>
    </section>

    <!-- Generator -->
    <section class="panel">
      <div class="section-title">
        <h2>Generator (Suche)</h2>
        <span class="muted small">Diversität • Scoring • Zeitlimit</span>
      </div>
      <div class="row">
        <label class="small muted">Modus</label>
        <select id="mode">
          <option value="normal">normal</option>
          <option value="medium">mittel</option>
          <option value="hard">hard</option>
          <option value="ultra">Ultra++</option>
        </select>
        <label class="small muted">Top-N</label>
        <select id="topN">
          <option>1</option><option>3</option><option selected>6</option><option>10</option>
        </select>
        <label class="small muted">Zeit</label>
        <select id="timeLimit">
          <option value="15">15s</option>
          <option value="60" selected>1m</option>
          <option value="180">3m</option>
          <option value="0">offen</option>
        </select>
      </div>
      <div class="row">
        <label class="chip"><input type="checkbox" id="scorePairs" checked> Paare</label>
        <label class="chip"><input type="checkbox" id="scoreTriples"> Triples</label>
        <label class="chip"><input type="checkbox" id="scoreGaps" checked> Gaps</label>
        <label class="chip"><input type="checkbox" id="mmr" checked> MMR-Auswahl</label>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="btnStart" class="btn-ok">Start</button>
        <button id="btnStop" class="btn-danger" disabled>Stop</button>
        <span class="muted small">Status:</span>
        <span id="progress" class="chip">—</span>
      </div>
    </section>
  </div>

  <div class="grid cols-2" style="margin-top:12px">
    <!-- Ergebnisse -->
    <section class="panel" id="resultsPanel">
      <div class="section-title">
        <h2>Ergebnisse</h2>
        <span class="muted small">Top-Kombis (divers)</span>
      </div>
      <div id="results" class="list"></div>
    </section>

    <!-- Analyse -->
    <section class="panel" id="analysisPanel">
      <div class="section-title">
        <h2>Analyse</h2>
        <span class="muted small">Kenotyp, S-1 & Histogramm</span>
      </div>
      <div id="analysis" class="list small"></div>
    </section>
  </div>

  <div class="sticky-footer">
    <div class="muted small">Tipps: <span class="kbd">⌘/Ctrl</span>+<span class="kbd">V</span> Datei droppen • Zahlen getrennt durch Leerzeichen/Kommata • Nur JSZip als externe Abhängigkeit bei ZIP</div>
  </div>
</div>

<!-- ==== TEIL 2 HIER EINFÜGEN ==== -->
<script>
/* =========================================================
   Keno Explorer – Single-file JS (Worker + IDB + ZIP + Canvas)
   ========================================================= */

(() => {
  /* ------------------------ Utilities ------------------------ */
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const byNumAsc = (a,b)=>a-b;
  const sum = arr => arr.reduce((a,b)=>a+b,0);
  const uniqKey = a => a.slice().sort(byNumAsc).join(',');
  const nowIso = () => new Date().toISOString();

  const state = {
    storeName: 'keno-archive',
    archive: null, // {meta, draws:[{date:'YYYY-MM-DD', nums:[...20]}], pick:20, freq:[71], pairs, triples, gaps}
    analyzeLive: new Set(),
    worker: null,
    running: false,
    currentCandidate: new Set(),
    groupMode: 7,
    rangeMin: 1,
    rangeMax: 70,
    groupTargets: [], // per group count target
  };

  /* ------------------------ Storage (IDB + fallback) ------------------------ */
  const idb = {
    db: null,
    async open(){
      return new Promise((resolve,reject)=>{
        const req = indexedDB.open('KenoExplorerDB',1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(state.storeName)){
            db.createObjectStore(state.storeName);
          }
        };
        req.onsuccess = ()=>{ this.db=req.result; resolve(); };
        req.onerror = ()=>reject(req.error);
      });
    },
    async set(key, val){
      if(!this.db) return localStorage.setItem(key, JSON.stringify(val));
      return new Promise((resolve,reject)=>{
        const tx = this.db.transaction(state.storeName,'readwrite');
        tx.objectStore(state.storeName).put(val, key);
        tx.oncomplete = resolve; tx.onerror = ()=>reject(tx.error);
      });
    },
    async get(key){
      if(!this.db){ const s = localStorage.getItem(key); return s?JSON.parse(s):null; }
      return new Promise((resolve,reject)=>{
        const tx = this.db.transaction(state.storeName,'readonly');
        const req = tx.objectStore(state.storeName).get(key);
        req.onsuccess = ()=>resolve(req.result||null);
        req.onerror = ()=>reject(req.error);
      });
    },
    async del(key){
      if(!this.db){ localStorage.removeItem(key); return; }
      return new Promise((resolve,reject)=>{
        const tx = this.db.transaction(state.storeName,'readwrite');
        tx.objectStore(state.storeName).delete(key);
        tx.oncomplete=resolve; tx.onerror=()=>reject(tx.error);
      });
    }
  };

  /* ------------------------ Status & UI helpers ------------------------ */
  const el = {
    status: $('#statusBox'),
    map: $('#map'),
    groupModeSel: $('#groupMode'),
    rangeMin: $('#rangeMin'),
    rangeMax: $('#rangeMax'),
    analyzeInput: $('#analyzeInput'),
    analyzeBtn: $('#btnAnalyzeInput'),
    results: $('#results'),
    analysis: $('#analysis'),
    groupTargets: $('#groupTargets'),
    btnEven: $('#btnEven'),
    btnFromArchive: $('#btnFromArchive'),
    targetSum: $('#targetSum'),
    targetS: $('#targetS'),
    btnStart: $('#btnStart'),
    btnStop: $('#btnStop'),
    progress: $('#progress'),
    topN: $('#topN'),
    mode: $('#mode'),
    chkPairs: $('#scorePairs'),
    chkTriples: $('#scoreTriples'),
    chkGaps: $('#scoreGaps'),
    chkMMR: $('#mmr'),
    fileInput: $('#fileInput'),
    btnExportCsv: $('#btnExportCsv'),
    btnExportJson: $('#btnExportJson'),
    btnClear: $('#btnClear'),
    metaDraws: $('#metaDraws'),
    metaDateRange: $('#metaDateRange'),
    metaPick: $('#metaPick'),
    metaStore: $('#metaStore'),
    stateBadge: $('#stateBadge'),
    resultsPanel: $('#resultsPanel'),
    analysisPanel: $('#analysisPanel'),
  };

  function setStatus(msg, tone='info'){
    el.status.textContent = msg;
    if(tone==='error') el.status.style.borderColor = '#7d3147';
    else if(tone==='warn') el.status.style.borderColor = '#7a6a2e';
    else el.status.style.borderColor = '#2a3555';
  }
  function setRunning(running){
    state.running = running;
    el.stateBadge.textContent = running ? 'running' : 'idle';
    el.btnStart.disabled = running || !isStartEnabled();
    el.btnStop.disabled = !running;
  }

  /* ------------------------ Groups & coloring ------------------------ */
  function groupsFor(mode){
    const g = [];
    if(mode===7){
      for(let i=0;i<7;i++) g.push([i*10+1, i*10+10]);
    } else if(mode===5){
      // 5 groups of 14 numbers: 1–14, 15–28, ...
      for(let i=0;i<5;i++) g.push([i*14+1, i*14+14]);
    } else { // 3
      for(let i=0;i<3;i++) g.push([i*23+1, i===2?70:(i*23+23)]);
    }
    return g;
  }
  function groupIndexOf(n, mode){
    const gs = groupsFor(mode);
    for(let i=0;i<gs.length;i++){
      const [a,b] = gs[i]; if(n>=a && n<=b) return i;
    }
    return -1;
  }
  function colorForGroup(i,total){
    // pleasant, muted palette; consistent across modes
    const hues = [210, 195, 180, 165, 150, 135, 120];
    const h = hues[i % hues.length];
    return `hsl(${h} 30% 18%)`;
  }

  /* ------------------------ Canvas Map ------------------------ */
  const ctx = el.map.getContext('2d');
  function drawMap(){
    const W = el.map.width, H = el.map.height;
    ctx.clearRect(0,0,W,H);
    // background grid coloring by group
    const mode = state.groupMode;
    const cellW = W/10, cellH=H/7;
    for(let r=0;r<7;r++){
      for(let c=0;c<10;c++){
        const n = r*10 + (c+1);
        const gi = groupIndexOf(n, mode);
        ctx.fillStyle = colorForGroup(gi, groupsFor(mode).length);
        ctx.fillRect(c*cellW, r*cellH, cellW, cellH);
      }
    }
    // grid lines
    ctx.strokeStyle = '#2a3247'; ctx.lineWidth = 1;
    for(let i=0;i<=10;i++){ ctx.beginPath(); ctx.moveTo(i*cellW,0); ctx.lineTo(i*cellW,H); ctx.stroke(); }
    for(let i=0;i<=7;i++){ ctx.beginPath(); ctx.moveTo(0,i*cellH); ctx.lineTo(W,i*cellH); ctx.stroke(); }

    // number labels
    ctx.fillStyle = '#cfe1ff';
    ctx.font = '14px system-ui, sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    for(let r=0;r<7;r++){
      for(let c=0;c<10;c++){
        const x=c*cellW+cellW/2, y=r*cellH+cellH/2;
        const n = r*10 + (c+1);
        let labelCol = '#cfe1ff';
        // Range outside?
        if(n < state.rangeMin || n > state.rangeMax){
          labelCol = '#ff6a6a';
        }
        // base text
        ctx.fillStyle = labelCol;
        ctx.fillText(String(n), x, y);
        // Range mark ❌
        if(n < state.rangeMin || n > state.rangeMax){
          ctx.fillText('❌', x, y-16);
        }
      }
    }

    // highlights: analyze (blue-ish), worker current (green-ish)
    function drawSet(s, color, radius=18){
      ctx.save();
      ctx.strokeStyle = color; ctx.lineWidth = 3;
      for(const n of s){
        const idx = n-1; const r = Math.floor(idx/10), c = idx%10;
        const x=c*cellW+cellW/2, y=r*cellH+cellH/2;
        ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.stroke();
      }
      ctx.restore();
    }
    if(state.currentCandidate.size>0) drawSet(state.currentCandidate,'#4bd4c6aa',20);
    if(state.analyzeLive.size>0) drawSet(state.analyzeLive,'#6aa7ffaa',20);
  }

  /* ------------------------ Parsing ------------------------ */
  function parseNumbersLine(line){
    // Accept "1 4 7 ..." or "1,4,7" or "1;4;7"
    const parts = line.trim().split(/[^\d]+/).filter(Boolean);
    const nums = parts.map(x=>parseInt(x,10)).filter(n=>n>=1 && n<=70);
    return nums;
  }

  function detectPickSize(lines){
    const lengths = {};
    for(const ln of lines){
      const ns = parseNumbersLine(ln);
      if(ns.length>=5 && ns.length<=20){
        lengths[ns.length] = (lengths[ns.length]||0)+1;
      }
    }
    let bestL=0,bestC=-1;
    for(const [k,v] of Object.entries(lengths)){
      if(v>bestC){bestC=v;bestL=parseInt(k,10);}
    }
    return bestL || 20;
  }

  function parseCSVorTXT(text){
    // Try header with "Zahl1..Zahl20" and possibly date columns
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
    if(lines.length===0) throw new Error('Keine gültigen Zahlen erkannt.');
    const pick = detectPickSize(lines.slice(0,200));
    const draws = [];
    for(const ln of lines){
      const ns = parseNumbersLine(ln);
      if(ns.length===pick){
        draws.push({date:null, nums:ns.sort(byNumAsc)});
      } else {
        // maybe TSV with header; try to pick only Zahl1..ZahlX
        const parts = ln.split(/[\t;,]+/).map(x=>x.trim());
        const onlyNums = parts.map(p=>parseInt(p,10)).filter(n=>!isNaN(n) && n>=1 && n<=70);
        if(onlyNums.length===pick) draws.push({date:null, nums:onlyNums.sort(byNumAsc)});
      }
    }
    if(draws.length===0) throw new Error('Keine gültigen Zahlen erkannt.');
    return {draws, pick};
  }

  async function loadJSZip(){
    if(window.JSZip) return;
    await new Promise((resolve, reject)=>{
      const s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
      s.onload=resolve; s.onerror=()=>reject(new Error('JSZip konnte nicht geladen werden.'));
      document.head.appendChild(s);
    });
  }

  async function parseZIP(file){
    await loadJSZip();
    const buf = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(buf);
    // score files: prefer names including keno/archiv, and larger size
    let bestFile=null, bestScore=-Infinity;
    await Promise.all(Object.values(zip.files).map(async f=>{
      if(f.dir) return;
      const name = f.name.toLowerCase();
      const ext = name.split('.').pop();
      if(!['csv','txt','tsv'].includes(ext)) return;
      let sc = 0;
      if(name.includes('keno')) sc+=50;
      if(name.includes('archiv')) sc+=20;
      sc += (f._data.uncompressedSize||0)/1024; // size in KB
      if(sc>bestScore){bestScore=sc; bestFile=f;}
    }));
    if(!bestFile) throw new Error('Keine passende Datei im ZIP gefunden.');
    const text = await bestFile.async('string');
    return parseCSVorTXT(text);
  }

  /* ------------------------ Frequenzen & Stats ------------------------ */
  function computeStats(draws, pick){
    const freq = Array(71).fill(0);
    const pairFreq = new Map(); // "a,b" a<b
    const tripleFreq = new Map(); // "a,b,c"
    const gapHist = Array(70).fill(0); // distances 1..69 across sorted nums
    const fmtKey2 = (a,b)=> a<b? `${a},${b}` : `${b},${a}`;
    const fmtKey3 = (a,b,c)=> [a,b,c].sort(byNumAsc).join(',');

    for(const d of draws){
      const arr = d.nums;
      for(const n of arr) freq[n]++;
      // pairs
      for(let i=0;i<arr.length;i++){
        for(let j=i+1;j<arr.length;j++){
          const k=fmtKey2(arr[i],arr[j]);
          pairFreq.set(k, (pairFreq.get(k)||0)+1);
        }
      }
      // triples (sampled to limit blowup if huge)
      if(draws.length<=12000 || Math.random()<0.35){
        for(let i=0;i<arr.length;i++){
          for(let j=i+1;j<arr.length;j++){
            for(let k=j+1;k<arr.length;k++){
              const key=fmtKey3(arr[i],arr[j],arr[k]);
              tripleFreq.set(key,(tripleFreq.get(key)||0)+1);
            }
          }
        }
      }
      // gaps
      for(let i=1;i<arr.length;i++){
        const g = arr[i]-arr[i-1];
        if(g>0 && g<gapHist.length) gapHist[g]++;
      }
    }
    // smooth gaps (simple 3-wide)
    const sm = gapHist.slice();
    for(let i=1;i<gapHist.length-1;i++){
      sm[i] = (gapHist[i-1]+gapHist[i]+gapHist[i+1])/3;
    }
    return {freq, pairFreq, tripleFreq, gapHist: sm};
  }

  function normalizeScore(v, minV, maxV){
    if(maxV===minV) return 0.5;
    return (v-minV)/(maxV-minV);
  }

  /* ------------------------ Exports ------------------------ */
  function exportCsv(archive){
    const rows = [];
    const header = ['date', ...Array.from({length:archive.pick}, (_,i)=>`zahl${i+1}`)];
    rows.push(header.join(','));
    for(const d of archive.draws){
      rows.push([d.date||'', ...d.nums].join(','));
    }
    const blob = new Blob([rows.join('\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'keno_normalized.csv';
    a.click();
    URL.revokeObjectURL(a.href);
  }
  function exportSnapshot(archive){
    const meta = {created: nowIso(), pick: archive.pick, draws: archive.draws.length};
    const obj = {meta, freq: archive.freq, range:[state.rangeMin,state.rangeMax]};
    const blob = new Blob([JSON.stringify(obj,null,2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'keno_snapshot.json';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  /* ------------------------ UI: Group targets ------------------------ */
  function buildGroupTargets(){
    const mode = state.groupMode;
    const groups = groupsFor(mode);
    el.groupTargets.innerHTML = '';
    state.groupTargets = groups.map(()=>0);
    groups.forEach((range, idx)=>{
      const wrap = document.createElement('div'); wrap.className='row';
      wrap.style.background='#101625'; wrap.style.border='1px solid #263252';
      wrap.style.borderRadius='10px'; wrap.style.padding='6px 8px';
      const label = document.createElement('div');
      label.className='tag';
      label.textContent = `G${idx+1} ${range[0]}–${range[1]}`;
      const input = document.createElement('input');
      input.type='number'; input.min='0'; input.value='0'; input.style.width='90px';
      input.addEventListener('input', ()=>{
        state.groupTargets[idx] = parseInt(input.value||'0',10);
        updateTargetSum();
      });
      wrap.append(label,input);
      el.groupTargets.appendChild(wrap);
    });
    updateTargetSum();
  }
  function updateTargetSum(){
    const s = sum(state.groupTargets);
    el.targetSum.textContent = String(s);
    el.targetS.textContent = state.archive? state.archive.pick : '—';
    el.btnStart.disabled = !isStartEnabled();
  }
  function isStartEnabled(){
    if(!state.archive) return false;
    return sum(state.groupTargets) === state.archive.pick;
  }

  /* ------------------------ Live analyze input ------------------------ */
  function parseNumbersFromFreeText(s){
    const ns = s.split(/[^\d]+/).filter(Boolean).map(x=>parseInt(x,10))
                .filter(n=>n>=1 && n<=70);
    // unique:
    return Array.from(new Set(ns)).slice(0, state.archive?state.archive.pick:20);
  }

  el.analyzeInput.addEventListener('input', ()=>{
    const ns = parseNumbersFromFreeText(el.analyzeInput.value);
    state.analyzeLive = new Set(ns);
    state.currentCandidate.clear(); // ensure no overlay confusion
    drawMap();
  });
  el.analyzeBtn.addEventListener('click', ()=>{
    const ns = parseNumbersFromFreeText(el.analyzeInput.value);
    if(ns.length===0){ setStatus('Keine gültigen Zahlen erkannt.', 'warn'); return; }
    analyzeVariant(ns);
    // scroll to analysis
    $('#analysisPanel').scrollIntoView({behavior:'smooth', block:'nearest'});
  });

  /* ------------------------ Worker (blob) ------------------------ */
  function createWorker(){
    const code = `
      let archive=null;
      function randInt(a,b){return Math.floor(Math.random()*(b-a+1))+a;}
      const byAsc=(a,b)=>a-b;
      const uniq = a => Array.from(new Set(a));
      const uniqKey = a => a.slice().sort(byAsc).join(',');

      function groupIndexOf(n, mode){
        if(mode===7){
          for(let i=0;i<7;i++){ const a=i*10+1,b=i*10+10; if(n>=a&&n<=b) return i; }
        }else if(mode===5){
          for(let i=0;i<5;i++){ const a=i*14+1,b=i*14+14; if(n>=a&&n<=b) return i; }
        }else{
          for(let i=0;i<3;i++){ const a=i*23+1,b= i===2?70:(i*23+23); if(n>=a&&n<=b) return i; }
        }
        return -1;
      }

      function sampleCandidate(pick, rangeMin, rangeMax, groupMode, targets){
        // respect targets per group
        const groups = [];
        const counts = [];
        if(groupMode===7){ for(let i=0;i<7;i++){groups.push([i*10+1,i*10+10]);} }
        else if(groupMode===5){ for(let i=0;i<5;i++){groups.push([i*14+1,i*14+14]);} }
        else { for(let i=0;i<3;i++){groups.push([i*23+1, i===2?70:(i*23+23)]);} }
        const pickNums=[];
        for(let gi=0; gi<groups.length; gi++){
          const need = targets[gi]||0;
          for(let k=0;k<need;k++){
            // pick random available in group & in range
            let tries=0, v;
            do{
              v = randInt(groups[gi][0], groups[gi][1]);
              tries++;
              if(tries>200) break;
            }while(v<pick && (v<rangeMin || v>rangeMax) || pickNums.includes(v));
            if(v>=rangeMin && v<=rangeMax && !pickNums.includes(v)) pickNums.push(v);
          }
        }
        // fill if any missing due to range collisions
        while(pickNums.length<pick){
          const v = randInt(rangeMin, rangeMax);
          if(!pickNums.includes(v)) pickNums.push(v);
        }
        return pickNums.sort(byAsc);
      }

      function scoreCandidate(arr, conf){
        // components: singles, pairs (opt), triples (opt), gaps (opt), novelty on group signature
        // normalize by dividing through maxima observed in archive meta
        const {freq, pairFreq, tripleFreq, gapHist} = archive;
        let sSingles=0;
        for(const n of arr) sSingles += freq[n]||0;

        let sPairs=0;
        if(conf.usePairs){
          for(let i=0;i<arr.length;i++)
            for(let j=i+1;j<arr.length;j++){
              const a=arr[i], b=arr[j];
              const k = a<b? \`\${a},\${b}\` : \`\${b},\${a}\`;
              sPairs += (pairFreq[k]||0);
            }
        }

        let sTriples=0;
        if(conf.useTriples){
          for(let i=0;i<arr.length;i++)
            for(let j=i+1;j<arr.length;j++)
              for(let k=j+1;k<arr.length;k++){
                const key=[arr[i],arr[j],arr[k]].sort(byAsc).join(',');
                sTriples += (tripleFreq[key]||0);
              }
        }

        let sGaps=0;
        if(conf.useGaps){
          for(let i=1;i<arr.length;i++){
            const g = arr[i]-arr[i-1];
            sGaps += gapHist[g]||0;
          }
        }

        // novelty: penalize frequent group signatures
        const sigCounts = conf.sigCounts; // Map like "2-3-...": count
        const groups = conf.groups;
        const counts = new Array(groups.length).fill(0);
        for(const n of arr){
          const gi = groupIndexOf(n, conf.groupMode);
          counts[gi] = (counts[gi]||0)+1;
        }
        const sig = counts.join('-');
        const sigCount = (sigCounts.get(sig)||0);
        const noveltyPenalty = sigCount * conf.noveltyWeight;

        const raw = sSingles*conf.wSingles + sPairs*conf.wPairs + sTriples*conf.wTriples + sGaps*conf.wGaps;
        const score = raw - noveltyPenalty;
        return {score, sig};
      }

      function jaccard(a,b){
        let i=0,j=0, inter=0;
        while(i<a.length && j<b.length){
          if(a[i]===b[j]){ inter++; i++; j++; }
          else if(a[i]<b[j]) i++; else j++;
        }
        const union = a.length + b.length - inter;
        return union? inter/union : 0;
      }

      self.onmessage = (ev)=>{
        const {type} = ev.data;
        if(type==='init'){ archive = ev.data.archive; }
        else if(type==='run'){
          const {pick, rangeMin, rangeMax, groupMode, targets, conf, timeLimitSec, topN, mmr} = ev.data;
          const groups = [];
          if(groupMode===7){ for(let i=0;i<7;i++){groups.push([i*10+1,i*10+10]);} }
          else if(groupMode===5){ for(let i=0;i<5;i++){groups.push([i*14+1,i*14+14]);} }
          else { for(let i=0;i<3;i++){groups.push([i*23+1, i===2?70:(i*23+23)]);} }

          const tEnd = timeLimitSec>0? (Date.now()+timeLimitSec*1000) : Infinity;
          // params by mode
          const mode = conf.mode;
          const presets = {
            normal:{pop:160, iters:400, restarts:1},
            medium:{pop:260, iters:800, restarts:2},
            hard:{pop:380, iters:1400, restarts:3},
            ultra:{pop:520, iters:2200, restarts:4}
          };
          const P = presets[mode]||presets.normal;

          const sigCounts = new Map();
          const bestPool = []; // {arr, score, sig}
          function keepBest(candidate){
            bestPool.push(candidate);
            bestPool.sort((a,b)=>b.score-a.score);
            if(bestPool.length>Math.max(60, topN*8)) bestPool.length=Math.max(60, topN*8);
          }

          for(let r=0;r<P.restarts;r++){
            // population
            let pop = new Array(P.pop).fill(0).map(()=>sampleCandidate(pick, rangeMin, rangeMax, groupMode, targets));
            for(let iter=0; iter<P.iters; iter++){
              if(Date.now()>tEnd){ break; }
              const scored = pop.map(arr=>{
                const sc = scoreCandidate(arr,{...conf, groups, groupMode, sigCounts});
                sigCounts.set(sc.sig,(sigCounts.get(sc.sig)||0)+1);
                return {arr, score: sc.score, sig: sc.sig};
              }).sort((a,b)=>b.score-a.score);

              // notify a current candidate (first)
              if(iter%7===0){
                self.postMessage({type:'tick', candidate: scored[0].arr});
              }

              // select top K, mutate others
              const K = Math.max(20, Math.floor(P.pop*0.3));
              keepBest(scored[0]);
              const elites = scored.slice(0,K).map(s=>s.arr);
              const next = elites.slice();
              while(next.length<P.pop){
                // crossover + mutation
                const a = elites[randInt(0,elites.length-1)];
                const b = elites[randInt(0,elites.length-1)];
                // MMR-like parent selection: prefer dissimilar parents
                const jac = jaccard(a,b);
                const prob = jac<0.4 ? 0.7 : 0.3;
                const parent = Math.random()<prob ? a : b;
                let child = parent.slice();
                // mutation: swap or replace within group target allowances
                if(Math.random()<0.6){
                  const idx = randInt(0,child.length-1);
                  let v = randInt(rangeMin, rangeMax);
                  // nudge around parent value to respect pairs/triples context
                  if(Math.random()<0.6){
                    const base = child[idx];
                    const delta = randInt(-3,3);
                    v = Math.min(rangeMax, Math.max(rangeMin, base+delta));
                    if(v<1||v>70) v = randInt(rangeMin, rangeMax);
                  }
                  child[idx]=v;
                  child = uniq(child).sort(byAsc);
                  while(child.length<pick){
                    const add = randInt(rangeMin, rangeMax);
                    if(!child.includes(add)) child.push(add);
                    child.sort(byAsc);
                  }
                  while(child.length>pick){ child.splice(randInt(0,child.length-1),1); }
                }else{
                  // small shuffle
                  child = child.slice().sort(()=>Math.random()-.5).sort(byAsc);
                }
                next.push(child);
              }
              pop = next;
            }
            if(Date.now()>tEnd) break;
          }

          // Final selection: top by score, then diversify with MMR
          bestPool.sort((a,b)=>b.score-a.score);
          const chosen = [];
          for(const cand of bestPool){
            if(chosen.length===0){ chosen.push(cand); continue; }
            if(mmr){
              // keep if reasonably dissimilar to existing
              const minJac = Math.min(...chosen.map(c=>jaccard(c.arr, cand.arr)));
              if(minJac < 0.6) chosen.push(cand);
            }else{
              chosen.push(cand);
            }
            if(chosen.length>=topN) break;
          }
          while(chosen.length<topN && bestPool[chosen.length]) chosen.push(bestPool[chosen.length]);
          self.postMessage({type:'done', results: chosen.map(c=>({nums:c.arr, score:c.score}))});
        }
      };
    `;
    const blob = new Blob([code], {type:'text/javascript'});
    const w = new Worker(URL.createObjectURL(blob));
    w.onmessage = (ev)=>{
      const {type} = ev.data;
      if(type==='tick'){
        state.currentCandidate = new Set(ev.data.candidate);
        drawMap();
      }else if(type==='done'){
        setRunning(false);
        state.currentCandidate.clear();
        drawMap();
        renderResults(ev.data.results);
        // scroll results
        el.resultsPanel.scrollIntoView({behavior:'smooth', block:'nearest'});
      }
    };
    return w;
  }

  /* ------------------------ Results rendering ------------------------ */
  function renderResults(items){
    el.results.innerHTML = '';
    const topN = parseInt(el.topN.value,10);
    const list = items.slice(0, topN);
    for(const it of list){
      const card = document.createElement('div'); card.className='card';
      const numsWrap = document.createElement('div'); numsWrap.className='nums';
      it.nums.forEach(n=>{
        const span=document.createElement('span'); span.className='ball best'; span.textContent=String(n);
        numsWrap.appendChild(span);
      });
      const gapSeq = it.nums.slice(1).map((v,i)=>v-it.nums[i]);
      const head = document.createElement('div'); head.className='row';
      const scoreSpan = document.createElement('span'); scoreSpan.className='chip on';
      scoreSpan.textContent = `Score: ${it.score.toFixed(2)}`;
      const gapsSpan = document.createElement('span'); gapsSpan.className='chip';
      gapsSpan.textContent = `Gaps: [${gapSeq.join(', ')}]`;
      const btn = document.createElement('button'); btn.textContent='Variante analysieren';
      btn.addEventListener('click', ()=>{
        el.analyzeInput.value = it.nums.join(' ');
        state.analyzeLive = new Set(it.nums);
        drawMap();
        analyzeVariant(it.nums);
        el.analysisPanel.scrollIntoView({behavior:'smooth', block:'nearest'});
      });
      head.append(scoreSpan, gapsSpan, btn);
      card.append(numsWrap, head);
      el.results.appendChild(card);
    }
  }

  /* ------------------------ Analyse einer Variante ------------------------ */
  function analyzeVariant(nums){
    const pick = state.archive.pick;
    const key = uniqKey(nums);
    const setNums = new Set(nums);
    const counts = Array(pick+1).fill(0);
    let exact=0, sMinus1=0;
    for(const d of state.archive.draws){
      let hit=0;
      for(const n of d.nums){ if(setNums.has(n)) hit++; }
      counts[hit]++;
      if(hit===pick) exact++;
      if(hit===pick-1) sMinus1++;
    }

    const wrap = document.createElement('div'); wrap.className='card';
    const head = document.createElement('div'); head.className='row';
    head.innerHTML = `<div class="chip on">Variante</div><div class="chip mono">${nums.join(' ')}</div>`;
    const keno = document.createElement('div');
    keno.className='row';
    keno.innerHTML = `
      <span class="tag">Kenotyp: S=${pick}</span>
      <span class="chip">exakt: ${exact===0? 'noch nie exakt' : ('exakt '+exact+'×')}</span>
      <span class="chip">S-1: ${sMinus1}×</span>
    `;
    // histogram
    const hist = document.createElement('div'); hist.className='row'; hist.style.flexWrap='wrap';
    for(let k=0;k<=pick;k++){
      const chip = document.createElement('span'); chip.className='chip'; chip.textContent=`${k}: ${counts[k]}×`;
      hist.appendChild(chip);
    }
    wrap.append(head, keno, document.createElement('div'));
    wrap.children[2].appendChild(hist);
    el.analysis.prepend(wrap);
  }

  /* ------------------------ Load & Init ------------------------ */
  async function loadFromFile(file){
    try{
      setStatus('Lese Datei …');
      let parsed;
      if(file.name.toLowerCase().endsWith('.zip')){
        parsed = await parseZIP(file);
      }else if(file.name.toLowerCase().endsWith('.json')){
        const text = await file.text();
        const obj = JSON.parse(text);
        if(!obj || !obj.meta) throw new Error('Invalid Snapshot JSON');
        // Only minimal fields are required for snapshot load
        const pick = obj.meta.pick || 20;
        const freq = obj.freq || Array(71).fill(0);
        const draws = []; // snapshot might not include draws; allow empty
        state.archive = {draws, pick, freq, pairFreq:new Map(), tripleFreq:new Map(), gapHist:Array(70).fill(0)};
        await idb.set('archive', snapshotPack(state.archive));
        afterArchiveLoaded();
        setStatus('Snapshot geladen.');
        return;
      }else{
        const text = await file.text();
        parsed = parseCSVorTXT(text);
      }
      const {draws, pick} = parsed;
      // set dates if detectable: try regex for date in line – omitted for simplicity
      setStatus(`Berechne Statistiken (${draws.length} Ziehungen) …`);
      const stats = computeStats(draws, pick);
      state.archive = {draws, pick, ...stats};
      await idb.set('archive', snapshotPack(state.archive));
      afterArchiveLoaded();
      setStatus('Archiv geladen.');
    }catch(err){
      console.error(err);
      setStatus('Fehler beim Lesen: '+err.message, 'error');
    }
  }

  function snapshotPack(arch){
    // Map→array for IDB
    const pf = Array.from(arch.pairFreq?.entries?.()||[]);
    const tf = Array.from(arch.tripleFreq?.entries?.()||[]);
    return {...arch, pairFreq: pf, tripleFreq: tf};
  }
  function snapshotUnpack(obj){
    const pf = new Map(obj.pairFreq||[]);
    const tf = new Map(obj.tripleFreq||[]);
    return {...obj, pairFreq: pf, tripleFreq: tf};
  }

  function afterArchiveLoaded(){
    const a = state.archive;
    // Meta
    el.metaDraws.textContent = a.draws.length.toLocaleString('de-DE');
    el.metaPick.textContent = String(a.pick);
    el.metaStore.textContent = idb.db? 'IndexedDB' : 'localStorage';

    // Date range (best-effort: derive from snapshot or leave unknown)
    let minD='—', maxD='—';
    if(a.draws.length){
      // Assuming no date -> show count-based range
      minD = 'n/a'; maxD='n/a';
    }
    el.metaDateRange.textContent = `${minD} – ${maxD}`;

    // Build group targets fresh
    buildGroupTargets();
    drawMap();
    el.btnStart.disabled = !isStartEnabled();

    // Init worker with archive meta (compact)
    if(state.worker) state.worker.terminate();
    state.worker = createWorker();
    const pass = {
      freq: a.freq, gapHist: a.gapHist,
      pairFreq: Object.fromEntries(a.pairFreq), // pass as plain object for structured clone size
      tripleFreq: Object.fromEntries(a.tripleFreq),
    };
    // Rehydrate maps inside worker? We use object lookups; fine.
    state.worker.postMessage({type:'init', archive: pass});
  }

  /* ------------------------ Generator control ------------------------ */
  function modeToConf(){
    const mode = el.mode.value;
    // weights
    return {
      mode,
      wSingles: 1.0,
      wPairs: el.chkPairs.checked? 0.15 : 0,
      wTriples: el.chkTriples.checked? 0.05 : 0,
      wGaps: el.chkGaps.checked? 0.12 : 0,
      noveltyWeight: 0.8,
      usePairs: el.chkPairs.checked,
      useTriples: el.chkTriples.checked,
      useGaps: el.chkGaps.checked
    };
  }

  el.btnStart.addEventListener('click', ()=>{
    if(!isStartEnabled()){ setStatus('Summe der Gruppen-Counts muss S ergeben.', 'warn'); return; }
    const pick = state.archive.pick;
    const tsec = parseInt(el.timeLimit.value,10);
    const conf = modeToConf();
    const targets = state.groupTargets.slice();
    setRunning(true);
    setStatus('Suche gestartet …');
    el.progress.textContent = 'läuft …';
    state.currentCandidate.clear(); drawMap();

    state.worker.postMessage({
      type:'run',
      pick,
      rangeMin: state.rangeMin,
      rangeMax: state.rangeMax,
      groupMode: state.groupMode,
      targets,
      conf,
      timeLimitSec: tsec,
      topN: parseInt(el.topN.value,10),
      mmr: el.chkMMR.checked
    });
  });

  el.btnStop.addEventListener('click', ()=>{
    if(state.worker){ state.worker.terminate(); state.worker=null; }
    setRunning(false);
    state.currentCandidate.clear(); drawMap();
    setStatus('Suche abgebrochen.', 'warn');
  });

  /* ------------------------ Range & Group UI ------------------------ */
  function updateRange(){
    state.rangeMin = clamp(parseInt(el.rangeMin.value||'1',10),1,70);
    state.rangeMax = clamp(parseInt(el.rangeMax.value||'70',10),1,70);
    if(state.rangeMin>state.rangeMax){ [state.rangeMin,state.rangeMax]=[state.rangeMax,state.rangeMin]; }
    el.rangeMin.value=state.rangeMin; el.rangeMax.value=state.rangeMax;
    drawMap();
  }
  el.rangeMin.addEventListener('input', updateRange);
  el.rangeMax.addEventListener('input', updateRange);

  el.groupModeSel.addEventListener('change', ()=>{
    state.groupMode = parseInt(el.groupModeSel.value,10);
    buildGroupTargets();
    drawMap();
  });

  el.btnEven.addEventListener('click', ()=>{
    if(!state.archive) return;
    const g = groupsFor(state.groupMode).length;
    const base = Math.floor(state.archive.pick / g);
    let rem = state.archive.pick - base*g;
    state.groupTargets = Array.from({length:g}, ()=>base);
    for(let i=0;i<g && rem>0;i++,rem--) state.groupTargets[i]++;
    // reflect to inputs
    $$('#groupTargets input').forEach((inp,i)=>inp.value=state.groupTargets[i]);
    updateTargetSum();
  });

  el.btnFromArchive.addEventListener('click', ()=>{
    if(!state.archive) return;
    const g = groupsFor(state.groupMode);
    const totals = new Array(g.length).fill(0);
    for(let n=1;n<=70;n++){
      const gi = groupIndexOf(n, state.groupMode);
      totals[gi] += state.archive.freq[n];
    }
    const sumF = sum(totals);
    const raw = totals.map(x=>x/sumF*state.archive.pick);
    const ints = raw.map(x=>Math.floor(x));
    let rem = state.archive.pick - sum(ints);
    // distribute remainders by largest fractional
    const fracIdx = raw.map((x,i)=>[x-ints[i],i]).sort((a,b)=>b[0]-a[0]).map(x=>x[1]);
    for(let k=0;k<fracIdx.length && rem>0;k++,rem--) ints[fracIdx[k]]++;
    state.groupTargets = ints;
    $$('#groupTargets input').forEach((inp,i)=>inp.value=state.groupTargets[i]);
    updateTargetSum();
  });

  /* ------------------------ File input, drag/drop ------------------------ */
  el.fileInput.addEventListener('change', async e=>{
    const f = e.target.files[0]; if(!f) return;
    await loadFromFile(f);
  });

  document.addEventListener('dragover', e=>{ e.preventDefault(); });
  document.addEventListener('drop', async e=>{
    e.preventDefault();
    const f = e.dataTransfer.files?.[0];
    if(f) await loadFromFile(f);
  });

  /* ------------------------ Exports & Clear ------------------------ */
  el.btnExportCsv.addEventListener('click', ()=>{
    if(!state.archive || state.archive.draws.length===0){ setStatus('Kein Archiv geladen.', 'warn'); return; }
    exportCsv(state.archive);
  });
  el.btnExportJson.addEventListener('click', ()=>{
    if(!state.archive){ setStatus('Kein Archiv geladen.', 'warn'); return; }
    exportSnapshot(state.archive);
  });
  el.btnClear.addEventListener('click', async ()=>{
    await idb.del('archive');
    state.archive=null;
    el.metaDraws.textContent='—'; el.metaDateRange.textContent='—'; el.metaPick.textContent='—';
    buildGroupTargets(); drawMap(); updateTargetSum();
    setStatus('Archiv gelöscht.');
  });

  /* ------------------------ Init on load ------------------------ */
  async function init(){
    try{
      await idb.open();
      const saved = await idb.get('archive');
      if(saved){
        state.archive = snapshotUnpack(saved);
        afterArchiveLoaded();
        setStatus('Archiv aus Persistenz geladen.');
      }else{
        setStatus('Bereit. Lade eine Datei (CSV/TXT/ZIP/JSON).');
      }
    }catch(err){
      console.warn('IDB disabled, fallback to localStorage', err);
      setStatus('IndexedDB nicht verfügbar – Fallback localStorage.', 'warn');
    }
    drawMap();
  }

  init();

})();
</script>
</body>
</html>