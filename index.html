<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO ‚Äì Kombinationen, Muster & Hot-Gruppen (Map + Gruppenquoten / robustes Archiv)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041; --text:#e5e7eb;
    --accent:#22c55e; --accent2:#60a5fa; --warm:#fb923c; --danger:#ef4444;
    --dim:#1b2333; --outline:#94a3b8;
  }
  html,body{height:100%}
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  a{color:#93c5fd;text-decoration:none}
  .box{max-width:1180px;margin:0 auto}
  input[type="file"],input[type="number"],input[type="text"],select,textarea{
    width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid var(--muted);background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .ghost{background:transparent;border:1px dashed var(--muted);color:var(--text)}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 220px}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .pill{display:inline-block;padding:4px 10px;border-radius:999px;border:1px solid var(--muted);background:var(--bg);margin-left:8px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:8px}
  .badge.hot{background:#1f2937;border-color:var(--warm);color:#ffd7a1}
  .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
  .hint{color:#9ca3af;font-size:14px;margin-top:4px}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .resItem{display:flex;align-items:center;gap:10px;flex-wrap:wrap;background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:8px;margin-bottom:6px}
  .resNums{white-space:pre}
  .hotnum{color:var(--danger);font-weight:700}
  progress{width:100%;height:12px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-bar{background:var(--bg)}
  progress::-webkit-progress-value{background:var(--accent)}
  /* Zahlen-Map */
  .mapWrap{display:grid;grid-template-columns:repeat(10,1fr);gap:6px}
  .cell{position:relative;border-radius:10px;padding:8px 0;text-align:center;font-weight:700;border:1px solid transparent;user-select:none}
  .cell.sel{outline:2px solid var(--outline);outline-offset:0;border-color:var(--outline)}
  .cell.disallowed{filter:grayscale(1) brightness(.6); border-color:transparent; outline:none}
  .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .legend .lg{display:flex;align-items:center;gap:6px;border:1px solid var(--muted);border-radius:8px;padding:4px 8px;background:var(--bg)}
  .sw{width:14px;height:14px;border-radius:4px;border:1px solid #0003}
  .quota{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:6px;margin-top:6px}
  .quotaItem{border:1px solid var(--muted);border-radius:10px;padding:8px;background:var(--bg)}
  .quotaItem header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .quotaItem .cnt{font-weight:700}
</style>
</head>
<body>
<div class="box">

  <!-- üóÇÔ∏è Archiv -->
  <div class="panel" id="p-archiv" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2><span class="pill">ZIP wird lokal entpackt</span></div>
    <p class="hint">Offizielles Bayern-Archiv: CSV/TXT im ZIP ‚Äì wir erkennen Kopfzeilen ‚ÄûZahl 1 ‚Ä¶ Zahl 20‚Äú, Bindestrich-Spalten oder freie Zahlenzeilen.</p>
    <div class="row">
      <div>
        <label>CSV/TXT oder ZIP ausw√§hlen</label>
        <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">
        <div class="hint">Robuste Erkennung (UTF-8/Latin-1, ; | , Tab, Anf√ºhrungszeichen, Bindestrich-Spalte).</div>
      </div>
      <div>
        <label>Archiv-Status</label>
        <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
        <div class="row" style="margin-top:6px"><button id="clearCache" class="danger">Archiv l√∂schen</button></div>
      </div>
    </div>
  </div>

  <!-- üéõÔ∏è Einstellungen -->
  <div class="panel" id="p-settings" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">üéõÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div>
        <label>Kombi-Gr√∂√üe (KENO-Typ)</label>
        <select id="kenoType">
          <option value="2">Typ 2</option><option value="3">Typ 3</option><option value="4">Typ 4</option>
          <option value="5">Typ 5</option><option value="6" selected>Typ 6</option><option value="7">Typ 7</option>
          <option value="8">Typ 8</option><option value="9">Typ 9</option><option value="10">Typ 10</option>
        </select>
      </div>
      <div><label>Max. erlaubte √úberschneidung</label><input type="number" id="maxOv" value="5" min="0" max="20"></div>
      <div><label>Zahlenbereich ‚Äì Von</label><input type="number" id="rangeFrom" value="1" min="1" max="200"></div>
      <div><label>Zahlenbereich ‚Äì Bis</label><input type="number" id="rangeTo" value="70" min="1" max="200"></div>
    </div>
  </div>

  <!-- üó∫Ô∏è Zahlen-Map & Quoten -->
  <div class="panel" id="p-map" style="border-left:6px solid #a78bfa">
    <div class="ph"><span class="emoji">üó∫Ô∏è</span><h2 style="margin:0">Zahlen-Map & Gruppen-Einteilung</h2><span class="pill">Farben fix je 10er-Bereich</span></div>
    <div class="row">
      <div><label><input type="checkbox" id="mapEnabled" checked> Map beim Generieren live anzeigen</label></div>
      <div>
        <label>Gruppen-Einteilung</label>
        <select id="groupMode">
          <option value="10" selected>10er Gruppen (1‚Äì10, 11‚Äì20, ‚Ä¶)</option>
          <option value="7">7er Gruppen</option>
          <option value="5">5er Gruppen</option>
          <option value="3">3er Gruppen</option>
          <option value="custom">eigene Gr√∂√üe ‚Ä¶</option>
        </select>
      </div>
      <div id="customGroupWrap" style="display:none">
        <label>Eigene Gruppengr√∂√üe</label>
        <input type="number" id="customGroupSize" value="10" min="2" max="20">
      </div>
      <div>
        <label>Quoten automatisch auf S verteilen</label>
        <button id="autoDistribute" class="secondary">Aufteilen</button>
      </div>
    </div>
    <div class="hint">‚Äû0‚Äú hei√üt: <b>diese Gruppe komplett ausschlie√üen</b> ‚Äì in der Map keine Outline/Umrandung.</div>
    <div id="quotaBox" class="quota"></div>
    <div class="legend" id="colorLegend"></div>
    <div id="map" class="mapWrap" style="margin-top:8px"></div>
    <div class="hint">Vorschau: <span id="previewCount" class="badge">0 / S</span></div>
  </div>

  <!-- üî• H√§ufige Gruppen -->
  <div class="panel" id="p-hot" style="border-left:6px solid #f472b6">
    <div class="ph"><span class="emoji">üî•</span><h2 style="margin:0">H√§ufige Gruppen</h2></div>
    <label style="display:flex;align-items:center;gap:8px">
      <input type="checkbox" id="useHotGroups"> <span>aktivieren</span>
    </label>
    <div id="hotBox" style="display:none">
      <div class="row">
        <div><label>R√ºckblick Ziehungen</label><input type="number" id="hotWindow" value="500" min="50" max="50000"></div>
        <div><label>Gruppengr√∂√üe</label>
          <select id="hotK">
            <option value="2" selected>2 (Paare)</option>
            <option value="3">3 (Tripel)</option>
            <option value="4">4 (Quattro)</option>
            <option value="5">5</option>
          </select>
        </div>
        <div><label>Top N</label><input type="number" id="hotTopN" value="30" min="5" max="1000"></div>
        <div><label>Modus</label>
          <select id="hotMode"><option value="require" selected>M√ºssen enthalten</option><option value="prefer">Bevorzugen</option></select>
        </div>
      </div>
      <div class="row">
        <div style="flex:2 1 180px"><label>Info</label><div id="hotInfo" class="status">inaktiv</div></div>
        <div style="flex:1 1 180px"><label>Fortschritt</label><progress id="hotProg" value="0" max="1" style="display:none"></progress></div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="hotStart" class="secondary">Neu berechnen</button>
        <button id="hotCancel" class="danger" disabled>Abbrechen</button>
      </div>
    </div>
  </div>

  <!-- üßÆ Generieren -->
  <div class="panel" id="p-gen" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üßÆ</span><h2 style="margin:0">Kombinationen generieren</h2></div>
    <div class="row">
      <div><label>Wieviele Ergebnisse</label><input type="number" id="want" value="10" min="1" max="2000"></div>
      <div><label>Max. Versuche (Basis)</label><input type="number" id="tries" value="60000" min="1000" step="1000"></div>
      <div><label>Seed</label><input type="number" id="seed" value="1" min="0"></div>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="go" class="primary">Generieren</button>
      <button id="save" class="secondary">Als CSV speichern</button>
    </div>
    <div class="row" style="margin-top:8px">
      <div style="flex:2 1 180px"><label>Generieren-Status</label><div id="genInfo" class="status">bereit</div></div>
      <div style="flex:1 1 180px"><label>Fortschritt</label><progress id="genProg" value="0" max="1" style="display:none"></progress></div>
    </div>
  </div>

  <!-- üß† Tipp pr√ºfen -->
  <div class="panel" id="p-analyse" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">üß†</span><h2 style="margin:0">Tipp analysieren</h2></div>
    <label>Dein Tipp (Zahlen mit Leerzeichen/Komma)</label>
    <input type="text" id="tipInput" placeholder="z. B. 10 11 16 22 24 44 48 49 50 52">
    <div class="row" style="margin-top:6px">
      <div><label>√úberschneidung z√§hlen ab (‚â•)</label><input type="number" id="thrA" value="5" min="1" max="20"></div>
      <div><label>2. Schwelle (optional, ‚â•)</label><input type="number" id="thrB" value="6" min="1" max="20"></div>
    </div>
    <div style="margin-top:6px" class="row">
      <button id="checkTip" class="secondary">Tipp analysieren</button>
    </div>
    <div id="tipStatus" class="status" style="display:none"></div>
  </div>

  <!-- üìã Ergebnisse -->
  <div class="panel" id="p-results">
    <div class="ph"><span class="emoji">üìã</span><h2 style="margin:0">Ergebnisse</h2></div>
    <div id="results" class="results"></div>
    <div id="resultStatus" class="status" style="display:none;margin-top:10px"></div>
  </div>

</div>

<!-- JSZip (ZIP-Entpacken im Browser) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(function(){
  "use strict";
  const $=s=>document.querySelector(s);
  const text=(el,s)=>{ if(el) el.textContent=s; };
  const html=(el,s)=>{ if(el) el.innerHTML=s; };
  const uniqSorted=a=>Array.from(new Set(a)).sort((x,y)=>x-y);
  const sum=a=>a.reduce((s,x)=>s+x,0);

  const CACHE_KEY="keno_archive_v5";
  let g_draws=[], g_drawSize=0;

  /* ===== Farben fix je 10er-Bereich ===== */
  const decileColors=["#bfdbfe","#a7f3d0","#fde68a","#c7d2fe","#99f6e4","#fecaca","#bbf7d0","#f5d0fe","#fef08a"];
  function colorForNumber(n){ const idx=Math.floor((n-1)/10); return decileColors[idx]||"#e5e7eb"; }

  /* ===== Gruppen / Map ===== */
  let groupSize=10;
  let groupQuotas=[];
  function groupIndexOf(n){ const A=+$("#rangeFrom").value; return Math.floor((n-A)/groupSize); }
  function renderLegend(){
    const box=$("#colorLegend"); box.innerHTML="";
    for(let start=1; start<=70; start+=10){
      const end=Math.min(start+9,70);
      const div=document.createElement("div");
      div.className="lg";
      div.innerHTML = '<span class="sw" style="background:'+colorForNumber(start)+'"></span>'+start+'‚Äì'+end;
      box.appendChild(div);
    }
  }
  function renderQuotaInputs(){
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const nGroups = Math.ceil((B-A+1)/groupSize);
    const S = parseInt($("#kenoType").value,10);
    groupQuotas.length=nGroups; groupQuotas.fill(0,groupQuotas.length);
    const wrap=$("#quotaBox"); wrap.innerHTML="";
    for(let gi=0; gi<nGroups; gi++){
      const gStart=A+gi*groupSize, gEnd=Math.min(B, gStart+groupSize-1);
      const id="q_"+gi;
      const div=document.createElement("div");
      div.className="quotaItem";
      div.innerHTML=`<header><div><b>Gruppe ${gi+1}</b> <span class="mono">(${gStart}‚Äì${gEnd})</span></div>
                     <div class="cnt" id="${id}_cnt">0/0</div></header>
                     <div class="row" style="gap:6px">
                        <div><label>Quote</label><input type="number" min="0" max="${S}" value="0" id="${id}"></div>
                        <div><label>&nbsp;</label><button class="ghost" data-gi="${gi}">0</button></div>
                     </div>`;
      wrap.appendChild(div);
    }
    wrap.onchange=(e)=>{
      const inp=e.target.closest("input[id^='q_']"); if(!inp) return;
      const gi=+inp.id.split("_")[1]; const v=Math.max(0,Math.min(20,+inp.value||0));
      groupQuotas[gi]=v; $("#"+inp.id+"_cnt").textContent=`0/${v}`; renderMap(window._lastPreview||[]);
    };
    wrap.onclick=(e)=>{
      const b=e.target.closest("button[data-gi]"); if(!b) return;
      const gi=+b.dataset.gi; groupQuotas[gi]=0; const id="q_"+gi; const inp=$("#"+id); if(inp) inp.value=0;
      $("#"+id+"_cnt").textContent="0/0"; renderMap(window._lastPreview||[]);
    };
  }
  function autoDistribute(){
    const S=parseInt($("#kenoType").value,10);
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const nGroups=Math.ceil((B-A+1)/groupSize);
    groupQuotas = Array(nGroups).fill(0);
    for(let i=0;i<S;i++) groupQuotas[i % nGroups]++;
    const wrap=$("#quotaBox");
    for(let gi=0; gi<nGroups; gi++){
      const inp=$("#q_"+gi); if(inp){ inp.value=groupQuotas[gi]; }
      $("#q_"+gi+"_cnt").textContent=`0/${groupQuotas[gi]}`;
    }
    renderMap(window._lastPreview||[]);
  }
  function updatePreviewCounters(sel){
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const nGroups=Math.ceil((B-A+1)/groupSize);
    const chosen = (sel||window._lastPreview||[]);
    const cnt = Array(nGroups).fill(0);
    for(const n of chosen){ const gi=groupIndexOf(n); if(gi>=0 && gi<cnt.length) cnt[gi]++; }
    for(let gi=0; gi<nGroups; gi++){
      const el=$("#q_"+gi+"_cnt"); if(!el) continue;
      const quota=groupQuotas[gi]||0; el.textContent=`${cnt[gi]}/${quota}`;
    }
    $("#previewCount").textContent = (chosen.length)+" / "+(parseInt($("#kenoType").value,10));
  }
  function renderMap(selected){
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const map=$("#map"); map.innerHTML="";
    const set=new Set(selected||[]);
    for(let n=A; n<=B; n++){
      const cell=document.createElement("div");
      cell.className="cell";
      cell.style.background = colorForNumber(n);
      const gi=groupIndexOf(n);
      const quota = groupQuotas[gi]||0;
      if(quota===0){ cell.classList.add("disallowed"); }
      if(set.has(n)){ cell.classList.add("sel"); }
      cell.textContent = n;
      map.appendChild(cell);
    }
    updatePreviewCounters(selected);
  }
  function buildGroups(){
    const mode=$("#groupMode").value;
    $("#customGroupWrap").style.display = (mode==="custom")? "" : "none";
    groupSize = (mode==="custom") ? Math.max(2,Math.min(20,+$("#customGroupSize").value||10)) : +mode;
    renderLegend();
    renderQuotaInputs();
    renderMap([]);
  }
  $("#groupMode").addEventListener("change", buildGroups);
  $("#customGroupSize").addEventListener("change", buildGroups);
  $("#rangeFrom").addEventListener("change", buildGroups);
  $("#rangeTo").addEventListener("change", buildGroups);
  $("#kenoType").addEventListener("change", ()=>{ buildGroups(); updatePreviewCounters(); });
  $("#autoDistribute").addEventListener("click", autoDistribute);
    /* ===== Archiv laden (robust) ===== */
  function stripQuotes(s){ return String(s||"").trim().replace(/^"+|"+$/g,"").replace(/^'+|'+$/g,""); }
  function splitSmart(line){
    const L=line.replace(/\uFEFF/g,""); // BOM
    if(/\t/.test(L)) return L.split("\t").map(stripQuotes);
    if(L.includes(";")) return L.split(";").map(stripQuotes);
    if(L.includes("|")) return L.split("|").map(stripQuotes);
    if(/,/.test(L) && !/^\d+(?:-\d+)+$/.test(L.trim())) return L.split(",").map(stripQuotes);
    return L.trim().split(/\s+/).map(stripQuotes);
  }
  function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}
  function detectZahlColumns(rows){
    if(!rows.length) return null;
    const h=rows[0].map(x=>stripQuotes(String(x||"")));
    const idx=[];
    for(let i=0;i<h.length;i++){
      const cell=h[i].toLowerCase();
      if(/zahl\s*0?\d{1,2}/i.test(cell)) idx.push(i);
    }
    if(idx.length>=5) return idx;
    return null;
  }
  function extractByZahlColumns(rows, idx){
    const lists=[];
    for(let r=1;r<rows.length;r++){
      const nums=idx.map(i=>parseInt(String(rows[r][i]||"").replace(/\D+/g,""),10)).filter(Number.isFinite);
      if(nums.length>=5) lists.push(nums);
    }
    return lists;
  }
  function detectDashCol(rows){
    let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
    let best=-1,score=-1;
    for(let c=0;c<maxCols;c++){
      let sc=0;
      for(const r of rows){
        if(c>=r.length) continue;
        const cell=stripQuotes(String(r[c]||"")).trim(); if(!cell) continue;
        const parts=cell.split("-");
        if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }
  function extractByDash(rows, ncol){
    const lists=[];
    for(const r of rows){
      if(ncol>=r.length) continue;
      const raw=stripQuotes(String(r[ncol]||"")).trim(); if(!raw) continue;
      if(/^\d+(?:-\d+)+$/.test(raw)) lists.push(raw.split("-").map(x=>parseInt(x,10)));
    }
    return lists;
  }
  function fallbackExtract(raw){
    const out=[];
    for(const lnRaw of raw.split(/\r?\n/)){
      const ln=lnRaw.trim(); if(!ln) continue;
      // Whole-line dash format
      if(/^\d+(?:-\d+)+$/.test(ln)){ out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); continue; }
      // Otherwise: pick 10..20 ints in range 1..200
      const ints=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
      const filtered=ints.filter(x=>x>=1 && x<=200);
      if(filtered.length>=10) out.push(filtered.slice(0,20));
    }
    return out;
  }
  async function loadArchiveFromAny(file){
    text($("#statusTop"), `Lese Datei: ${file.name}`);
    const name=file.name.toLowerCase();
    try{
      let raw=""; let source="";
      if(name.endsWith(".zip")){
        if(!window.JSZip){ alert("JSZip fehlt (CDN)"); return; }
        const ab = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(ab);
        const candidates=[];
        zip.forEach((path, entry)=>{
          const p=path.toLowerCase();
          if(p.endsWith(".csv") || p.endsWith(".txt")){
            const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
            candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
          }
        });
        if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden");
        candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
        const target=candidates[0];
        text($("#statusTop"), `Entpacke & lese: ${target.path}`);
        try{ raw = await target.entry.async("string"); }
        catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        source=`ZIP: ${target.path}`;
      }else{
        raw = await file.text();
        source=file.name||"Upload";
      }

      // Try parsers
      const rows=parseTable(raw);
      let lists=[], detected="";
      const idx=detectZahlColumns(rows);
      if(idx){
        lists=extractByZahlColumns(rows,idx);
        detected=`Header (‚ÄûZahl ‚Ä¶‚Äú) ¬∑ ${idx.length} Spalten`;
      }
      if(!lists.length){
        const ncol=detectDashCol(rows);
        if(ncol>=0){
          lists=extractByDash(rows,ncol);
          detected = "Spalte mit ‚Äû1-4-‚Ä¶‚Äú";
        }
      }
      if(!lists.length){
        lists=fallbackExtract(raw);
        detected = "Fallback: freie Zahlzeilen";
      }

      if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");

      // Standardisieren
      const cleaned = lists.map(arr => uniqSorted(arr.filter(n=>Number.isInteger(n))));
      const freq=new Map(); for(const a of cleaned){ if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1); }
      let bestLen=0, bestCnt=-1; for(const [k,v] of freq.entries()){ if(v>bestCnt){ bestCnt=v; bestLen=k; } }
      if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");

      g_drawSize=bestLen;
      g_draws = cleaned.filter(a=>a.length===g_drawSize);

      if(!g_draws.length) throw new Error("Nach Filter auf dominierende L√§nge keine Ziehungen √ºbrig.");

      localStorage.setItem(CACHE_KEY, JSON.stringify({draws:g_draws, drawSize:g_drawSize, savedAt:Date.now(), source}));
      text($("#statusTop"), `Archiv geladen: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}${source?` ¬∑ Quelle: ${source}`:""}`);
    }catch(e){
      text($("#statusTop"), "Fehler beim Lesen: "+(e?.message||e));
      g_draws=[]; g_drawSize=0;
    }
  }
  $("#file").addEventListener("change", ()=>{ const f=$("#file").files[0]; if(f) loadArchiveFromAny(f); });
  $("#clearCache").addEventListener("click",()=>{
    try{ localStorage.removeItem(CACHE_KEY); }catch{}
    g_draws=[]; g_drawSize=0;
    text($("#statusTop"), "Archiv gel√∂scht. Bitte Datei erneut laden.");
    $("#results").innerHTML=""; $("#resultStatus").style.display="none";
  });

  /* ===== Init ===== */
  (function(){
    try{
      const raw=localStorage.getItem(CACHE_KEY);
      if(raw){
        const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
        if(g_draws.length){
          const ts=obj.savedAt?new Date(obj.savedAt):new Date();
          const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
          text($("#statusTop"), `Archiv aus Browser geladen: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ gespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}${src}`);
        }
      }
    }catch{}
    buildGroups();
  })();

  /* ===== Hot-Gruppen (k=2..5) ===== */
  let g_hotGroups=[];
  function recomputeHotGroups(){
    if(!g_draws.length){ g_hotGroups=[]; text($("#hotInfo"),"aktiv: kein Archiv"); return; }
    const k=+($("#hotK").value||2);
    let topN=Math.max(5,Math.min(1000,+($("#hotTopN").value||30)));
    let win=Math.max(50,+($("#hotWindow").value||500)); if(win>g_draws.length) win=g_draws.length;
    const fromIdx=Math.max(0,g_draws.length-win);
    const slice=g_draws.slice(fromIdx);
    const counts=new Map();
    function combIter(arr,k,cb){
      const n=arr.length; if(k>n) return;
      const idx=Array.from({length:k},(_,i)=>i);
      while(true){
        cb(idx.map(i=>arr[i]));
        let i=k-1;
        while(i>=0 && idx[i]===i+n-k) i--;
        if(i<0) break;
        idx[i]++;
        for(let j=i+1;j<k;j++) idx[j]=idx[j-1]+1;
      }
    }
    for(const d of slice) combIter(d,k,(c)=>{ const key=c.join("-"); counts.set(key,(counts.get(key)||0)+1); });
    const items=Array.from(counts.entries()).sort((a,b)=> b[1]-a[1] || (a[0]<b[0]?-1:1)).slice(0,topN);
    g_hotGroups = items.map(([k])=>k.split("-").map(x=>+x));
    if(!items.length) text($("#hotInfo"),"Keine Gruppen gefunden.");
    else {
      const lines=items.slice(0,10).map(([key,count])=>`${key} √ó${count}`).join(" | ");
      $("#hotInfo").innerHTML = `Top ${items.length} (k=${k}):<br><span class='mono'>${lines}${items.length>10?" | ‚Ä¶":""}</span>`;
    }
  }
  function matchedHotGroups(arr){
    const hits=[]; if(!g_hotGroups.length) return hits;
    const set=new Set(arr);
    for(const g of g_hotGroups) if(g.every(v=>set.has(v))) hits.push(g);
    return hits;
  }
  function toggleHotBox(){ const on=$("#useHotGroups").checked; $("#hotBox").style.display=on?"":"none"; text($("#hotInfo"), on?"bereit":"inaktiv"); if(on) recomputeHotGroups(); }
  $("#useHotGroups").addEventListener("change", toggleHotBox);
  ["hotWindow","hotK","hotTopN","hotMode"].forEach(id=>{ const el=document.getElementById(id); if(el) el.addEventListener("change", ()=>{ if($("#useHotGroups").checked) recomputeHotGroups(); }); });
  $("#hotStart").addEventListener("click", ()=>{ if($("#useHotGroups").checked) recomputeHotGroups(); });

  /* ===== Generator (mit Live-Map & Quoten) ===== */
  function buildDrawBits(A,B){
    const toBits=arr=>{ let bits=0n; for(const v of arr){ if(v>=A&&v<=B) bits|=(1n<<BigInt(v-1)); } return bits; };
    return g_draws.map(d=> toBits(d).toString());
  }
  function rng(seed){ let t=seed>>>0; return ()=>{ t=(t+0x6D2B79F5)>>>0; let r=((t^(t>>>15))|1); r=Math.imul(r^(r>>>7),61|r); r=(r^(r>>>14))>>>0; return r/4294967296; }; }
  function startGenerate(params){
    const drawsBits = params.drawsBits.map(s=>BigInt(s));
    const want=params.want|0, maxOv=params.maxOv|0, A=params.A|0, B=params.B|0, S=params.S|0;
    const hotOn=params.hotOn, hotMode=params.hotMode||"require", HOT=params.hotGroups||[];
    const rand = rng(params.seed>>>0 || 1);
    function validAgainst(dbits,cb,maxOv){
      function popcountUpTo(x,limit){ let c=0; while(x){ x&=(x-1n); c++; if(c>limit) break; } return c; }
      for(const db of dbits){ if(popcountUpTo(cb & db, maxOv) > maxOv) return false; } return true;
    }
    function hasHotGroup(arr){
      if(!HOT.length) return false;
      const set=new Set(arr);
      outer: for(const g of HOT){ for(const v of g){ if(!set.has(v)) continue outer; } return true; }
      return false;
    }
    function toBits(arr){ let b=0n; for(const v of arr){ if(v>0) b|=(1n<<BigInt(v-1)); } return b; }
    const results=[]; let tested=0; const seen=new Set();
    function updatePreview(arr){ if(!$("#mapEnabled").checked) return; window._lastPreview = arr.slice(); renderMap(arr); }
    const triesTarget = Math.max(+$("#tries").value||60000, want*5000);
    while(results.length<want && tested<triesTarget){
      // sample random S numbers
      const n=B-A+1; if(S>n) break;
      const arr=Array(n); for(let i=0;i<n;i++) arr[i]=A+i;
      for(let i=0;i<S;i++){ const j=i+Math.floor(rand()*(n-i)); const t=arr[i]; arr[i]=arr[j]; arr[j]=t; }
      arr.length=S; arr.sort((x,y)=>x-y);
      // Quoten pr√ºfen
      const cnt=[];
      let ok=true;
      for(const v of arr){
        const gi=groupIndexOf(v);
        const q=groupQuotas[gi]||0;
        if(q===0){ ok=false; break; }
        cnt[gi]=(cnt[gi]||0)+1;
        if(cnt[gi]>q){ ok=false; break; }
      }
      if(!ok){ tested++; if(tested%1200===0) updatePreview(arr); continue; }
      const key=arr.join("-"); if(seen.has(key)){ tested++; continue; } seen.add(key);
      const cb=toBits(arr);
      if(validAgainst(drawsBits,cb,maxOv)){
        const hit = hasHotGroup(arr);
        if(hotOn && hotMode==='require'){ if(hit) results.push(arr); }
        else results.push(arr);
        updatePreview(arr);
      }else if(tested%1500===0){
        updatePreview(arr);
      }
      tested++;
      if(tested%2000===0){ text($("#genInfo"), `Suche‚Ä¶ getestet=${tested.toLocaleString()} ¬∑ gefunden=${results.length}/${want}`); $("#genProg").value = results.length/Math.max(1,want); }
    }
    return results;
  }
  $("#go").addEventListener("click", ()=>{
    if(!g_draws.length){alert("Bitte Archiv laden");return;}
    const A=+$("#rangeFrom").value,B=+$("#rangeTo").value,maxOv=+$("#maxOv").value;
    if(A>B){alert("Bereich ‚ÄöVon‚Äò darf nicht gr√∂√üer als ‚ÄöBis‚Äò sein.");return;}
    const Ssize=parseInt($("#kenoType").value,10);
    const hotOn=$("#useHotGroups").checked, hotMode=($("#hotMode")?$("#hotMode").value:"require");
    const params = {
      A,B,S:Ssize,maxOv,
      drawsBits: buildDrawBits(A,B),
      hotOn, hotMode, hotGroups: (hotOn? g_hotGroups : []),
      want:+$("#want").value,
      seed:(+$("#seed").value)>>>0
    };
    $("#genInfo").textContent = `Starte‚Ä¶ (S=${Ssize}, Bereich ${A}‚Äì${B}, maxOv ‚â§ ${maxOv})`;
    $("#results").innerHTML=""; $("#resultStatus").style.display="none";
    $("#genProg").style.display=""; $("#genProg").value=0; $("#genProg").max=1;

    const out = startGenerate(params);

    $("#genProg").style.display="none";
    const frag=document.createDocumentFragment();
    out.forEach((arr,i)=>{
      const div=document.createElement("div");
      div.className="resItem";
      const hotHit = matchedHotGroups(arr).length>0;
      const tag=hotHit? ' <span class="badge hot">HOT</span>' : '';
      div.innerHTML = `<span class="resNums">Kombi ${i+1} ‚Üí ${arr.join(" ")}${tag}</span>`;
      frag.appendChild(div);
    });
    $("#results").appendChild(frag);
    $("#resultStatus").style.display="";
    $("#resultStatus").textContent = `Ergebnisse: ${out.length}/${$("#want").value} ¬∑ Archiv: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize})`;
    $("#genInfo").textContent = "fertig";
    if(out[0]){ window._lastPreview = out[out.length-1]; renderMap(window._lastPreview); }
  });

  /* ===== Analyse ===== */
  function analyzeTipArray(arr){
    if(!g_draws.length){alert("Bitte Archiv laden");return;}
    const A=+$("#rangeFrom").value,B=+$("#rangeTo").value;
    const thrA=Math.max(1,Math.min(20, +($("#thrA").value||7)));
    const thrBVal=String($("#thrB").value||"").trim();
    const thrB=thrBVal? Math.max(1,Math.min(20, +thrBVal)) : null;

    const tip=arr.filter(v=>v>=A&&v<=B).sort((x,y)=>x-y);
    let maxOvSeen=0,cA=0,cB=0,cFull=0;
    for(const dr of g_draws){
      let i=0,j=0,ov=0;
      while(i<tip.length && j<dr.length){
        if(tip[i]===dr[j]){ov++;i++;j++;}
        else if(tip[i]<dr[j]) i++; else j++;
      }
      if(ov>maxOvSeen) maxOvSeen=ov;
      if(ov>=thrA) cA++;
      if(thrB!==null && ov>=thrB) cB++;
      if(ov===tip.length) cFull++;
    }
    const hits=matchedHotGroups(tip);
    const hotSet=new Set(hits.flat());
    const tipHTML = tip.map(n=> hotSet.has(n) ? `<span class="hotnum">${n}</span>` : String(n)).join(" ");
    const out=[];
    out.push('Tipp: '+tipHTML);
    out.push('S='+tip.length);
    out.push(`Max √úberschneidung im Archiv = ${maxOvSeen}`);
    out.push('Ziehungen mit ‚â•'+thrA+': '+cA);
    if(thrB!==null) out.push('Ziehungen mit ‚â•'+thrB+': '+cB);
    out.push('Komplett enthalten: '+(cFull?('Ja ('+cFull+'x)'):'Nein'));
    $("#tipStatus").style.display=""; $("#tipStatus").innerHTML=out.join("<br>");
    window._lastPreview = tip.slice(); renderMap(window._lastPreview);
  }
  $("#checkTip").addEventListener("click",()=>{
    const raw=String($("#tipInput").value||"").trim();
    let nums=(raw.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    nums=uniqSorted(nums);
    if(!nums.length){alert("Kein g√ºltiger Tipp");return;}
    analyzeTipArray(nums);
  });

  /* ===== CSV speichern ===== */
  $("#save").addEventListener("click",()=>{
    let items=[...document.querySelectorAll("#results .resItem .resNums")].map(el=>{
      const m=(el.textContent||"").match(/^Kombi\s+\d+\s+‚Üí\s+(.*)$/);
      return m? m[1].trim().replace(/\s+/g,",") : null;
    }).filter(Boolean);
    if(!items.length){
      const textAll=$("#results").textContent||"";
      items=textAll.split("\n").map(line=>{
        const m=line.match(/^Kombi\s+(\d+)\s+‚Üí\s+(.*)$/); if(!m) return null;
        return m[2].trim().replace(/\s+/g,",");
      }).filter(Boolean);
    }
    if(!items.length){alert("Keine Ergebnisse.");return;}
    const cols=items[0].split(",").length;
    const header="nr,"+Array.from({length:cols},(_,i)=>"feld"+(i+1)).join(",");
    const lines=items.map((row,i)=> (i+1)+","+row);
    const blob=new Blob([header+"\n"+lines.join("\n")],{type:"text/csv;charset=utf-8"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download="kombinationen.csv"; a.click();
    setTimeout(()=>URL.revokeObjectURL(url),500);
  });

})();</script>
</body>
</html>