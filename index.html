<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO Analyzer ‚Äì Ultra (Gruppen ‚Ä¢ Range ‚Ä¢ Historie ‚Ä¢ Deep Compute)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041;
    --text:#e5e7eb; --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  a{color:var(--accent2)}
  .box{max-width:1240px;margin:0 auto}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .row{display:flex;flex-wrap:wrap;gap:12px}
  .col{flex:1 1 220px;min-width:220px}
  label{display:block;margin:4px 0 6px;font-size:14px;opacity:.9}
  input,select,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid var(--muted);
    background:var(--bg);color:var(--text);outline:none}
  input[type="color"]{padding:0;height:42px}
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);
    border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  progress{width:100%;height:14px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-value{background:#22c55e}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .fc-line{border:1px solid var(--muted);border-radius:10px;padding:8px;margin-bottom:6px}
  .badge{display:inline-block;padding:2px 6px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:6px;font-size:12px}
  .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
  .legend-item{display:flex;align-items:center;gap:6px;border:1px solid var(--muted);border-radius:8px;padding:4px 8px}
  .swatch{width:16px;height:16px;border-radius:4px;border:1px solid #0003}
  .mapWrap{display:flex;gap:16px;flex-wrap:wrap}
  .mapPanel{flex:1 1 440px;min-width:320px}
  canvas{width:100%;height:auto;background:#0d1426;border:1px solid var(--muted);border-radius:12px}
  .hint{font-size:13px;opacity:.85}
  .pill{padding:2px 8px;border:1px solid var(--muted);border-radius:999px;font-size:12px}
  .small{font-size:12px;opacity:.9}
</style>
</head>
<body>
<div class="box">

  <!-- Archiv -->
  <div class="panel">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2></div>
    <input type="file" id="file" accept=".csv,.txt,.zip">
    <div class="status small">
      Offizielles ZIP: <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
    </div>
    <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
  </div>

  <!-- Gruppen & Map -->
  <div class="panel">
    <div class="ph"><span class="emoji">üé®</span><h2 style="margin:0">Gruppen (3‚Äì7) & Map</h2></div>
    <div class="row">
      <div class="col" style="flex:2 1 420px">
        <label>Gruppenbereiche (z. B. 1-10,11-20,21-30,31-40,41-50,51-60,61-70)</label>
        <input id="groupRanges" type="text" value="1-10,11-20,21-30,31-40,41-50,51-60,61-70">
        <div class="row">
          <button class="secondary" id="preset7">Preset 7√ó10</button>
          <button class="secondary" id="preset3">Preset 3 Zonen</button>
          <button class="secondary" id="preset5">Preset 5 Zonen</button>
          <button class="secondary" id="validate">Gruppen pr√ºfen</button>
        </div>
        <div id="groupStatus" class="status">Gruppen noch nicht validiert.</div>
        <div class="legend" id="legend"></div>
        <div id="colorRow" class="row" style="margin-top:6px"></div>
      </div>
      <div class="mapPanel">
        <canvas id="map" width="880" height="560"></canvas>
        <div class="hint">Map: 1‚Äì70 (10 Spalten √ó 7 Reihen). Farben = Gruppen, Punkte = aktuelle Hotspots.</div>
      </div>
    </div>
  </div>

  <!-- Einstellungen -->
  <div class="panel">
    <div class="ph"><span class="emoji">‚öôÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div class="col">
        <label>KENO-Typ (S)</label>
        <select id="kenoType">
          <option value="2">2</option><option value="3">3</option><option value="4">4</option>
          <option value="5">5</option><option value="6" selected>6</option><option value="7">7</option>
          <option value="8">8</option><option value="9">9</option><option value="10">10</option>
        </select>
      </div>
      <div class="col">
        <label>Recheng√ºte</label>
        <select id="computeMode">
          <option value="eco">Eco (schnell)</option>
          <option value="std" selected>Standard</option>
          <option value="deep">Deep</option>
          <option value="insane">Insane</option>
        </select>
      </div>
      <div class="col">
        <label>Zahlenspektrum (min‚Äìmax)</label>
        <div class="row">
          <input id="minVal" type="number" min="1" max="70" value="1">
          <input id="maxVal" type="number" min="1" max="70" value="70">
        </div>
        <div class="hint">Beispiel: 4‚Äì67.</div>
      </div>
      <div class="col">
        <label>Wie viele Kombinationen generieren?</label>
        <select id="genCount">
          <option>1</option><option>2</option><option>3</option><option>4</option><option selected>5</option>
          <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
        </select>
        <div class="hint">Separate Einstellung zur Anzeige.</div>
      </div>
      <div class="col">
        <label>Top-Kandidaten anzeigen</label>
        <select id="topShow">
          <option>12</option><option selected>24</option><option>48</option><option>72</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Analyse -->
  <div class="panel">
    <div class="ph"><span class="emoji">üß†</span><h2 style="margin:0">Analyse & Generierung</h2></div>
    <div class="row" style="margin-bottom:8px">
      <button id="start" class="primary" disabled>Start</button>
      <button id="pause" class="secondary" disabled>Pause</button>
      <button id="resume" class="secondary" disabled>Weiter</button>
      <button id="stop" class="danger" disabled>Stopp</button>
      <span class="pill" id="liveInfo">idle</span>
    </div>
    <progress id="prog" value="0" max="1" style="display:none"></progress>
    <div id="status" class="status">bereit</div>
    <div id="results" class="results"></div>
  </div>

  <!-- Finale Auswahl -->
  <div class="panel" id="p-final" style="display:none">
    <div class="ph"><span class="emoji">üèÅ</span><h2 style="margin:0">Finale Auswahl</h2></div>
    <div id="final" class="results"></div>
  </div>

  <!-- Tipp-Analyse -->
  <div class="panel" id="p-tip">
    <div class="ph"><span class="emoji">üìù</span><h2 style="margin:0">Tipp-Analyse</h2></div>
    <input type="text" id="tipInput" placeholder="z. B. 10 11 22 24 48 52">
    <button id="checkTip" class="secondary" style="margin-top:6px">Tipp analysieren</button>
    <div id="tipStatus" class="status" style="display:none"></div>
  </div>

</div>

<!-- ==== TEIL 2 hier unterhalb einf√ºgen ==== -->
</body>
</html>
<script>
(function(){
"use strict";

/* ================== Mini-Helpers ================== */
const $ = s => document.querySelector(s);
const text = (el, s) => { if(el) el.textContent = s; };
const html = (el, s) => { if(el) el.innerHTML = s; };
const fmt = n => (n||0).toLocaleString("de-DE");
const uniqSorted = a => Array.from(new Set(a)).sort((x,y)=>x-y);

/* ================== Globals ================== */
const CK_ARCH="keno_ultra_arch_v1", CK_GROUPS="keno_ultra_groups_v1";
let g_draws=[], g_drawSize=0, g_dates=[];   // g_dates optional (falls Datum/ID erkennbar)
let g_groups=[]; // {from,to,color,alpha}
let g_colorInputs=[];
let worker=null, runState="idle", lastList=[];

/* ================== Groups ================== */
const defaultPalette=["#3b82f6","#22c55e","#f59e0b","#ef4444","#a78bfa","#14b8a6","#eab308"];
function hexWithAlpha(hex,a){const h=hex.replace("#","");const r=parseInt(h.slice(0,2),16),g=parseInt(h.slice(2,4),16),b=parseInt(h.slice(4,6),16);return `rgba(${r},${g},${b},${a})`;}
function parseRanges(str){
  const parts=String(str||"").split(",").map(s=>s.trim()).filter(Boolean);
  const ranges=[];
  for(const p of parts){
    const m=p.match(/^(\d{1,2})\s*-\s*(\d{1,2})$/); if(!m) throw new Error(`Ung√ºltig: ${p}`);
    let a=+m[1], b=+m[2]; if(a>b) [a,b]=[b,a];
    if(a<1||b>70) throw new Error("Nur 1‚Äì70 erlaubt.");
    ranges.push({from:a,to:b});
  }
  ranges.sort((x,y)=> x.from-y.from || x.to-y.to);
  if(ranges.length<3||ranges.length>7) throw new Error("Gruppenanzahl 3‚Äì7.");
  if(ranges[0].from!==1 || ranges.at(-1).to!==70) throw new Error("1..70 l√ºckenlos abdecken.");
  for(let i=1;i<ranges.length;i++){
    if(ranges[i].from<=ranges[i-1].to) throw new Error("√úberlappung.");
    if(ranges[i].from!==ranges[i-1].to+1) throw new Error("L√ºcke in Abdeckung.");
  }
  return ranges.map((r,i)=>({...r,color:defaultPalette[i%defaultPalette.length],alpha:0.22}));
}
function buildColorRow(){
  const wrap=$("#colorRow"); html(wrap,""); g_colorInputs=[];
  (g_groups||[]).forEach((g,i)=>{
    const id="col"+i, ida="cola"+i;
    const box=document.createElement("div"); box.className="col";
    box.innerHTML=`
      <label>Gruppe ${i+1}: ${g.from}-${g.to}</label>
      <div class="row">
        <input type="color" id="${id}" value="${g.color}">
        <input type="number" id="${ida}" min="0" max="1" step="0.05" value="${g.alpha}">
      </div>`;
    wrap.appendChild(box);
    g_colorInputs.push({c:$("#"+id), a:$("#"+ida)});
  });
  updateLegend();
}
function updateLegend(){
  const L=$("#legend");
  html(L,(g_groups||[]).map((g,i)=>`
    <div class="legend-item">
      <span class="swatch" style="background:${hexWithAlpha(g.color,g.alpha)};border-color:${g.color}"></span>
      <span>G${i+1}: ${g.from}-${g.to}</span>
    </div>`).join(""));
}
function validateGroups(){
  try{
    const ranges=parseRanges($("#groupRanges").value);
    if(g_groups.length===ranges.length){
      for(let i=0;i<ranges.length;i++){
        ranges[i].color=g_colorInputs[i]?.c?.value||ranges[i].color;
        const a=parseFloat(g_colorInputs[i]?.a?.value ?? ranges[i].alpha);
        ranges[i].alpha=isFinite(a)?Math.max(0,Math.min(1,a)):ranges[i].alpha;
      }
    }
    g_groups=ranges; buildColorRow(); localStorage.setItem(CK_GROUPS,JSON.stringify(g_groups));
    $("#start").disabled=false; text($("#groupStatus"),"Gruppen OK ‚úì"); redrawMap();
    return true;
  }catch(e){ $("#start").disabled=true; text($("#groupStatus"),"Fehler: "+e.message); return false; }
}
$("#validate").addEventListener("click",validateGroups);
$("#preset7").addEventListener("click",()=>{$("#groupRanges").value="1-10,11-20,21-30,31-40,41-50,51-60,61-70";validateGroups();});
$("#preset3").addEventListener("click",()=>{$("#groupRanges").value="1-23,24-47,48-70";validateGroups();});
$("#preset5").addEventListener("click",()=>{$("#groupRanges").value="1-12,13-24,25-36,37-52,53-70";validateGroups();});

/* ================== Archive Loader ================== */
function splitSmart(line){
  if(/\t/.test(line)) return line.split("\t");
  if(line.includes(";")) return line.split(";");
  if(line.includes("|")) return line.split("|");
  if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
  return line.trim().split(/\s+/);
}
function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}
function tryZahlHeader(rows){
  if(!rows.length) return null;
  const header=rows[0].map(x=>String(x).trim()); const idx=[], dateIdx=[];
  for(let i=0;i<header.length;i++){
    if(/^zahl\s*\d+$/i.test(header[i])) idx.push(i);
    if(/datum|date|ziehung|draw|tag/i.test(header[i])) dateIdx.push(i);
  }
  if(idx.length>=5){
    const lists=[], dates=[];
    for(let r=1;r<rows.length;r++){
      const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
      if(nums.length) lists.push(nums);
      let dt=null; if(dateIdx.length){ dt=String(rows[r][dateIdx[0]]??"").trim(); }
      dates.push(dt);
    }
    return {lists, dates, info:`Header erkannt (${idx.length} Zahl-Spalten${dateIdx.length?"+Datum":""})`};
  }
  return null;
}
function detectDashCol(rows){
  let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
  let best=-1,score=-1;
  for(let c=0;c<maxCols;c++){
    let sc=0;
    for(const r of rows){
      if(c>=r.length) continue;
      const cell=String(r[c]??"").trim(); if(!cell) continue;
      const parts=cell.split("-");
      if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
    }
    if(sc>score){score=sc;best=c;}
  }
  return best;
}
function fallbackExtract(raw){
  const out=[], dates=[];
  for(const lnRaw of raw.split(/\r?\n/)){
    const ln=lnRaw.trim(); if(!ln) continue;
    // Datum evtl. am Anfang/Ende? (heuristisch)
    const dtMatch=ln.match(/(\d{4}[-.\/]\d{1,2}[-.\/]\d{1,2})/);
    if(/^\d+(?:-\d+)+$/.test(ln)){
      out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger));
      dates.push(dtMatch?dtMatch[1]:null);
      continue;
    }
    const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    if(nums.length>=5){ out.push(nums); dates.push(dtMatch?dtMatch[1]:null); }
  }
  return {lists:out, dates};
}
async function ensureJSZip(){
  if(window.JSZip) return;
  await new Promise((res,rej)=>{
    const s=document.createElement("script");
    s.src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
    s.onload=res; s.onerror=()=>rej(new Error("JSZip laden fehlgeschlagen"));
    document.head.appendChild(s);
  });
}
function loadArchiveFromRawText(raw, sourceLabel){
  text($("#statusTop"),"Analysiere Datei ‚Ä¶");
  const rows=parseTable(raw);
  let lists=[], dates=[], detected="";
  const h=tryZahlHeader(rows);
  if(h){ lists=h.lists; dates=h.dates; detected=h.info; }
  else{
    const ncol=detectDashCol(rows);
    if(ncol>=0){
      for(const r of rows){
        if(ncol>=r.length) continue;
        const cell=String(r[ncol]??"").trim(); if(!cell) continue;
        const parts=cell.split("-").map(s=>s.trim());
        if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
      }
      detected="Spalte 1-4-‚Ä¶";
    }else{
      const fb=fallbackExtract(raw); lists=fb.lists; dates=fb.dates; detected="Fallback: freie Zahlzeilen";
    }
  }
  if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");
  // dominante L√§nge
  const freq=new Map();
  for(const a of lists){ if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1); }
  let bestLen=0,bestCnt=-1;
  for(const [k,v] of freq.entries()){ if(v>bestCnt){bestCnt=v;bestLen=k;} }
  if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");

  g_drawSize=bestLen;
  g_draws = lists.filter(a=>a.length===g_drawSize).map(a=>uniqSorted(a.filter(Number.isInteger).filter(x=>x>=1&&x<=70)));
  // sync dates auf gleiche L√§nge
  g_dates = dates && dates.length===lists.length ? dates.filter((_,i)=>lists[i].length===g_drawSize) : new Array(g_draws.length).fill(null);
  if(!g_draws.length) throw new Error("Nach Filter keine Ziehungen √ºbrig.");

  try{ localStorage.setItem(CK_ARCH, JSON.stringify({draws:g_draws, drawSize:g_drawSize, dates:g_dates, savedAt:Date.now(), source:sourceLabel||""})); }catch{}

  const ts=new Date();
  text($("#statusTop"),
    `Archiv geladen: ${fmt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}`+
    (sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:"")+
    `\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`
  );
  html($("#results"),""); $("#p-final").style.display="none"; text($("#status"),"bereit"); $("#prog").style.display="none"; redrawMap();
}
async function handleAnyFile(file){
  if(!file){ text($("#statusTop"),"Keine Datei gew√§hlt."); return; }
  text($("#statusTop"),`Lese Datei: ${file.name}`);
  const name=(file.name||"").toLowerCase();
  try{
    if(name.endsWith(".zip")){
      await ensureJSZip();
      const ab=await file.arrayBuffer();
      const zip=await JSZip.loadAsync(ab);
      const candidates=[];
      zip.forEach((path, entry)=>{
        const p=path.toLowerCase();
        if(p.endsWith(".csv")||p.endsWith(".txt")){
          const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
          candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
        }
      });
      if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
      candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
      const target=candidates[0];
      text($("#statusTop"),`Entpacke & lese: ${target.path}`);
      let raw=""; try{ raw=await target.entry.async("string"); }
      catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
      loadArchiveFromRawText(raw, `ZIP: ${target.path}`);
    }else{
      let txt=""; try{ txt=await file.text(); }
      catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
      loadArchiveFromRawText(txt, file.name||"Upload");
    }
  }catch(e){ text($("#statusTop"),"Fehler beim Lesen: "+(e?.message||e)); g_draws=[]; g_drawSize=0; g_dates=[]; }
}
$("#file").addEventListener("change",()=>handleAnyFile($("#file").files[0]));
(function initFromCache(){
  try{
    const raw=localStorage.getItem(CK_ARCH);
    if(raw){
      const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0; g_dates=obj.dates||[];
      if(g_draws.length){
        const ts=obj.savedAt?new Date(obj.savedAt):new Date(); const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
        text($("#statusTop"),`Archiv aus Browser geladen: ${fmt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize})${src}\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`);
      }
    }
  }catch{}
})();
(function initGroups(){
  try{
    const saved=localStorage.getItem(CK_GROUPS); if(saved){ g_groups=JSON.parse(saved)||[]; if(g_groups.length) $("#groupRanges").value=g_groups.map(g=>`${g.from}-${g.to}`).join(",");}
  }catch{}
  if(!g_groups.length){ $("#groupRanges").value="1-10,11-20,21-30,31-40,41-50,51-60,61-70"; validateGroups(); }
  else { buildColorRow(); updateLegend(); $("#start").disabled=false; text($("#groupStatus"),"Gruppen aus Speicher geladen ‚úì"); }
})();

/* ================== Map ================== */
const map=$("#map"), ctx=map.getContext("2d");
function cellRect(n){ const col=(n-1)%10, row=Math.floor((n-1)/10); const pad=8, cw=(map.width-pad*2)/10, ch=(map.height-pad*2)/7; return {x:pad+col*cw,y:pad+row*ch,w:cw,h:ch}; }
function redrawMap(highlights){
  ctx.clearRect(0,0,map.width,map.height);
  for(const g of g_groups){ ctx.fillStyle=hexWithAlpha(g.color,g.alpha); for(let v=g.from;v<=g.to;v++){ const r=cellRect(v); ctx.fillRect(r.x,r.y,r.w,r.h); } }
  ctx.strokeStyle="#1f2a44"; ctx.lineWidth=1; ctx.fillStyle="#cbd5e1"; ctx.font="14px ui-sans-serif,system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle";
  for(let v=1;v<=70;v++){ const r=cellRect(v); ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.fillText(String(v), r.x+r.w/2, r.y+r.h/2); }
  if(Array.isArray(highlights)){
    for(const {num,rank} of highlights){
      const r=cellRect(num);
      ctx.beginPath(); ctx.arc(r.x+r.w/2,r.y+r.h/2,Math.min(r.w,r.h)*0.35,0,Math.PI*2);
      ctx.fillStyle=hexWithAlpha("#fff",0.08+0.12*(rank||0)); ctx.fill();
      ctx.beginPath(); ctx.arc(r.x+r.w/2,r.y+r.h/2,Math.min(r.w,r.h)*0.18,0,Math.PI*2);
      ctx.fillStyle="#e5e7eb"; ctx.fill(); ctx.strokeStyle="#00000055"; ctx.stroke();
    }
  }
}

/* ================== Worker ================== */
function buildWorker(){
  if(worker) try{worker.terminate();}catch{}
  const code=`
  let CFG=null, STATE=null;

  const uniqSorted = a => Array.from(new Set(a)).sort((x,y)=>x-y);

  /* ---- Stats ---- */
  function freq(draws,minV,maxV){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=minV&&v<=maxV) f[v]++; return f; }
  function coMatrix(draws,minV,maxV){
    const M=Array.from({length:71},()=>Array(71).fill(0));
    for(const d of draws){
      const s=d.filter(v=>v>=minV&&v<=maxV);
      for(let i=0;i<s.length;i++) for(let j=i+1;j<s.length;j++){ const a=s[i],b=s[j]; M[a][b]++; M[b][a]++; }
    }
    return M;
  }
  function PMI(draws,minV,maxV){
    const N=draws.length, f=freq(draws,minV,maxV), co=coMatrix(draws,minV,maxV);
    const p=Array(71).fill(0).map((_,i)=> i? (f[i]/(N||1)) : 0);
    const P=Array.from({length:71},()=>Array(71).fill(0));
    for(let a=minV;a<=maxV;a++) for(let b=minV;b<=maxV;b++){
      if(a===b){P[a][b]=0;continue;}
      const pab=co[a][b]/(N||1), den=(p[a]*p[b])||1e-12;
      P[a][b]=Math.log((pab||1e-12)/den);
    }
    return {P};
  }
  function gapHistogram(draws,minV,maxV){
    const H=Array(70).fill(0);
    for(const d of draws){
      const s=d.filter(v=>v>=minV&&v<=maxV).slice().sort((a,b)=>a-b);
      for(let i=1;i<s.length;i++){ const g=s[i]-s[i-1]; if(g>=1&&g<=69) H[g]++; }
    }
    for(let i=2;i<=68;i++) H[i]=0.25*H[i-1]+0.5*H[i]+0.25*H[i+1];
    let mx=1; for(let i=1;i<=69;i++) if(H[i]>mx) mx=H[i];
    for(let i=1;i<=69;i++) H[i]/=mx||1;
    return H;
  }
  function baseProb(draws,minV,maxV){
    const f=freq(draws,minV,maxV), p=Array(71).fill(0);
    for(let i=minV;i<=maxV;i++){ p[i]=(f[i]+0.5); }
    let s=0; for(let i=minV;i<=maxV;i++) s+=p[i]; for(let i=minV;i<=maxV;i++) p[i]/=s||1;
    return p;
  }
  function makeGrpIdx(groups){ const idx=Array(71).fill(-1); for(let g=0; g<groups.length; g++){ for(let v=groups[g].from; v<=groups[g].to; v++) idx[v]=g; } return idx; }

  /* ---- Scoring ---- */
  function scoreOf(arr, ctx){
    const {P, gapW, pBase, grpTarget, grpIdx} = ctx;
    let sProb=0; for(const v of arr) sProb+=Math.log(Math.max(1e-12, pBase[v]||1e-12));
    let sPair=0; for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) sPair+=P[arr[i]][arr[j]]||0;
    const srt=arr.slice().sort((a,b)=>a-b);
    let sGap=0; for(let i=1;i<srt.length;i++){ const g=srt[i]-srt[i-1]; if(g>=1&&g<=69) sGap+=gapW[g]||0; } sGap/=Math.max(1,srt.length-1);
    const cg=Array(grpTarget.length).fill(0); for(const v of arr){ const g=grpIdx[v]; if(g>=0) cg[g]++; }
    let sGrp=0; for(let g=0; g<grpTarget.length; g++){ sGrp += -Math.abs((grpTarget[g]||0)-(cg[g]||0)); }
    let low=0,mid=0,high=0; for(const v of srt){ if(v<=23) low++; else if(v<=47) mid++; else high++; }
    const bal = 1 - (Math.abs(low-mid)+Math.abs(mid-high)+Math.abs(low-high))/(2*arr.length);
    return 1.00*sProb + 0.48*sPair + 0.60*sGap + 0.42*sGrp + 0.20*bal;
  }
  function rankNumbers(pBase,P,minV,maxV){
    const r=Array(71).fill(-1e9);
    for(let v=minV; v<=maxV; v++){
      let top=0; for(let u=minV;u<=maxV;u++){ if(u!==v) top=Math.max(top, P[v][u]||0); }
      r[v]=Math.log(Math.max(1e-12,pBase[v]||1e-12)) + 0.35*top;
    }
    return r;
  }

  /* ---- Profilvarianten ---- */
  function groupProfile(draws,S,groups,minV,maxV){
    const idx=makeGrpIdx(groups);
    const tot=Array(groups.length).fill(0);
    for(const d of draws) for(const v of d){ if(v<minV||v>maxV) continue; const gi=idx[v]; if(gi>=0) tot[gi]++; }
    const share=tot.map(x=> x/Math.max(1,draws.length));
    const base=share.map(s=> s*S), tgt=base.map(Math.floor);
    let rest=S - tgt.reduce((a,b)=>a+b,0);
    const frac=base.map((x,i)=>({i,f:x-tgt[i]})).sort((a,b)=> b.f-a.f);
    for(let i=0;i<rest;i++) tgt[frac[i%frac.length].i]++;
    const variants=[tgt.slice()];
    for(let a=0;a<groups.length;a++) for(let b=0;b<groups.length;b++){
      if(a===b) continue; if(tgt[a]>0){ const v=tgt.slice(); v[a]--; v[b]++; variants.push(v); }
    }
    const seen=new Set(), out=[];
    for(const v of variants){
      if(v.some(x=>x<0)) continue; if(v.reduce((p,c)=>p+c,0)!==S) continue;
      const k=v.join(","); if(!seen.has(k)){ seen.add(k); out.push(v); }
    }
    if(!out.length){ const flat=Array(groups.length).fill(0); for(let i=0;i<S;i++) flat[i%groups.length]++; out.push(flat); }
    return out.slice(0,48);
  }

  /* ---- Suche ---- */
  function start(cfg){
    CFG=cfg;
    const {drawsAll, groups, S, minV, maxV} = CFG;
    const pBase=baseProb(drawsAll,minV,maxV);
    const gapW=gapHistogram(drawsAll,minV,maxV);
    const {P} = PMI(drawsAll,minV,maxV);
    const grpIdx=makeGrpIdx(groups);
    const grpVariants=groupProfile(drawsAll,S,groups,minV,maxV);
    const rank=rankNumbers(pBase,P,minV,maxV);

    // Kandidaten je Gruppe
    const groupsList = groups.map(()=>[]);
    for(let v=minV;v<=maxV;v++){ const gi=grpIdx[v]; if(gi>=0) groupsList[gi].push(v); }
    for(let g=0; g<groupsList.length; g++){ groupsList[g].sort((a,b)=> rank[b]-rank[a] || a-b); }

    STATE={
      startTime: performance.now(), iter:0, paused:false, stop:false,
      targetSec: CFG.targetSec, tickDelay: CFG.tickDelay,
      variants: grpVariants, varIdx:0, best:new Map(),
      ctxBase:{P,gapW,pBase,grpIdx}, groupsList, rank
    };
    postMessage({type:"phase", info:"init", varTotal:grpVariants.length});
    tick();
  }

  function greedyFallback(S, rank, grpIdx, grpTarget, minV, maxV){
    const pool=Array.from({length:grpTarget.length},()=>[]);
    for(let v=minV;v<=maxV;v++){ const gi=grpIdx[v]; if(gi>=0) pool[gi].push(v); }
    for(const g of pool) g.sort((a,b)=>rank[b]-rank[a]||a-b);
    const out=[]; const used=new Uint8Array(71);
    for(let gi=0;gi<grpTarget.length;gi++){
      let need=grpTarget[gi], i=0;
      while(need>0 && i<pool[gi].length){ const v=pool[gi][i++]; if(!used[v]){ used[v]=1; out.push(v); need--; } }
    }
    for(let v=minV; out.length<S && v<=maxV; v++) if(!used[v]){ used[v]=1; out.push(v); }
    return out.slice(0,S).sort((a,b)=>a-b).join("-");
  }

  function expandVariant(){
    const S=CFG.S, take=CFG.take; // gew√ºnschte Anzahl finaler Kombis
    if(STATE.varIdx>=STATE.variants.length) return false;
    const target=STATE.variants[STATE.varIdx];
    const ctx={...STATE.ctxBase, grpTarget:target};
    const beamW=CFG.beam, branch=CFG.branchPerStep;
    // Node: arr[], used[], need[], score
    let frontier=[{arr:[], used:new Uint8Array(71), need:target.slice(), score:0}];

    function nextGroupOrder(need){
      let bestG=0, bestV=-1;
      for(let g=0; g<need.length; g++){
        if(need[g]<=0) continue;
        const v=need[g]*1000 + STATE.groupsList[g].length;
        if(v>bestV){bestV=v; bestG=g;}
      }
      return bestG;
    }

    for(let depth=0; depth<S; depth++){
      const next=[];
      for(const node of frontier){
        const g = nextGroupOrder(node.need);
        if(node.need[g]<=0) continue;
        let pushed=0;
        for(const v of STATE.groupsList[g]){
          if(node.used[v]) continue;
          const need2=node.need.slice(); need2[g]--;
          const used2=node.used.slice(); used2[v]=1;
          const arr2=node.arr.concat(v);
          const sc=scoreOf(arr2, ctx);
          next.push({arr:arr2, used:used2, need:need2, score:sc});
          if(++pushed>=branch) break;
        }
      }
      if(!next.length) break;
      next.sort((a,b)=> b.score-a.score || a.arr.length-b.arr.length);
      frontier=next.slice(0, beamW);
      if(CFG.tickDelay>0) Atomics.wait(new Int32Array(new SharedArrayBuffer(4)),0,0,CFG.tickDelay); // leichte Entschleunigung
    }

    let produced=false;
    for(const node of frontier){
      if(node.arr.length===S){
        const sorted=node.arr.slice().sort((a,b)=>a-b);
        const k=sorted.join("-");
        const val=STATE.best.get(k)||0;
        STATE.best.set(k, val+node.score);
        produced=true;
        if(STATE.best.size>=take*4) break; // genug Material
      }
    }
    if(!produced){
      const k = greedyFallback(S, STATE.rank, STATE.ctxBase.grpIdx, target, CFG.minV, CFG.maxV);
      const sc = scoreOf(k.split("-").map(Number), ctx);
      const prev=STATE.best.get(k)||0; STATE.best.set(k, prev+sc);
    }
    STATE.varIdx++;
    return true;
  }

  function elapsedSec(){ return (performance.now()-STATE.startTime)/1000; }

  function tick(){
    if(!STATE || STATE.stop) return;
    if(STATE.paused){ setTimeout(tick,200); return; }

    const ok=expandVariant(); STATE.iter++;

    const best=Array.from(STATE.best.entries()).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0])).slice(0, CFG.showN)
      .map(([k,score])=>({k,score}));
    let mx=best.length?best[0].score:1;
    const out=best.map(x=>({k:x.k,idx:+(((x.score)/mx)*100).toFixed(1),raw:+x.score.toFixed(3)}));
    postMessage({type:"progress", var:STATE.varIdx, varTotal:STATE.variants.length, elapsed:elapsedSec(), list:out});

    if(CFG.targetSec>0 && elapsedSec()>=CFG.targetSec){ finish(); return; }
    if(!ok){ finish(); return; }
    setTimeout(tick,0);
  }

  function finish(){
    const best=Array.from(STATE.best.entries()).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0])).slice(0, CFG.take)
      .map(([k,score])=>({k,score}));
    let mx=best.length?best[0].score:1;
    const out=best.map(x=>({k:x.k,idx:+(((x.score)/mx)*100).toFixed(1),raw:+x.score.toFixed(3)}));
    postMessage({type:"done", list:out});
    STATE=null;
  }

  onmessage=e=>{
    const m=e.data;
    if(m.cmd==="start") start(m.cfg);
    else if(m.cmd==="pause"){ if(STATE){ STATE.paused=true; postMessage({type:"paused"});} }
    else if(m.cmd==="resume"){ if(STATE){ STATE.paused=false; postMessage({type:"resumed"});} }
    else if(m.cmd==="stop"){ if(STATE){ STATE.stop=true; } postMessage({type:"stopped"}); }
  };
  `;
  const blob=new Blob([code],{type:"application/javascript"});
  worker=new Worker(URL.createObjectURL(blob));
  worker.onmessage=onWorkerMsg;
  worker.onerror=e=>{ text($("#status"),"Worker-Fehler: "+(e.message||"unbekannt")); resetButtons(); };
}

/* ================== Historie (Subset-Suche) ================== */
/** Findet f√ºr eine Kombo die Ziehungs-Indices & Datumswerte, in denen alle Zahlen der Kombo gemeinsam vorkamen (als Teilmenge). */
function findOccurrences(combo){
  const set=new Set(combo);
  const hits=[];
  for(let i=0;i<g_draws.length;i++){
    const d=g_draws[i];
    let ok=true;
    for(const v of set){ if(!d.includes(v)){ ok=false; break; } }
    if(ok) hits.push({idx:i, date:g_dates[i]||null});
  }
  return hits;
}

/* ================== UI: Worker Events ================== */
function onWorkerMsg(ev){
  const m=ev.data;
  if(m.type==="phase"){
    text($("#liveInfo"),`init (${m.varTotal} Profile)`);
  }else if(m.type==="progress"){
    $("#prog").style.display="";
    $("#prog").value=Math.max(0,Math.min(1,(m.varTotal?m.var/m.varTotal:0.5)));
    text($("#status"), `Variante ${m.var}/${m.varTotal} ¬∑ ${m.elapsed.toFixed(1)}s ¬∑ Kandidaten=${fmt((m.list||[]).length)}`);
    lastList=m.list||[];
    renderResults(lastList);
    // Map-Highlights aus Top
    const nums=new Map();
    (lastList||[]).slice(0,8).forEach((it,rank)=>{
      it.k.split("-").map(Number).forEach(n=> nums.set(n, Math.max(nums.get(n)||0, 1-(rank/8))));
    });
    const highlights=Array.from(nums.entries()).map(([num,rk])=>({num,rank:rk}));
    redrawMap(highlights);
    text($("#liveInfo"),`running`);
  }else if(m.type==="paused"){
    text($("#liveInfo"),`paused`);
    $("#pause").disabled=true; $("#resume").disabled=false; $("#stop").disabled=false;
  }else if(m.type==="resumed"){
    text($("#liveInfo"),`running`);
    $("#pause").disabled=false; $("#resume").disabled=true; $("#stop").disabled=false;
  }else if(m.type==="stopped"){
    resetButtons(true); finalize(lastList);
    text($("#liveInfo"),`stopped`);
  }else if(m.type==="done"){
    resetButtons(true); renderResults(m.list||[]); finalize(m.list||[]);
    text($("#liveInfo"),`done`);
  }
}
function resetButtons(hasFinal){
  $("#start").disabled=false; $("#pause").disabled=true; $("#resume").disabled=true; $("#stop").disabled=true;
  $("#prog").style.display="none";
  if(hasFinal) $("#p-final").style.display="";
}

/* ================== Render ================== */
function grpInfo(key){
  const arr=key.split("-").map(Number);
  const cnt=Array(g_groups.length).fill(0);
  for(const v of arr){
    for(let i=0;i<g_groups.length;i++){ if(v>=g_groups[i].from && v<=g_groups[i].to){ cnt[i]++; break; } }
  }
  const parts=[]; for(let i=0;i<g_groups.length;i++){ if(cnt[i]) parts.push(`${g_groups[i].from}-${g_groups[i].to}:${cnt[i]}`); }
  return parts.join(" | ");
}
function renderResults(list){
  const take=parseInt($("#topShow").value,10)||24;
  const out=(list||[]).slice(0,take).map((it,i)=>{
    const arr=it.k.split("-").map(Number);
    const hits=findOccurrences(arr);
    const last=hits.at(-1);
    const lastTxt = last ? (last.date?`#${last.idx} (${last.date})`:`#${last.idx}`) : "‚Äì";
    const total = hits.length;
    return `<div class="fc-line">
      <b>${i+1}. ${it.k.replace(/-/g," ")}</b>
      <span class="badge">Score-Idx: ${it.idx}</span>
      <span class="badge">Gruppen: ${grpInfo(it.k)}</span>
      <span class="badge">Historie: ${total}√ó (letzte: ${lastTxt})</span>
      <button class="secondary" style="margin-left:8px" data-tip="${it.k}">Analysieren</button>
    </div>`;
  }).join("");
  html($("#results"), out || "<div class='fc-line'>(keine Kandidaten)</div>");
}
function finalize(list){
  const out=(list||[]).map((it,i)=>{
    const arr=it.k.split("-").map(Number);
    const hits=findOccurrences(arr);
    const hist=hits.slice(-5).map(h=> h.date?`#${h.idx} (${h.date})`:`#${h.idx}`).join(", ") || "‚Äì";
    return `<div class="fc-line">
      <b>${i+1}. ${it.k.replace(/-/g," ")}</b>
      <span class="badge">Score-Idx: ${it.idx}</span>
      <span class="badge">Gruppen: ${grpInfo(it.k)}</span>
      <div class="small">Historie (letzte 5): ${hist}</div>
    </div>`;
  }).join("");
  html($("#final"), out || "<div class='fc-line'>(keine Daten)</div>");
}

/* ================== Controls ================== */
function computeParams(mode){
  // Langsamer = gr√∂√üere Beam/Branch + Tick-Delay + Zeitlimit hoch
  switch(mode){
    case "eco":   return {beam:4500,  branch:8,  target:120, delay:0};
    case "std":   return {beam:9000,  branch:12, target:360, delay:4};
    case "deep":  return {beam:14000, branch:16, target:900, delay:8};
    case "insane":return {beam:20000, branch:20, target:0,   delay:12}; // 0 = kein Zeitlimit
    default:      return {beam:9000,  branch:12, target:360, delay:4};
  }
}
function startAnalysis(){
  if(!g_draws.length) return alert("Bitte zuerst ein Archiv laden.");
  if(!validateGroups()) return;

  // Spektrum
  const minV=Math.max(1, Math.min(70, parseInt($("#minVal").value,10)||1));
  const maxV=Math.max(minV, Math.min(70, parseInt($("#maxVal").value,10)||70));
  $("#minVal").value=minV; $("#maxVal").value=maxV;

  const S=parseInt($("#kenoType").value,10)||6;
  const mode=$("#computeMode").value; const cp=computeParams(mode);
  const showN=parseInt($("#topShow").value,10)||24;
  const take=Math.max(1, Math.min(10, parseInt($("#genCount").value,10)||5));

  // Farben √ºbernehmen
  for(let i=0;i<g_groups.length;i++){
    if(g_colorInputs[i]){
      g_groups[i].color=g_colorInputs[i].c.value;
      g_groups[i].alpha=Math.max(0,Math.min(1, parseFloat(g_colorInputs[i].a.value)||g_groups[i].alpha));
    }
  }
  localStorage.setItem(CK_GROUPS, JSON.stringify(g_groups));

  // Worker
  buildWorker();
  runState="running";
  $("#start").disabled=true; $("#pause").disabled=false; $("#resume").disabled=true; $("#stop").disabled=false;
  $("#prog").style.display=""; $("#prog").value=0;
  text($("#status"),`Start ‚Äì S=${S} ¬∑ Mode=${mode} ¬∑ Range=${minV}-${maxV} ¬∑ Archiv=${fmt(g_draws.length)} Ziehungen`);
  text($("#liveInfo"),"running");

  worker.postMessage({cmd:"start", cfg:{
    S, minV, maxV,
    drawsAll: g_draws,
    groups: g_groups,
    take, showN,
    beam: cp.beam, branchPerStep: cp.branch,
    targetSec: cp.target,
    tickDelay: cp.delay
  }});
}
function pauseAnalysis(){ if(worker && runState==="running"){ worker.postMessage({cmd:"pause"}); } }
function resumeAnalysis(){ if(worker && runState==="paused"){ worker.postMessage({cmd:"resume"}); } }
function stopAnalysis(){ if(worker){ worker.postMessage({cmd:"stop"}); } }

$("#start").addEventListener("click",startAnalysis);
$("#pause").addEventListener("click",pauseAnalysis);
$("#resume").addEventListener("click",resumeAnalysis);
$("#stop").addEventListener("click",stopAnalysis);

/* ================== Results -> Tippanalyse ================== */
$("#results").addEventListener("click",(e)=>{
  const btn=e.target.closest("button[data-tip]"); if(!btn) return;
  $("#tipInput").value=btn.getAttribute("data-tip").split("-").join(" ");
  document.getElementById("p-tip").scrollIntoView({behavior:"smooth",block:"start"});
  setTimeout(()=>runTipAnalysis(),100);
});
$("#checkTip").addEventListener("click",runTipAnalysis);

function runTipAnalysis(){
  if(!g_draws.length){ alert("Bitte Archiv laden."); return; }
  const raw=String($("#tipInput").value||"").trim();
  let arr=(raw.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(n=>Number.isInteger(n)&&n>=1&&n<=70);
  arr=uniqSorted(arr); if(!arr.length){ alert("Kein Tipp erkannt."); return; }

  // einfache Scoring-Vorschau aus Archiv (ohne Gruppenprofil)
  function freq(draws){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=1&&v<=70) f[v]++; return f; }
  function coMatrix(draws){ const M=Array.from({length:71},()=>Array(71).fill(0)); for(const d of draws){ for(let i=0;i<d.length;i++) for(let j=i+1;j<d.length;j++){ const a=d[i],b=d[j]; if(a>=1&&a<=70&&b>=1&&b<=70){ M[a][b]++; M[b][a]++; } } } return M; }
  function PMI(draws){ const N=draws.length,f=freq(draws),co=coMatrix(draws); const p=Array(71).fill(0).map((_,i)=> i?(f[i]/(N||1)):0); const P=Array.from({length:71},()=>Array(71).fill(0)); for(let a=1;a<=70;a++) for(let b=1;b<=70;b++){ if(a===b){P[a][b]=0;continue;} const pab=co[a][b]/(N||1), den=(p[a]*p[b])||1e-12; P[a][b]=Math.log((pab||1e-12)/den);} return P; }
  function gapHistogram(draws){ const H=Array(70).fill(0); for(const d of draws){ const s=d.slice().sort((a,b)=>a-b); for(let i=1;i<s.length;i++){ const g=s[i]-s[i-1]; if(g>=1&&g<=69) H[g]++; } } for(let i=2;i<=68;i++) H[i]=0.25*H[i-1]+0.5*H[i]+0.25*H[i+1]; let mx=1; for(let i=1;i<=69;i++) if(H[i]>mx) mx=H[i]; for(let i=1;i<=69;i++) H[i]/=mx||1; return H; }
  function baseProb(draws){ const f=freq(draws), p=Array(71).fill(0); for(let i=1;i<=70;i++){ p[i]=(f[i]+0.5); } let s=0; for(let i=1;i<=70;i++) s+=p[i]; for(let i=1;i<=70;i++) p[i]/=s||1; return p; }

  const pBase=baseProb(g_draws), P=PMI(g_draws), gapW=gapHistogram(g_draws);
  function scoreOf(a){
    let sProb=0; for(const v of a) sProb+=Math.log(Math.max(1e-12,pBase[v]));
    let sPair=0; for(let i=0;i<a.length;i++) for(let j=i+1;j<a.length;j++) sPair+=P[a[i]][a[j]];
    const srt=a.slice().sort((x,y)=>x-y);
    let sGap=0; for(let i=1;i<srt.length;i++){ const g=srt[i]-srt[i-1]; if(g>=1&&g<=69) sGap+=gapW[g]; }
    sGap/=Math.max(1,a.length-1);
    return 1.00*sProb + 0.45*sPair + 0.60*sGap;
  }
  const sc=scoreOf(arr);
  const gaps=arr.slice(1).map((v,i)=>v-arr[i]);
  const hits=findOccurrences(arr);
  const last=hits.at(-1);
  $("#tipStatus").style.display="";
  $("#tipStatus").textContent=[
    "Tipp: "+arr.join(" "),
    "Score (relativ): "+sc.toFixed(3),
    "Abst√§nde: ["+gaps.join(", ")+"]",
    "Historie: "+hits.length+"√ó"+(last?` (letzte: ${last.date?("#"+last.idx+" "+last.date):("#"+last.idx)})`:"")
  ].join("\n");
  redrawMap(arr.map(n=>({num:n,rank:1})));
}

/* ================== Wire basic ================== */
})();
</script>