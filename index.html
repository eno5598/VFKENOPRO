<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO Analyzer ‚Äì deterministische Archiv-Auswertung</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111827; --border:#223046; --muted:#263041;
    --text:#e5e7eb; --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444; --pink:#a78bfa;
  }
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  .box{max-width:1140px;margin:0 auto}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px;margin:12px 0 0}
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  input[type="file"],select,input[type="number"],input[type="text"]{
    width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid var(--muted);
    background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);
          border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  progress{width:100%;height:14px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-value{background:#22c55e}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .fc-line{border:1px solid var(--muted);border-radius:8px;padding:6px;margin-bottom:4px}
  .badge{display:inline-block;padding:2px 6px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:6px;font-size:13px}
  .chip{background:var(--bg);border:1px solid var(--muted);border-radius:999px;padding:4px 8px;margin:2px;display:inline-block}
  .row{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
<div class="box">

  <!-- Archiv laden -->
  <div class="panel">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2></div>
    <input type="file" id="file" accept=".csv,.txt,.zip">
    <div class="status" style="margin-top:8px">
      Offizielles ZIP (manuell laden & hier ausw√§hlen):
      <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
    </div>
    <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
  </div>

  <!-- Einstellungen -->
  <div class="panel">
    <div class="ph"><span class="emoji">‚öôÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div style="flex:1 1 220px">
        <label>KENO-Typ</label>
        <select id="kenoType">
          <option value="2">Typ 2</option>
          <option value="3">Typ 3</option>
          <option value="4">Typ 4</option>
          <option value="5">Typ 5</option>
          <option value="6" selected>Typ 6</option>
          <option value="7">Typ 7</option>
          <option value="8">Typ 8</option>
          <option value="9">Typ 9</option>
          <option value="10">Typ 10</option>
        </select>
      </div>
      <div style="flex:1 1 220px">
        <label>Gr√ºndlichkeit</label>
        <select id="mode">
          <option value="normal">Normal</option>
          <option value="medium">Mittel</option>
          <option value="high">High-End</option>
          <option value="exhaustive">Exhaustive-Light</option>
        </select>
      </div>
      <div style="flex:1 1 220px">
        <label>Top-Kombis anzeigen</label>
        <select id="topShow">
          <option value="12">12</option>
          <option value="24" selected>24</option>
          <option value="48">48</option>
          <option value="72">72</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Analyse -->
  <div class="panel" id="p-analyse">
    <div class="ph"><span class="emoji">üîç</span><h2 style="margin:0">Analyse (deterministisch, ohne Simulation)</h2></div>
    <div class="row" style="margin-bottom:8px">
      <button id="start" class="primary">Analyse starten</button>
      <button id="pause" class="secondary" disabled>Pause</button>
      <button id="resume" class="secondary" disabled>Weiter</button>
      <button id="stop" class="danger" disabled>Stopp</button>
      <button id="showFinal" class="secondary" disabled>Top 6 anzeigen</button>
    </div>
    <progress id="prog" value="0" max="1" style="display:none"></progress>
    <div id="status" class="status">bereit</div>
    <div id="results" class="results"></div>
    <div id="finalBlock" class="panel" style="display:none">
      <h3>üèÅ Finale 6 Vorschl√§ge</h3>
      <div id="finalCombos" class="grid"></div>
    </div>
  </div>

  <!-- Tipp-Analyse -->
  <div class="panel" id="p-tip">
    <div class="ph"><span class="emoji">üìù</span><h2 style="margin:0">Tipp-Analyse</h2></div>
    <input type="text" id="tipInput" placeholder="z. B. 10 11 22 24 48 52">
    <button id="checkTip" class="secondary" style="margin-top:6px">Tipp analysieren</button>
    <div id="tipStatus" class="status" style="display:none"></div>
  </div>

</div>

<!-- ======= TEIL 2 direkt HIER drunter einf√ºgen ======= -->
<!-- (Kein zus√§tzlicher <script> Platzhalter n√∂tig) -->
</body>
</html>
<script>
(function(){
"use strict";

/* =============== kleine Helfer =============== */
const $ = s => document.querySelector(s);
const text = (el, s) => { if(el) el.textContent = s; };
const html = (el, s) => { if(el) el.innerHTML = s; };
const uniqSorted = a => Array.from(new Set(a)).sort((x,y)=>x-y);
const fmtInt = n => (n||0).toLocaleString("de-DE");
const pct = x => ((x*100).toFixed(2)+"%").replace(".", ",");

/* =============== Archiv laden (CSV/TXT/ZIP) =============== */
const CACHE_KEY = "keno_det_archive_v2";
let g_draws = [], g_drawSize = 0;

function splitSmart(line){
  if(/\t/.test(line)) return line.split("\t");
  if(line.includes(";")) return line.split(";");
  if(line.includes("|")) return line.split("|");
  if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
  return line.trim().split(/\s+/);
}
function parseTable(text){ return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart); }
function tryZahlHeader(rows){
  if(!rows.length) return null;
  const header = rows[0].map(x=>String(x).trim());
  const idx = [];
  for(let i=0;i<header.length;i++) if(/^zahl\s*\d+$/i.test(header[i])) idx.push(i);
  if(idx.length>=5){
    const lists=[];
    for(let r=1;r<rows.length;r++){
      const nums=idx.map(i=>parseInt(String(rows[r][i]??"").trim(),10)).filter(Number.isInteger);
      if(nums.length) lists.push(nums);
    }
    return {lists, info:`Header erkannt (${idx.length} Zahl-Spalten)`};
  }
  return null;
}
function detectDashCol(rows){
  let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
  let best=-1,score=-1;
  for(let c=0;c<maxCols;c++){
    let sc=0;
    for(const r of rows){
      if(c>=r.length) continue;
      const cell=String(r[c]??"").trim(); if(!cell) continue;
      const parts=cell.split("-");
      if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
    }
    if(sc>score){score=sc;best=c;}
  }
  return best;
}
function fallbackExtract(raw){
  const out=[];
  for(const lnRaw of raw.split(/\r?\n/)){
    const ln=lnRaw.trim(); if(!ln) continue;
    if(/^\d+(?:-\d+)+$/.test(ln)){
      out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); continue;
    }
    const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
    if(nums.length>=5) out.push(nums);
  }
  return out;
}
function loadArchiveFromRawText(raw, sourceLabel){
  text($("#statusTop"), "Analysiere Datei ‚Ä¶");
  const rows=parseTable(raw);
  let lists=[], detected="";
  const h=tryZahlHeader(rows);
  if(h){ lists=h.lists; detected=h.info; }
  else{
    const ncol=detectDashCol(rows);
    if(ncol>=0){
      for(const r of rows){
        if(ncol>=r.length) continue;
        const cell=String(r[ncol]??"").trim(); if(!cell) continue;
        const parts=cell.split("-").map(s=>s.trim());
        if(parts.length && parts.every(p=>/^\d+$/.test(p))) lists.push(parts.map(Number));
      }
      detected="Spalte 1-4-‚Ä¶";
    }else{
      lists=fallbackExtract(raw);
      detected="Fallback: freie Zahlzeilen";
    }
  }
  if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");

  const freq=new Map();
  for(const a of lists){ if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1); }
  let bestLen=0,bestCnt=-1;
  for(const [k,v] of freq.entries()){ if(v>bestCnt){ bestCnt=v; bestLen=k; } }
  if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");

  g_drawSize=bestLen;
  g_draws = lists.filter(a=>a.length===g_drawSize).map(a=>uniqSorted(a.filter(Number.isInteger)));
  if(!g_draws.length) throw new Error("Nach Filter auf dominierende L√§nge keine Ziehungen √ºbrig.");

  try{
    localStorage.setItem(CACHE_KEY, JSON.stringify({draws:g_draws, drawSize:g_drawSize, savedAt:Date.now(), source:sourceLabel||""}));
  }catch{}

  const ts=new Date();
  text($("#statusTop"),
    `Archiv geladen: ${fmtInt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}`+
    (sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:"")+
    `\nGespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`
  );
  html($("#results"),""); $("#finalBlock").style.display="none";
  text($("#status"),"bereit"); $("#prog").style.display="none";
}
async function ensureJSZip(){
  if(window.JSZip) return;
  await new Promise((res,rej)=>{
    const s=document.createElement("script");
    s.src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
    s.onload=res; s.onerror=()=>rej(new Error("JSZip laden fehlgeschlagen"));
    document.head.appendChild(s);
  });
}
async function handleAnyFile(file){
  if(!file){ text($("#statusTop"),"Keine Datei gew√§hlt."); return; }
  text($("#statusTop"),`Lese Datei: ${file.name}`);
  const name=(file.name||"").toLowerCase();
  try{
    if(name.endsWith(".zip")){
      await ensureJSZip();
      const ab=await file.arrayBuffer();
      const zip=await JSZip.loadAsync(ab);
      const candidates=[];
      zip.forEach((path, entry)=>{
        const p=path.toLowerCase();
        if(p.endsWith(".csv")||p.endsWith(".txt")){
          const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
          candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
        }
      });
      if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden.");
      candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
      const target=candidates[0];
      text($("#statusTop"),`Entpacke & lese: ${target.path}`);
      let raw="";
      try{ raw=await target.entry.async("string"); }
      catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
      loadArchiveFromRawText(raw, `ZIP: ${target.path}`);
    }else{
      let txt="";
      try{ txt=await file.text(); }
      catch(_){ const u8=new Uint8Array(await file.arrayBuffer()); txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
      loadArchiveFromRawText(txt, file.name||"Upload");
    }
  }catch(e){
    text($("#statusTop"),"Fehler beim Lesen: "+(e?.message||e));
    g_draws=[]; g_drawSize=0;
  }
}
$("#file").addEventListener("change", ()=> handleAnyFile($("#file").files[0]));
(function initFromCache(){
  try{
    const raw=localStorage.getItem(CACHE_KEY);
    if(raw){
      const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
      if(g_draws.length){
        const ts=obj.savedAt?new Date(obj.savedAt):new Date();
        const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
        text($("#statusTop"),
          `Archiv aus Browser geladen: ${fmtInt(g_draws.length)} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize})${src}\n`+
          `Gespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}`
        );
      }else{
        text($("#statusTop"),"Bereit. (Kein Archiv geladen)");
      }
    }else{
      text($("#statusTop"),"Bereit. (Kein Archiv geladen)");
    }
  }catch{ text($("#statusTop"),"Bereit. (Kein Archiv geladen)"); }
})();

/* =============== Deterministische Analyse via Worker =============== */
let worker=null;
let globalAgg = new Map(); // key -> aggregated score
let runState = "idle";

function buildWorker(){
  if(worker) try{worker.terminate();}catch{}
  const code = `
  let CFG=null; // {S, mode, topM, maxTemplates, drawsAll, drawsSub, showN}
  // ===== Helpers =====
  const uniqSorted = a => Array.from(new Set(a)).sort((x,y)=>x-y);
  const clamp = (x,a,b)=> Math.max(a, Math.min(b, x));

  function freq(draws){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=1&&v<=70) f[v]++; return f; }
  function lastSeen(draws){ const last=Array(71).fill(-1); for(let i=0;i<draws.length;i++) for(const v of draws[i]) last[v]=i; return last; }
  function coMatrix(draws){
    const M=Array.from({length:71},()=>Array(71).fill(0));
    for(const d of draws){
      for(let i=0;i<d.length;i++) for(let j=i+1;j<d.length;j++){
        const a=d[i],b=d[j]; if(a>=1&&a<=70&&b>=1&&b<=70){ M[a][b]++; M[b][a]++; }
      }
    }
    return M;
  }
  function PMIfromCo(draws){
    const N=draws.length; const f=freq(draws);
    const co=coMatrix(draws);
    const p=Array(71).fill(0).map((_,i)=> i? (f[i]/(N||1)) : 0);
    const PMI=Array.from({length:71},()=>Array(71).fill(0));
    for(let a=1;a<=70;a++) for(let b=1;b<=70;b++){
      if(a===b){PMI[a][b]=0;continue;}
      const pab=co[a][b]/(N||1);
      const denom=(p[a]*p[b])||1e-12;
      PMI[a][b] = Math.log((pab||1e-12)/denom);
    }
    return {PMI,co};
  }

  function gapHistogram(draws){
    const H=Array(70).fill(0);
    for(const d of draws){
      const s=d.slice().sort((a,b)=>a-b);
      for(let i=1;i<s.length;i++){
        const g=s[i]-s[i-1];
        if(g>=1 && g<=69) H[g]++;
      }
    }
    // Gl√§tten
    for(let i=2;i<=68;i++) H[i]=0.25*H[i-1]+0.5*H[i]+0.25*H[i+1];
    // Normiert
    let mx=1; for(let i=1;i<=69;i++) if(H[i]>mx) mx=H[i];
    for(let i=1;i<=69;i++) H[i]/=mx||1;
    return H;
  }
  function gapTransition(draws){
    // Matrix T[g1][g2]: H√§ufigkeit, dass nach g1 ‚Üí g2 folgt
    const T=Array.from({length:70},()=>Array(70).fill(0));
    for(const d of draws){
      const s=d.slice().sort((a,b)=>a-b);
      const gaps=[];
      for(let i=1;i<s.length;i++){
        const g=s[i]-s[i-1];
        if(g>=1&&g<=69) gaps.push(g);
      }
      for(let i=1;i<gaps.length;i++){
        T[gaps[i-1]][gaps[i]]++;
      }
    }
    // leichte Gl√§ttung
    for(let a=1;a<=69;a++){
      let row=T[a];
      // Nachbarn mischen
      for(let b=2;b<=68;b++) row[b]=0.2*row[b-1]+0.6*row[b]+0.2*row[b+1];
    }
    return T;
  }

  function baseProb(drawsSub, drawsAll, mode){
    const f=freq(drawsSub), last=lastSeen(drawsAll), Nall=drawsAll.length;
    const p=Array(71).fill(0);
    for(let i=1;i<=70;i++){
      const due=(last[i]<0)?Nall:(Nall-1-last[i]);
      const boost = mode==='high'? (1+Math.min(2.0, due/Math.max(10,Nall/20)))
                  : mode==='medium'? (1+Math.min(1.6, due/Math.max(12,Nall/30)))
                                   : (1+Math.min(1.3, due/Math.max(15,Nall/35)));
      p[i]=(f[i]+0.5)*boost;
    }
    // Segmente angleichen
    for(const [L,R,w] of [[1,23,1.03],[24,47,1.01],[48,70,1.00]]){
      let s=0; for(let i=L;i<=R;i++) s+=p[i];
      const avg=s/Math.max(1,R-L+1);
      for(let i=L;i<=R;i++) p[i]=0.8*p[i]+0.2*avg*w;
    }
    // normieren
    let s=0; for(let i=1;i<=70;i++) s+=p[i]; if(s<=0){for(let i=1;i<=70;i++) p[i]=1/70;} else {for(let i=1;i<=70;i++) p[i]/=s;}
    return p;
  }

  // ===== Score (additiv; sp√§ter in Index 0..100 umgerechnet) =====
  function scoreOf(arr, ctx){
    const {PMI, gapW, pBase} = ctx;
    let sProb=0; for(const v of arr) sProb+=Math.log(Math.max(1e-12, pBase[v]));
    let sPair=0; for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) sPair+=PMI[arr[i]][arr[j]];
    let sGap =0; for(let i=1;i<arr.length;i++){ const g=arr[i]-arr[i-1]; if(g>=1&&g<=69) sGap+=gapW[g]; }
    sGap/=Math.max(1,arr.length-1);
    let low=0,mid=0,high=0; for(const v of arr){ if(v<=23) low++; else if(v<=47) mid++; else high++; }
    const bal = 1 - (Math.abs(low-mid)+Math.abs(mid-high)+Math.abs(low-high))/(2*arr.length);
    return 1.00*sProb + 0.35*sPair + 0.70*sGap + 0.25*bal;
  }

  // ===== Template-Generatoren (deterministisch) =====
  function topGaps(H, k){ // meist genutzte Gaps
    const items=[]; for(let g=1;g<=69;g++) items.push({g,w:H[g]});
    items.sort((a,b)=> b.w-a.w || a.g-b.g);
    return items.slice(0,k).map(x=>x.g);
  }
  function bestGapChain(T, startG, len){ // Viterbi √§hnlich, greedy
    const chain=[startG];
    for(let i=1;i<len;i++){
      const prev=chain[i-1];
      let best=prev, bestv=-1;
      for(let g=1;g<=69;g++){
        const v=T[prev][g];
        if(v>bestv){ bestv=v; best=g; }
      }
      chain.push(best);
    }
    return chain;
  }

  function makeTemplates(H, T, S, mode){
    const need=S-1;
    const tgs = topGaps(H, Math.min(10, need+3));
    const list=[];

    // T1: repeat h√§ufigster Gap
    if(tgs.length) list.push(Array(need).fill(tgs[0]));

    // T2: alternierend top2
    if(tgs.length>=2){
      const a=tgs[0], b=tgs[1]; const t=[];
      for(let i=0;i<need;i++) t.push(i%2===0?a:b);
      list.push(t);
    }

    // T3: direkt Top-(need)
    if(tgs.length>=need) list.push(tgs.slice(0,need));

    // T4..: markov-artig aus jedem der Top3 starten
    const topStart = tgs.slice(0, Math.min(3, tgs.length));
    for(const s of topStart){
      list.push(bestGapChain(T, s, need));
    }

    // T5: ‚Äûbreiter‚Äú Mix (f√ºr High/Exhaustive)
    if(mode!=="normal"){
      const mix=[];
      for(let i=0;i<need;i++){
        mix.push(tgs[i%Math.max(1,Math.min(4,tgs.length))]);
      }
      list.push(mix);
    }

    // deduplizieren
    const seen=new Set(); const out=[];
    for(const t of list){
      const k=t.join(",");
      if(!seen.has(k)){ seen.add(k); out.push(t); }
    }
    return out;
  }

  // ===== Kandidaten-Builder: alle Startwerte f√ºr Templates =====
  function seqFromTemplate(start, templ){
    const out=[start]; let cur=start;
    for(const g of templ){ cur+=g; out.push(cur); }
    return out;
  }
  function validSeq(arr){ // 1..70 und strikt steigend
    if(arr[0]<1 || arr[arr.length-1]>70) return false;
    for(let i=1;i<arr.length;i++) if(!(arr[i]>arr[i-1])) return false;
    return true;
  }

  function start(cfg){
    CFG=cfg; // {S, mode, topM, maxTemplates, drawsAll, drawsSub, showN}
    // Stats
    const H = gapHistogram(CFG.drawsAll);
    const T = gapTransition(CFG.drawsAll);
    const {PMI} = PMIfromCo(CFG.drawsSub);
    const pBase = baseProb(CFG.drawsSub, CFG.drawsAll, CFG.mode);
    const ctx = {PMI, gapW: H, pBase};

    // Templates erzeugen
    let templs = makeTemplates(H, T, CFG.S, CFG.mode);
    templs = templs.slice(0, CFG.maxTemplates);

    // Startbereich je Template
    const results=[]; // {k, scoreRaw}
    let processed=0, total=0;

    // vorab total bestimmen (ungef√§hr)
    for(const tp of templs){
      let inc=0; for(const g of tp) inc+=g;
      const startMax = 70 - inc;
      if(startMax>=1) total += startMax;
    }
    total=Math.max(1,total);

    for(let ti=0; ti<templs.length; ti++){
      const tp=templs[ti];
      let inc=0; for(const g of tp) inc+=g;
      const startMax = 70 - inc;
      if(startMax<1){ postMessage({type:"templ", idx:ti+1, total:templs.length, starts:0}); continue; }

      // deterministisch √ºber alle Startpunkte
      for(let s=1; s<=startMax; s++){
        const seq = seqFromTemplate(s, tp);
        if(!validSeq(seq)) continue;

        const sc = scoreOf(seq, ctx);
        results.push({k:seq.join("-"), scoreRaw:sc});
        processed++;
        if(processed%500===0){
          postMessage({type:"progress", done:processed, total, templ:ti+1, templTotal:templs.length});
        }
      }
      postMessage({type:"templ", idx:ti+1, total:templs.length, starts:startMax});
    }

    // Top-Kombis ausw√§hlen (deterministisch)
    results.sort((a,b)=> b.scoreRaw-a.scoreRaw || (a.k<b.k?-1:1));
    const top = results.slice(0, CFG.showN);

    // Score-Index 0..100 (min-max aus Topfenster)
    let min=+Infinity,max=-Infinity;
    for(const t of top){ if(t.scoreRaw<min) min=t.scoreRaw; if(t.scoreRaw>max) max=t.scoreRaw; }
    const idx = t=> (max>min)? ( (t-min)/(max-min)*100 ) : 100;

    const out = top.map(t=>({k:t.k, idx:+idx(t.scoreRaw).toFixed(1), raw:+t.scoreRaw.toFixed(3)}));
    postMessage({type:"done", out});
  }

  onmessage = e=>{
    const m=e.data;
    if(m.cmd==="start") start(m.cfg);
  };
  `;
  const blob=new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  worker = new Worker(url);
  worker.onmessage = onWorkerMsg;
  worker.onerror = e=>{
    text($("#status"), "Fehler im Worker: "+(e.message||"unbekannt"));
    resetButtons();
  };
}

function onWorkerMsg(ev){
  const m=ev.data;
  if(m.type==="progress"){
    const p = m.total? Math.min(1, m.done/m.total) : 0;
    $("#prog").style.display=""; $("#prog").value=p;
    const line = `Template ${m.templ}/${m.templTotal} ¬∑ gepr√ºft ${fmtInt(m.done)} / ~${fmtInt(m.total)} Startwerte`;
    text($("#status"), line);
  }else if(m.type==="templ"){
    const prev = $("#status").textContent;
    text($("#status"), prev + `\nTemplate ${m.idx}/${m.total}: Startwerte=${fmtInt(m.starts)}`);
  }else if(m.type==="done"){
    renderResults(m.out||[]);
    finalizeTop6From(m.out||[]);
    resetButtons(true);
  }
}
function resetButtons(hasFinal){
  $("#start").disabled=false; $("#pause").disabled=true; $("#resume").disabled=true; $("#stop").disabled=true;
  $("#showFinal").disabled = !hasFinal;
  $("#prog").style.display="none";
}

/* =============== UI-Render =============== */
function renderResults(list){
  const take = parseInt($("#topShow").value,10)||24;
  const out = (list||[]).slice(0,take).map((it,i)=>{
    const nums = it.k.replace(/-/g," ");
    return `<div class="fc-line">
      <b>${i+1}. ${nums}</b>
      <span class="badge">Score-Index: ${it.idx}</span>
      <span class="badge" title="interner Rohwert (nur Info)">raw: ${it.raw}</span>
      <button class="secondary" style="margin-left:8px" data-tip="${it.k}">Tipp analysieren</button>
    </div>`;
  }).join("");
  html($("#results"), out || "<div class='fc-line'>(keine Kandidaten)</div>");
}

function finalizeTop6From(list){
  const top6 = (list||[]).slice(0,6);
  $("#finalBlock").style.display="";
  if(!top6.length){ html($("#finalCombos"), "<div class='fc-line'>(keine Daten)</div>"); return; }
  const out = top6.map(it=>`<div class="fc-line"><b>${it.k.replace(/-/g," ")}</b><span class="badge">Score-Index: ${it.idx}</span></div>`).join("");
  html($("#finalCombos"), out);
}

/* =============== Steuerung =============== */
function configByMode(mode, S){
  // bestimmt, wie viele Templates & wie gro√ü die Subbasis ist
  if(mode==="normal")   return {sub:1000, topM:32, maxTemplates:4};
  if(mode==="medium")   return {sub:3000, topM:36, maxTemplates:6};
  if(mode==="high")     return {sub:Infinity, topM:40, maxTemplates:8};
  if(mode==="exhaustive")return {sub:Infinity, topM:40, maxTemplates:10};
  return {sub:1000, topM:32, maxTemplates:4};
}

function startAnalysis(){
  if(!g_draws.length){ alert("Bitte zuerst ein Archiv laden."); return; }
  const S = parseInt($("#kenoType").value,10)||6;
  const modeSel = $("#mode").value;
  const cfg0 = configByMode(modeSel, S);

  const drawsSub = Number.isFinite(cfg0.sub) ? g_draws.slice(0, Math.min(cfg0.sub, g_draws.length)) : g_draws;

  buildWorker();
  $("#start").disabled=true; $("#pause").disabled=true; $("#resume").disabled=true; $("#stop").disabled=true;
  $("#showFinal").disabled=true;
  $("#prog").style.display=""; $("#prog").value=0;
  text($("#status"), `Starte‚Ä¶ Modus: ${modeSel.toUpperCase()} ¬∑ S=${S} ¬∑ SubArchiv=${fmtInt(drawsSub.length)} / ${fmtInt(g_draws.length)}`);

  worker.postMessage({cmd:"start", cfg:{
    S,
    mode: modeSel,
    topM: cfg0.topM,
    maxTemplates: cfg0.maxTemplates,
    drawsAll: g_draws,
    drawsSub,
    showN: parseInt($("#topShow").value,10)||24
  }});
}

$("#start").addEventListener("click", startAnalysis);
$("#showFinal").addEventListener("click", ()=> {
  // Falls schon gerendert, einfach nach unten scrollen
  document.getElementById("finalBlock").scrollIntoView({behavior:"smooth", block:"start"});
});

/* =============== Tipp-Analyse (gleiche Scoring-Logik, positiv angezeigt) =============== */
$("#results").addEventListener("click",(e)=>{
  const btn=e.target.closest("button[data-tip]");
  if(!btn) return;
  const nums=btn.getAttribute("data-tip").split("-").map(x=>parseInt(x,10)).filter(Number.isInteger);
  $("#tipInput").value=nums.join(" ");
  // scroll zu Analyse
  document.getElementById("p-tip").scrollIntoView({behavior:"smooth", block:"start"});
  setTimeout(()=>runTipAnalysis(nums), 100);
});
$("#checkTip").addEventListener("click", ()=>{
  const raw=String($("#tipInput").value||"").trim();
  const nums=(raw.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
  runTipAnalysis(nums);
});

function runTipAnalysis(arr){
  if(!g_draws.length){ alert("Bitte Archiv laden."); return; }
  arr=uniqSorted(arr||[]);
  if(!arr.length){ alert("Kein Tipp erkannt."); return; }

  // Stats aus ganzem Archiv, wie im Worker
  function freq(draws){ const f=Array(71).fill(0); for(const d of draws) for(const v of d) if(v>=1&&v<=70) f[v]++; return f; }
  function lastSeen(draws){ const last=Array(71).fill(-1); for(let i=0;i<draws.length;i++) for(const v of draws[i]) last[v]=i; return last; }
  function coMatrix(draws){
    const M=Array.from({length:71},()=>Array(71).fill(0));
    for(const d of draws){
      for(let i=0;i<d.length;i++) for(let j=i+1;j<d.length;j++){
        const a=d[i],b=d[j]; if(a>=1&&a<=70&&b>=1&&b<=70){ M[a][b]++; M[b][a]++; }
      }
    }
    return M;
  }
  function PMIfromCo(draws){
    const N=draws.length; const f=freq(draws);
    const co=coMatrix(draws);
    const p=Array(71).fill(0).map((_,i)=> i? (f[i]/(N||1)) : 0);
    const PMI=Array.from({length:71},()=>Array(71).fill(0));
    for(let a=1;a<=70;a++) for(let b=1;b<=70;b++){
      if(a===b){PMI[a][b]=0;continue;}
      const pab=co[a][b]/(N||1);
      const denom=(p[a]*p[b])||1e-12;
      PMI[a][b] = Math.log((pab||1e-12)/denom);
    }
    return {PMI,co};
  }
  function gapHistogram(draws){
    const H=Array(70).fill(0);
    for(const d of draws){
      const s=d.slice().sort((a,b)=>a-b);
      for(let i=1;i<s.length;i++){
        const g=s[i]-s[i-1];
        if(g>=1 && g<=69) H[g]++;
      }
    }
    for(let i=2;i<=68;i++) H[i]=0.25*H[i-1]+0.5*H[i]+0.25*H[i+1];
    let mx=1; for(let i=1;i<=69;i++) if(H[i]>mx) mx=H[i];
    for(let i=1;i<=69;i++) H[i]/=mx||1;
    return H;
  }
  function baseProb(draws){
    const f=freq(draws), last=lastSeen(draws), Nall=draws.length;
    const p=Array(71).fill(0);
    for(let i=1;i<=70;i++){
      const due=(last[i]<0)?Nall:(Nall-1-last[i]);
      const boost = 1 + Math.min(1.6, due/Math.max(12, Nall/30));
      p[i]=(f[i]+0.5)*boost;
    }
    let s=0; for(let i=1;i<=70;i++) s+=p[i]; if(s<=0){for(let i=1;i<=70;i++) p[i]=1/70;} else {for(let i=1;i<=70;i++) p[i]/=s;}
    return p;
  }
  const pBase=baseProb(g_draws);
  const {PMI}=PMIfromCo(g_draws.slice(-Math.min(5000,g_draws.length)));
  const gapW=gapHistogram(g_draws);

  function scoreRaw(a){
    let sProb=0; for(const v of a) sProb+=Math.log(Math.max(1e-12,pBase[v]));
    let sPair=0; for(let i=0;i<a.length;i++) for(let j=i+1;j<a.length;j++) sPair+=PMI[a[i]][a[j]];
    let sGap=0; for(let i=1;i<a.length;i++){ const g=a[i]-a[i-1]; if(g>=1&&g<=69) sGap+=gapW[g]; }
    sGap/=Math.max(1,a.length-1);
    let low=0,mid=0,high=0; for(const v of a){ if(v<=23) low++; else if(v<=47) mid++; else high++; }
    const bal = 1 - (Math.abs(low-mid)+Math.abs(mid-high)+Math.abs(low-high))/(2*a.length);
    return 1.00*sProb + 0.35*sPair + 0.70*sGap + 0.25*bal;
  }

  const sc = scoreRaw(arr);
  // F√ºr einen verst√§ndlichen Wert normalisieren: gegen 5 zuf√§llig gezogene vergleichen (Deterministik: take mid quantiles)
  const probes=[];
  for(let i=0;i<5;i++){
    // deterministische "Pseudo-Proben": feste Offsets
    const base = 1+i*13;
    const pool = [];
    for(let v=1; v<=70; v+= ((i%2)?3:4)) pool.push(v);
    pool.length = Math.max(arr.length, Math.min(pool.length, arr.length+2));
    const cand = uniqSorted(pool.slice(0,arr.length));
    probes.push(scoreRaw(cand));
  }
  const min=Math.min(sc, ...probes), max=Math.max(sc, ...probes);
  const idx = (max>min)? ((sc-min)/(max-min)*100) : 100;

  const gaps = arr.slice(1).map((v,i)=> v-arr[i]);
  const out = [
    "Tipp: "+arr.join(" "),
    "Score-Index (0‚Äì100): "+idx.toFixed(1),
    "Muster-Abst√§nde: ["+gaps.join(", ")+"]",
    "Segmente: ‚â§23="+arr.filter(v=>v<=23).length+" | 24‚Äì47="+arr.filter(v=>v>=24&&v<=47).length+" | ‚â•48="+arr.filter(v=>v>=48).length
  ].join("\n");
  $("#tipStatus").style.display=""; $("#tipStatus").textContent=out;
}

/* =============== Klicks registrieren =============== */
$("#results").addEventListener("click",(e)=>{
  const btn=e.target.closest("button[data-tip]");
  if(!btn) return;
  const nums=btn.getAttribute("data-tip").split("-").map(x=>parseInt(x,10)).filter(Number.isInteger);
  $("#tipInput").value=nums.join(" ");
  document.getElementById("p-tip").scrollIntoView({behavior:"smooth", block:"start"});
  setTimeout(()=>runTipAnalysis(nums),100);
});

/* =============== Buttons =============== */
function finalizeTop6From(list){
  // schon oben definiert ‚Äì hier nur Alias (falls direkt aufgerufen)
  const top6 = (list||[]).slice(0,6);
  $("#finalBlock").style.display="";
  if(!top6.length){ html($("#finalCombos"), "<div class='fc-line'>(keine Daten)</div>"); return; }
  const out = top6.map(it=>`<div class="fc-line"><b>${it.k.replace(/-/g," ")}</b><span class="badge">Score-Index: ${it.idx}</span></div>`).join("");
  html($("#finalCombos"), out);
}

function renderResults(list){
  // schon oben definiert ‚Äì Alias
  const take = parseInt($("#topShow").value,10)||24;
  const out = (list||[]).slice(0,take).map((it,i)=>{
    const nums = it.k.replace(/-/g," ");
    return `<div class="fc-line">
      <b>${i+1}. ${nums}</b>
      <span class="badge">Score-Index: ${it.idx}</span>
      <span class="badge" title="interner Rohwert (nur Info)">raw: ${it.raw}</span>
      <button class="secondary" style="margin-left:8px" data-tip="${it.k}">Tipp analysieren</button>
    </div>`;
  }).join("");
  html($("#results"), out || "<div class='fc-line'>(keine Kandidaten)</div>");
}

$("#start").addEventListener("click", startAnalysis);

})();
</script>