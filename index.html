<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>KENO Tool • Group – v12.3 Offline</title>
<style>
  :root{
    --bg:#070a0f; --panel:#0f1421; --muted:#a2adbd; --text:#eef2f7;
    --accent:#22c55e; --warn:#f59e0b; --bad:#ef4444; --info:#60a5fa;
    --hit:#22c55e; --miss:#6b7280;
    --g1:#4f83ff; --g2:#22C55E; --g3:#A855F7; --g4:#F59E0B; --g5:#EF4444; --g6:#06B6D4; --g7:#C084FC;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(64,128,255,.12), transparent 50%),
      radial-gradient(800px 400px at 110% 10%, rgba(192,132,252,.12), transparent 50%),
      linear-gradient(180deg, #06080c 0%, #0b0f18 100%);
    padding-bottom:90px;
  }
  header{position:sticky; top:0; z-index:7; backdrop-filter: blur(8px);
    background:linear-gradient(180deg, rgba(15,20,33,.85), rgba(15,20,33,.55));
    border-bottom:1px solid rgba(255,255,255,.06); padding:14px 16px; display:flex; align-items:center; gap:12px}
  .brand{display:flex; align-items:center; gap:10px; font-weight:900; letter-spacing:.3px; font-size:1.05rem;}
  .brand .dot{width:10px;height:10px;border-radius:50%;
    background:conic-gradient(from 180deg, #4f83ff, #22C55E, #A855F7, #F59E0B, #EF4444, #06B6D4, #C084FC, #4f83ff)}
  main{max-width:1140px; margin:0 auto; padding:18px; display:grid; grid-template-columns: 1.05fr 1fr; gap:14px}
  @media (max-width:1080px){ main{grid-template-columns:1fr} }
  .card{background:linear-gradient(180deg, rgba(21,28,44,.92), rgba(15,20,33,.95)); border:1px solid rgba(255,255,255,.06); border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.4), inset 0 1px 0 rgba(255,255,255,.04)}
  .col-span-2{grid-column:1 / -1}
  .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
  .btn{border:1px solid rgba(255,255,255,.08); background:#0f1524; color:#eef2f7; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600}
  .btn:hover{transform:translateY(-1px)}
  .btn.ok{background:linear-gradient(180deg,#28c76f,#19995a); border:none}
  .btn.warn{background:linear-gradient(180deg,#f59e0b,#d97706); border:none}
  input[type="file"], input[type="number"], select, input[type="text"]{
    background:#0f1524; color:#eef2f7; border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius:10px; outline:none;
  }
  a.link{color:#93c5fd; text-decoration:none; border-bottom:1px dotted #93c5fd}
  .small{font-size:.85rem} .muted{color:var(--muted)}
  .badge{padding:4px 8px; border-radius:999px; background:#0f172a; border:1px solid rgba(255,255,255,.1); font-size:.8rem}
  .hide{display:none!important}

  /* Gruppen */
  .groupBar{display:grid; grid-template-columns: auto 1fr auto auto auto; align-items:center; gap:10px;
    padding:8px 10px; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06); margin-bottom:8px}
  .qtyCtl{display:flex; gap:6px; align-items:center}
  .qtyBtn{width:32px; height:32px; display:grid; place-items:center; font-weight:900; border-radius:8px; cursor:pointer;
    border:1px solid rgba(255,255,255,.12); background:#0e1528}
  .qty{min-width:48px; text-align:center; font-weight:800; padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:#0e1528}

  /* MAP */
  .mapWrap{display:grid; gap:12px; position:relative}
  .mapGroup{border:1px solid rgba(255,255,255,.08); border-radius:14px; overflow:hidden; background:rgba(255,255,255,.02)}
  .mapHeader{display:flex; align-items:center; gap:10px; padding:10px 12px; font-weight:800}
  .mapHeader .status{margin-left:auto}
  .board{display:grid; grid-template-columns: repeat(10, 1fr); gap:10px; padding:12px; user-select:none}
  .cell{aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; border-radius:14px;
    background:#0f1930; position:relative; overflow:hidden; font-weight:900; border:1px solid rgba(255,255,255,.10);
    font-size:1.15rem; letter-spacing:.3px; cursor:default; transition:transform .2s ease}
  .cell.hit{box-shadow: inset 0 0 0 3px var(--hit), 0 0 18px rgba(34,197,94,.35)}
  .cell.miss{opacity:.45; filter:grayscale(.2)}
  .pulse{animation:pulse .38s ease}
  @keyframes pulse{ 0%{transform:scale(1)} 50%{transform:scale(1.08)} 100%{transform:scale(1)} }
  .g1{background:linear-gradient(180deg, rgba(79,131,255,.24), transparent 55%), #0f1930}
  .g2{background:linear-gradient(180deg, rgba(34,197,94,.24), transparent 55%), #0f1930}
  .g3{background:linear-gradient(180deg, rgba(168,85,247,.26), transparent 55%), #0f1930}
  .g4{background:linear-gradient(180deg, rgba(245,158,11,.26), transparent 55%), #0f1930}
  .g5{background:linear-gradient(180deg, rgba(239,68,68,.26), transparent 55%), #0f1930}
  .g6{background:linear-gradient(180deg, rgba(6,182,212,.26), transparent 55%), #0f1930}
  .g7{background:linear-gradient(180deg, rgba(192,132,252,.26), transparent 55%), #0f1930}
  .stepBadge{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    font-weight:900; font-size:72px; letter-spacing:2px; padding:18px 28px;
    border-radius:18px; background:rgba(0,0,0,.5); border:1px solid rgba(255,255,255,.25);
    box-shadow:0 10px 40px rgba(0,0,0,.55); backdrop-filter: blur(5px);
    opacity:0; transition:.25s; color:#fff; text-shadow:0 2px 8px rgba(0,0,0,.6); z-index:20; pointer-events:none;
  }
  .stepBadge.show{opacity:1}
  @media (max-width:600px){ .stepBadge{font-size:48px} }

  /* Results */
  .resTable{width:100%; border-collapse:collapse; font-size:.95rem}
  .resTable th, .resTable td{border-bottom:1px solid rgba(255,255,255,.08); padding:10px 6px; text-align:left; vertical-align:middle}
  .combo{display:flex; gap:6px; flex-wrap:nowrap; overflow-x:auto; padding:2px 0}
  .pill{padding:3px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:#101a2f; font-family:ui-monospace,Consolas,Menlo,monospace; font-weight:800}
  .nowrap{white-space:nowrap}

  /* Sticky action bar (mobile) */
  .stickyBar{position:fixed; bottom:10px; left:50%; transform:translateX(-50%); z-index:50;
    background:linear-gradient(180deg, rgba(21,28,44,.95), rgba(15,20,33,.95)); border:1px solid rgba(255,255,255,.12);
    border-radius:14px; padding:8px; display:flex; gap:8px; box-shadow:0 12px 40px rgba(0,0,0,.5)}
  @media (min-width:901px){ .stickyBar{display:none} }

  /* Import progress & log */
  .progressWrap{display:flex; align-items:center; gap:10px}
  progress{width:220px; height:16px}
  .log{max-height:150px; overflow:auto; padding:8px; background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08); border-radius:8px; font-size:.9rem}
  .log .ok{color:#86efac}
  .log .skip{color:#fde68a}
  .log .bad{color:#fca5a5}
</style>
</head>
<body>
<header>
  <div class="brand"><span class="dot"></span> KENO Tool • Group</div>
</header>

<main>
  <!-- Archiv -->
  <section class="card col-span-2">
    <h2>1) Archiv</h2>
    <div class="controls" style="margin-bottom:6px">
      <input id="fileInput" type="file" accept=".zip,.csv,.txt" />
      <a class="btn" href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">Archiv herunterladen</a>
      <button class="btn" id="btnClear">Archiv löschen</button>
      <button class="btn" id="btnExportArc">Archiv exportieren</button>
      <input id="importArc" type="file" accept=".json" style="display:none">
      <button class="btn" id="btnImportArc">Archiv importieren</button>
      <span class="badge" id="bDraws">0 Ziehungen</span>
      <span class="badge" id="bRange">—</span>
      <span class="badge" id="bSaved">—</span>
    </div>
    <div class="progressWrap" style="margin-bottom:6px">
      <progress id="prog" max="100" value="0"></progress>
      <span class="small muted" id="progText">Bereit</span>
    </div>
    <div class="log" id="log"></div>
  </section>

  <!-- Gruppen -->
  <section class="card">
    <h2>2) Gruppen & Keno-Typ</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Keno-Typ&nbsp;<select id="kenoType"></select></label>
      <label class="small"><input type="checkbox" id="autoOverlap" checked> Maximale Überschneidung automatisch (Keno-Typ − 1)</label>
      <label>Max. Überschneidung&nbsp;<input id="overlapMax" type="number" min="0" max="20" value="7" style="width:90px" disabled></label>
      <span class="badge" id="sumBadge">Summe: 0</span>
      <span class="badge" id="fitBadge">—</span>
      <button class="btn" id="btnResetQuotas">Quoten zurücksetzen</button>
      <label class="small"><input type="checkbox" id="toggleStatus"> Gruppenstatus anzeigen</label>
    </div>
    <div id="groups"></div>
  </section>

  <!-- Map (read-only + live overlay) -->
  <section class="card" id="mapCard">
    <h2>3) Map (1–70)</h2>
    <div id="mapWrap" class="mapWrap">
      <div id="stepBadge" class="stepBadge">1</div>
    </div>
  </section>

  <!-- Generator -->
  <section class="card col-span-2">
    <h2>4) Generator</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Anzahl Ergebnisse&nbsp;<input id="genCount" type="number" min="1" max="20" value="5" style="width:100px"></label>
      <button class="btn ok" id="btnGenerate">Generieren</button>
      <button class="btn" id="btnClearRes">Alle Ergebnisse löschen</button>
      <button class="btn" id="btnExport">CSV Export</button>
    </div>
    <table class="resTable" id="resTable">
      <thead><tr><th>#</th><th>Kombi</th><th class="nowrap">Aktion</th></tr></thead>
      <tbody id="resBody"></tbody>
    </table>
  </section>

  <!-- Batch-Analyse -->
  <section class="card col-span-2" id="analysisCard">
    <h2>5) Batch-Analyse (Top-N Ergebnisse ↔ Archiv)</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Top-N&nbsp;<input id="batchN" type="number" min="1" value="5" style="width:80px"></label>
      <label>Schwelle A (≥)&nbsp;<input id="batchThrA" type="number" min="1" max="20" value="7" style="width:80px"></label>
      <label>Schwelle B (≥)&nbsp;<input id="batchThrB" type="number" min="1" max="20" value="8" style="width:80px"></label>
      <button class="btn ok" id="btnBatch">Batch analysieren</button>
      <button class="btn" id="btnBatchCSV">CSV Export</button>
    </div>
    <table class="resTable" id="batchTable">
      <thead><tr><th>#</th><th>Kombi</th><th>Max Überlappung</th><th id="colA">Überlappung ≥A</th><th id="colB">Überlappung ≥B</th><th>Volltreffer</th><th>Map</th></tr></thead>
      <tbody id="batchBody"></tbody>
    </table>
  </section>
</main>

<!-- Sticky action bar (mobile) -->
<div class="stickyBar">
  <button class="btn ok" id="sbGen">Generieren</button>
  <button class="btn" id="sbExp">CSV Export</button>
  <button class="btn" id="sbAna">Analyse</button>
</div>

<script>
/* ======================= Minimal ZIP Reader (offline) ======================= */
async function unzipCSVTXT(arrayBuffer, onProgress, onFile){
  const dv = new DataView(arrayBuffer);
  const u8 = new Uint8Array(arrayBuffer);
  const sigEOCD = 0x06054b50, sigCDH = 0x02014b50, sigLFH = 0x04034b50;
  function readUint32LE(i){ return dv.getUint32(i, true); }
  function readUint16LE(i){ return dv.getUint16(i, true); }
  function findEOCD(){
    const maxBack = Math.min(u8.length, 0xFFFF + 22);
    for(let i=u8.length-22; i>=u8.length-maxBack; i--){
      if(readUint32LE(i) === sigEOCD) return i;
    }
    return -1;
  }
  const eocd = findEOCD();
  if(eocd < 0) throw new Error('EOCD nicht gefunden (keine gültige ZIP).');
  const cdSize = readUint32LE(eocd + 12);
  const cdOffset = readUint32LE(eocd + 16);

  let ptr = cdOffset;
  const entries = [];
  while(ptr < cdOffset + cdSize){
    if(readUint32LE(ptr) !== sigCDH) throw new Error('CD Header erwartet.');
    const compMethod = readUint16LE(ptr + 10);
    const compSize = readUint32LE(ptr + 20);
    const nameLen = readUint16LE(ptr + 28);
    const extraLen = readUint16LE(ptr + 30);
    const commentLen = readUint16LE(ptr + 32);
    const lfhOffset = readUint32LE(ptr + 42);
    const nameBytes = u8.slice(ptr + 46, ptr + 46 + nameLen);
    const name = new TextDecoder().decode(nameBytes);
    entries.push({name, compMethod, compSize, lfhOffset});
    ptr += 46 + nameLen + extraLen + commentLen;
  }

  for(let i=0;i<entries.length;i++){
    const ent = entries[i];
    onProgress && onProgress(Math.round((i/entries.length)*100), 'Entpacke: '+ent.name);
    const lower = ent.name.toLowerCase();
    if(!/\.(csv|txt)$/.test(lower) || /(?:\bplus\b|\+5)/.test(lower)){ continue; }
    const p = ent.lfhOffset;
    if(readUint32LE(p) !== sigLFH) continue;
    const nameLen = readUint16LE(p + 26);
    const extraLen = readUint16LE(p + 28);
    const dataStart = p + 30 + nameLen + extraLen;
    const dataEnd = dataStart + ent.compSize;
    const slice = u8.slice(dataStart, dataEnd);
    let text = '';
    if(ent.compMethod === 0){
      text = new TextDecoder().decode(slice);
    }else if(ent.compMethod === 8){
      if(typeof DecompressionStream === 'undefined'){
        onFile && onFile(ent.name, null, 'deflate_nicht_unterstützt');
        continue;
      }
      const stream = new Blob([slice]).stream().pipeThrough(new DecompressionStream('deflate-raw'));
      const decompressed = await new Response(stream).arrayBuffer();
      text = new TextDecoder().decode(new Uint8Array(decompressed));
    }else{
      onFile && onFile(ent.name, null, 'methode_'+ent.compMethod);
      continue;
    }
    onFile && onFile(ent.name, text, null);
  }
  onProgress && onProgress(100, 'Fertig');
}

/* ===== IndexedDB helper ===== */
const DB_NAME='keno_db_offline_v12_3', STORE='kv';
function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME,1);
    req.onupgradeneeded = ()=>{ const db=req.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE); };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbSet(key, value){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite'); const st = tx.objectStore(STORE);
    st.put(value, key);
    tx.oncomplete = ()=> resolve();
    tx.onerror = ()=> reject(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const req=st.get(key);
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbDel(key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(STORE,'readwrite'); const st=tx.objectStore(STORE); st.delete(key);
    tx.oncomplete = ()=> resolve();
    tx.onerror = ()=> reject(tx.error);
  });
}

/* ===== App state ===== */
const CACHE_KEY="archive";
const state = {
  draws: [], freq: Array(71).fill(0), kenoType: 8,
  quotas: [0,0,0,0,0,0,0], results: [], liveTip: new Set(),
  animating: false, userOverlapCustom: false,
};

const els = {
  fileInput: document.getElementById('fileInput'),
  prog: document.getElementById('prog'),
  progText: document.getElementById('progText'),
  log: document.getElementById('log'),

  bDraws: document.getElementById('bDraws'),
  bRange: document.getElementById('bRange'),
  bSaved: document.getElementById('bSaved'),

  groups: document.getElementById('groups'),
  kenoType: document.getElementById('kenoType'),
  overlapMax: document.getElementById('overlapMax'),
  autoOverlap: document.getElementById('autoOverlap'),
  mapWrap: document.getElementById('mapWrap'),
  mapCard: document.getElementById('mapCard'),
  stepBadge: document.getElementById('stepBadge'),

  resBody: document.getElementById('resBody'),
  sumBadge: document.getElementById('sumBadge'),
  fitBadge: document.getElementById('fitBadge'),
  toggleStatus: document.getElementById('toggleStatus'),

  batchN: document.getElementById('batchN'),
  batchThrA: document.getElementById('batchThrA'),
  batchThrB: document.getElementById('batchThrB'),
  batchBody: document.getElementById('batchBody'),
  colA: document.getElementById('colA'),
  colB: document.getElementById('colB'),

  importArc: document.getElementById('importArc'),
};

/* ===== helpers ===== */
function ymd(d){ if(!d) return null; const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0'); return Number(`${y}${m}${dd}`); }
function ymdStr(i){ if(!i) return '—'; const s=String(i); return `${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6,8)}`; }
function groupRange(i){ return `${i*10+1}–${i*10+10}` }
const gClass = i => ['g1','g2','g3','g4','g5','g6','g7'][i];

/* ===== Persistenz Archiv ===== */
async function saveArchive(){ try{ await idbSet(CACHE_KEY,{draws:state.draws,savedAt:Date.now()}); els.bSaved.textContent='gespeichert: '+new Date().toLocaleString(); }catch{ els.bSaved.textContent='Speichern fehlgeschlagen'; } }
async function loadArchive(){ try{ const p=await idbGet(CACHE_KEY); if(!p){ els.bSaved.textContent='kein gespeichertes Archiv'; return;} state.draws=Array.isArray(p.draws)?p.draws:[]; recomputeStats(); els.bSaved.textContent=p.savedAt?('gespeichert: '+new Date(p.savedAt).toLocaleString()):'geladen'; }catch{ els.bSaved.textContent='Laden fehlgeschlagen'; } }
async function clearArchive(){ try{ await idbDel(CACHE_KEY);}catch{} state.draws=[]; state.freq=Array(71).fill(0); els.bDraws.textContent='0 Ziehungen'; els.bRange.textContent='—'; els.bSaved.textContent='—'; renderMap(); }

/* ===== Import progress & log ===== */
function logLine(type,msg){ const div=document.createElement('div'); div.className=type; div.textContent=msg; els.log.appendChild(div); els.log.scrollTop=els.log.scrollHeight; }
function setProgress(v, txt){ els.prog.value=v; els.progText.textContent=txt||''; }

/* ===== Datei laden & parsen ===== */
function parseRowToNumbers(row){
  const nums=[]; for(const cell of row){ const ints=String(cell).match(/\d+/g)||[]; for(const t of ints){ const v=Number(t); if(v>=1&&v<=70) nums.push(v); } }
  const seen=new Set(); const out=[]; for(const n of nums){ if(!seen.has(n)){ seen.add(n); out.push(n); if(out.length>=20) break; } } return out;
}
function looksLikeDate(s){
  const a=s.match(/^(\d{4})[-/.](\d{1,2})[-/.](\d{1,2})$/); if(a){ const d=new Date(+a[1],+a[2]-1,+a[3]); return isFinite(d)?d:null; }
  const b=s.match(/^(\d{1,2})[.](\d{1,2})[.](\d{4})$/); if(b){ const d=new Date(+b[3],+b[2]-1,+b[1]); return isFinite(d)?d:null; }
  return null;
}
function parseCSVText(text){
  const lines = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n');
  return lines.map(l => l.trim()).filter(Boolean).map(l => l.split(/[;,\t ]+/));
}
async function parseTextFile(name, text){
  if(/(?:\bplus\b|\+5)/i.test(name)){ logLine('skip', 'ignoriert (Plus): '+name); return {draws:[]}; }
  const rows = parseCSVText(text);
  const result=[];
  for(const row of rows){
    const nums = parseRowToNumbers(row);
    if(nums.length>=10){
      const dateCell=row.find(c=>looksLikeDate(String(c))); const d = dateCell?looksLikeDate(String(dateCell)):null;
      result.push({date: d? ymd(d): null, numbers: nums});
    }
  }
  logLine('ok', `übernommen: ${name} (${result.length} Ziehungen)`);
  return {draws: result};
}
async function handleZipOrTextFile(file){
  els.log.textContent=''; setProgress(1,'Lese Datei…');
  const name = file.name.toLowerCase();
  if(name.endsWith('.zip')){
    const ab=await file.arrayBuffer();
    setProgress(5,'ZIP wird geöffnet…');
    const all=[];
    await unzipCSVTXT(ab,
      (v,txt)=> setProgress(v, txt),
      async (path, text, err)=>{
        if(err){
          if(err==='deflate_nicht_unterstützt'){ logLine('bad','Deflate nicht unterstützt – bitte CSV/TXT direkt laden: '+path); }
          else{ logLine('skip','übersprungen: '+path+' ('+err+')'); }
          return;
        }
        const {draws} = await parseTextFile(path, text);
        all.push(...draws);
      }
    );
    applyDraws(all);
  }else{
    const txt=await file.text();
    const {draws} = await parseTextFile(name, txt);
    applyDraws(draws);
    setProgress(100,'Fertig');
  }
}
function applyDraws(draws){
  const key = d => (d.date||'') + '|' + d.numbers.slice().sort((a,b)=>a-b).join('-');
  const dedup=new Map(); for(const d of draws) dedup.set(key(d), d);
  state.draws = [...dedup.values()].sort((a,b)=> (a.date||0) - (b.date||0));
  recomputeStats();
  saveArchive();
}
function recomputeStats(){
  state.freq = Array(71).fill(0);
  for(const d of state.draws){ for(const n of d.numbers){ state.freq[n]++; } }
  if(state.draws.length){
    const ds = state.draws.map(d=>d.date).filter(Boolean).sort((a,b)=>a-b);
    els.bRange.textContent = `${ymdStr(ds[0])} – ${ymdStr(ds[ds.length-1])}`;
  } else { els.bRange.textContent = '—'; }
  els.bDraws.textContent = `${state.draws.length.toLocaleString('de-DE')} Ziehungen`;
  renderMap();
}

/* ===== Gruppen & Map (READ-ONLY + Live overlay) ===== */
function buildKenoType(){
  els.kenoType.innerHTML='';
  for(let k=2;k<=10;k++){
    const o=document.createElement('option'); o.value=k; o.textContent=k; if(k===state.kenoType) o.selected=true;
    els.kenoType.appendChild(o);
  }
  const applyAutoOverlap = ()=>{
    if(els.autoOverlap.checked){
      const v = Math.max(0, state.kenoType - 1);
      els.overlapMax.value = v;
      els.overlapMax.disabled = true;
      state.userOverlapCustom = false;
    }else{
      els.overlapMax.disabled = false;
      state.userOverlapCustom = true;
    }
  };
  els.kenoType.addEventListener('change', e=>{
    state.kenoType = Number(e.target.value);
    if(els.autoOverlap.checked){ els.overlapMax.value = Math.max(0, state.kenoType-1); }
    updateSumBadge(); renderMap();
  });
  els.autoOverlap.addEventListener('change', applyAutoOverlap);
  els.overlapMax.addEventListener('input', ()=>{ state.userOverlapCustom = true; });
  // initial
  els.autoOverlap.checked = true; els.overlapMax.value = Math.max(0, state.kenoType-1); els.overlapMax.disabled = true;
}
function renderGroups(){
  els.groups.innerHTML='';
  for(let i=0;i<7;i++){
    const row=document.createElement('div'); row.className='groupBar';
    row.innerHTML = `
      <span class="dot" style="width:12px;height:12px;border-radius:50%;background:var(--${gClass(i)})"></span>
      <strong>${groupRange(i)}</strong>
      <span class="badge status" id="st${i}">${state.quotas[i]===0?'GESCHLOSSEN':'offen'}</span>
      <div class="qtyCtl">
        <button class="qtyBtn" data-i="${i}" data-act="dec">−</button>
        <div class="qty" id="q${i}">${state.quotas[i]}</div>
        <button class="qtyBtn" data-i="${i}" data-act="inc">+</button>
      </div>`;
    els.groups.appendChild(row);
  }
  els.groups.querySelectorAll('.qtyBtn').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const i=Number(e.currentTarget.getAttribute('data-i'));
      const act=e.currentTarget.getAttribute('data-act');
      const cur=state.quotas[i];
      const next=Math.max(0, Math.min(10, act==='inc'?cur+1:cur-1));
      if(next===cur) return;
      state.quotas[i]=next;
      document.getElementById('q'+i).textContent=next;
      document.getElementById('st'+i).textContent= next===0?'GESCHLOSSEN':'offen';
      updateSumBadge();
      renderMap();
    });
  });
  updateSumBadge();
  updateStatusVisibility();
}
function buildMap(){
  // Preserve badge while rebuilding
  const badge = els.stepBadge;
  const wrap = els.mapWrap;
  wrap.innerHTML='';
  for(let i=0;i<7;i++){
    const box=document.createElement('div'); box.className='mapGroup';
    box.innerHTML = `<div class="mapHeader" style="background:linear-gradient(90deg, var(--${gClass(i)}) 0%, transparent 60%)">
        <span>${groupRange(i)}</span>
        <span class="badge status" id="mst${i}">${state.quotas[i]===0?'GESCHLOSSEN':'offen'}</span>
      </div>
      <div class="board" id="grid${i}"></div>`;
    wrap.appendChild(box);
    const grid=box.querySelector('#grid'+i);
    for(let n=i*10+1; n<=i*10+10; n++){
      const cell=document.createElement('div');
      cell.className=`cell ${gClass(i)}`;
      cell.dataset.n=n;
      cell.textContent=n;
      grid.appendChild(cell);
    }
  }
  wrap.appendChild(badge); // re-attach overlay
  renderMap();
}
function updateStatusVisibility(){
  const show = els.toggleStatus.checked;
  document.querySelectorAll('.status').forEach(el=> el.classList.toggle('hide', !show));
}
function getCellEl(n){ return document.querySelector('.cell[data-n="'+n+'"]'); }
function renderMap(){
  for(let i=0;i<7;i++){
    const badge=document.getElementById('mst'+i);
    if(badge) badge.textContent = state.quotas[i]===0 ? 'GESCHLOSSEN' : 'offen';
  }
  const hits=state.liveTip;
  document.querySelectorAll('.board .cell').forEach(cell=>{
    const n=Number(cell.dataset.n || cell.textContent);
    cell.classList.remove('hit','miss');
    if(hits.size>0){
      if(hits.has(n)) cell.classList.add('hit'); else cell.classList.add('miss');
    }
  });
}
function updateSumBadge(){
  const sum=state.quotas.reduce((a,b)=>a+b,0);
  els.sumBadge.textContent=`Summe: ${sum}`;
  els.fitBadge.textContent = sum===state.kenoType ? 'passt' : `(${sum}/${state.kenoType})`;
}

/* ===== Utilities ===== */
function sample(pool){ const i=Math.floor(Math.random()*pool.length); return pool.splice(i,1)[0]; }
function overlapCount(a,b){
  let i=0,j=0,c=0;
  const x=a.slice().sort((m,n)=>m-n), y=b.slice().sort((m,n)=>m-n);
  while(i<x.length && j<y.length){
    if(x[i]===y[j]){ c++; i++; j++; }
    else if(x[i]<y[j]) i++; else j++;
  }
  return c;
}

/* ===== Generator with overlap constraint + animation ===== */
function generateOne(){
  const nums=[];
  for(let gi=0; gi<7; gi++){
    const need=state.quotas[gi]; if(need===0) continue;
    const start=gi*10+1, end=gi*10+10;
    const pool=[]; for(let n=start;n<=end;n++) if(!nums.includes(n)) pool.push(n);
    for(let k=0;k<need;k++){ if(!pool.length) break; nums.push(sample(pool)); }
  }
  return nums.sort((a,b)=>a-b);
}
function passesOverlapLimit(arr, limit){
  if(!state.draws.length) return true; // no archive => allow all
  for(const d of state.draws){
    if(overlapCount(arr, d.numbers) > limit) return false;
  }
  return true;
}
function generate(){
  if(state.animating) return;
  const inputEl=document.getElementById('genCount');
  const count = Math.max(1, Math.min(20, Number(inputEl.value)||5));
  inputEl.value = count;
  const sum = state.quotas.reduce((a,b)=>a+b,0);
  if(sum !== state.kenoType){ alert('Summe der Gruppen muss dem Keno-Typ entsprechen.'); return; }
  const overlapLimit = Math.max(0, Math.min(20, Number(els.overlapMax.value)|| (state.kenoType-1)));

  const out=[]; const seen=new Set();
  let attempts=0, maxAttempts=Math.max(1000, count*2000); // großzügig, wegen Filter
  while(out.length<count && attempts<maxAttempts){
    attempts++;
    const nums=generateOne();
    const key=nums.join('-');
    if(seen.has(key)) continue;
    if(!passesOverlapLimit(nums, overlapLimit)) continue;
    seen.add(key); out.push(nums);
  }
  if(out.length<count){
    alert(`Nur ${out.length}/${count} Kombinationen gefunden, die die Überschneidung ≤ ${overlapLimit} erfüllen. Bitte Quoten oder Überschneidung lockern.`);
  }
  state.results=out;
  renderResults();
  animateCombos(out);
}
function animateCombos(combos){
  if(!combos.length) return;
  state.animating=true;
  const badge=els.stepBadge;
  window.scrollTo({top:els.mapCard.offsetTop-70, behavior:'smooth'});
  let idx=0;
  const playNext=()=>{
    if(idx>=combos.length){ state.animating=false; state.liveTip=new Set(); renderMap(); badge.classList.remove('show'); return; }
    const combo=combos[idx];
    badge.textContent = (idx+1).toString();
    badge.classList.add('show');
    let i=0;
    const step = ()=>{
      if(i>combo.length){
        setTimeout(()=>{ badge.classList.remove('show'); idx++; setTimeout(playNext, 350); }, 400);
        return;
      }
      state.liveTip = new Set(combo.slice(0,i));
      renderMap();
      if(i>0){
        const el=getCellEl(combo[i-1]); if(el){ el.classList.add('pulse'); setTimeout(()=>el.classList.remove('pulse'), 380); }
      }
      i++;
      setTimeout(step, 260);
    };
    step();
  };
  playNext();
}

/* ===== Results ===== */
function renderResults(){
  const tb=els.resBody; tb.innerHTML='';
  state.results.forEach((arr,i)=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${i+1}</td>
      <td><div class="combo">${arr.map(n=>`<span class="pill">${n}</span>`).join('')}</div></td>
      <td class="nowrap">
        <button class="btn small" data-act="copy" data-i="${i}">Kopieren</button>
        <button class="btn small" data-act="map" data-i="${i}">Map anzeigen</button>
      </td>`;
    tb.appendChild(tr);
  });
  tb.querySelectorAll('button').forEach(b=>{
    const i=Number(b.getAttribute('data-i')); const act=b.getAttribute('data-act');
    b.addEventListener('click', ()=>{
      const arr=state.results[i]; if(!arr) return;
      if(act==='copy'){ navigator.clipboard.writeText(arr.join(' ')); b.textContent='Kopiert'; setTimeout(()=>b.textContent='Kopieren',800); }
      if(act==='map'){ state.liveTip = new Set(arr); renderMap(); window.scrollTo({top:els.mapCard.offsetTop-70, behavior:'smooth'}); }
    });
  });
}
function clearResults(){
  state.results=[]; els.resBody.innerHTML=''; state.liveTip=new Set(); renderMap();
}
function exportCSV(){
  const rows=[['#','Kombi']];
  state.results.forEach((arr,i)=> rows.push([i+1, arr.join(' ')]));
  const csv = rows.map(r=>r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(';')).join('\n');
  const blob=new Blob([csv], {type:'text/csv;charset=utf-8'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='keno_ergebnisse.csv'; a.click(); URL.revokeObjectURL(a.href);
}

/* ===== Batch-Analyse ===== */
function batchOverlapCount(a,b){
  let i=0,j=0,c=0;
  const x=a.slice().sort((m,n)=>m-n), y=b.slice().sort((m,n)=>m-n);
  while(i<x.length && j<y.length){
    if(x[i]===y[j]){ c++; i++; j++; }
    else if(x[i]<y[j]) i++; else j++;
  }
  return c;
}
function analyzeOneAgainstArchive(tip, thrA, thrB){
  let maxOv=0, cA=0, cB=0, cFull=0;
  for(const d of state.draws){
    const ov = batchOverlapCount(tip, d.numbers);
    if(ov>maxOv) maxOv=ov;
    if(ov>=thrA) cA++;
    if(ov>=thrB) cB++;
    if(ov===tip.length) cFull++;
  }
  return {maxOv, cA, cB, cFull};
}
function updateBatchHeaders(){
  const a = Number(els.batchThrA.value)||7;
  const b = Number(els.batchThrB.value)||8;
  els.colA.textContent = `Überlappung ≥${a}`;
  els.colB.textContent = `Überlappung ≥${b}`;
}
function batchAnalyze(){
  if(!state.results.length){ alert('Bitte zuerst Ergebnisse generieren.'); return; }
  if(!state.draws.length){ alert('Bitte zuerst ein Archiv laden.'); return; }
  const N = Math.max(1, Math.min(state.results.length, Number(els.batchN.value)||5));
  els.batchN.value = N;
  const thrA = Math.max(1, Number(els.batchThrA.value)||7);
  const thrB = Math.max(1, Number(els.batchThrB.value)||8);
  updateBatchHeaders();
  const top = state.results.slice(0,N);
  const rows=[];
  els.batchBody.innerHTML='';
  top.forEach((arr,idx)=>{
    const {maxOv,cA,cB,cFull} = analyzeOneAgainstArchive(arr, thrA, thrB);
    const tr=document.createElement('tr');
    tr.innerHTML = `<td>${idx+1}</td>
      <td><div class="combo">${arr.map(n=>`<span class="pill">${n}</span>`).join('')}</div></td>
      <td>${maxOv}</td><td>${cA}</td><td>${cB}</td><td>${cFull}</td>
      <td><button class="btn small" data-i="${idx}" data-act="map">Map</button></td>`;
    els.batchBody.appendChild(tr);
    rows.push({rank:idx+1, kombi:arr.join(' '), max_overlap:maxOv, geA:cA, geB:cB, voll:cFull});
  });
  els.batchBody.querySelectorAll('button').forEach(b=>{
    b.addEventListener('click', ()=>{
      const i=Number(b.getAttribute('data-i'));
      const arr=top[i];
      state.liveTip = new Set(arr);
      renderMap();
      window.scrollTo({top:els.mapCard.offsetTop-70, behavior:'smooth'});
    });
  });
  batchAnalyze._csv = rows;
}
function batchCSV(){
  const rows = batchAnalyze._csv || [];
  if(!rows.length){ alert('Bitte zuerst Batch analysieren.'); return; }
  const a = Number(els.batchThrA.value)||7, b=Number(els.batchThrB.value)||8;
  const header = ['#','Kombi','Max Überlappung',`Überlappung ≥${a}`,`Überlappung ≥${b}`,'Volltreffer'];
  const data = [header, ...rows.map(r=>[r.rank, r.kombi, r.max_overlap, r.geA, r.geB, r.voll])];
  const csv = data.map(r=>r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(';')).join('\n');
  const blob=new Blob([csv], {type:'text/csv;charset=utf-8'});
  const aEl=document.createElement('a'); aEl.href=URL.createObjectURL(blob); aEl.download='keno_batch_analyse.csv'; aEl.click(); URL.revokeObjectURL(aEl.href);
}

/* ===== Events ===== */
els.fileInput.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  await handleZipOrTextFile(f);
});
document.getElementById('btnClear').addEventListener('click', ()=>{ if(confirm('Archiv wirklich löschen?')) clearArchive(); });
document.getElementById('btnResetQuotas').addEventListener('click', ()=>{ state.quotas=[0,0,0,0,0,0,0]; renderGroups(); buildMap(); updateSumBadge(); });
document.getElementById('btnGenerate').addEventListener('click', generate);
document.getElementById('btnClearRes').addEventListener('click', clearResults);
document.getElementById('btnExport').addEventListener('click', exportCSV);
document.getElementById('btnBatch').addEventListener('click', batchAnalyze);
document.getElementById('btnBatchCSV').addEventListener('click', batchCSV);
els.batchThrA.addEventListener('input', updateBatchHeaders);
els.batchThrB.addEventListener('input', updateBatchHeaders);
document.getElementById('btnExportArc').addEventListener('click', ()=>{
  const payload={draws: state.draws, exportedAt: Date.now()};
  const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='keno_archiv.json'; a.click(); URL.revokeObjectURL(a.href);
});
document.getElementById('btnImportArc').addEventListener('click', ()=> els.importArc.click());
els.importArc.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const obj = JSON.parse(await f.text());
    if(!Array.isArray(obj.draws)) throw new Error('Invalid');
    state.draws = obj.draws;
    recomputeStats();
    await saveArchive();
  }catch{ alert('Import fehlgeschlagen.'); }
});
// Sticky bar actions
document.getElementById('sbGen').addEventListener('click', ()=>document.getElementById('btnGenerate').click());
document.getElementById('sbExp').addEventListener('click', ()=>document.getElementById('btnExport').click());
document.getElementById('sbAna').addEventListener('click', ()=>{
  document.getElementById('analysisCard').scrollIntoView({behavior:'smooth', block:'start'});
});
els.toggleStatus.addEventListener('change', ()=>{ updateStatusVisibility(); });

/* ===== Init ===== */
(async function init(){
  buildKenoType(); renderGroups(); buildMap(); updateSumBadge(); updateBatchHeaders();
  await loadArchive();
})();
</script>
</body>
</html>
